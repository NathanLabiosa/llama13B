{"question": "The access matrix approach to protection has the difficulty that", "choices": [{"label": "A", "text": "the matrix, if stored directly, is large and can be clumsy to manage"}, {"label": "B", "text": "it is not capable of expressing complex protection requirements"}, {"label": "C", "text": "deciding whether a process has access to a resource is undecidable"}, {"label": "D", "text": "there is no way to express who has rights to change the access matrix itself"}], "answerKey": "A", "model_answer": ""}
{"question": "An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y. Which of the following sets of integers could possibly be the set of all common divisors of two integers?", "choices": [{"label": "A", "text": "{-6,-2, -1, 1, 2, 6}"}, {"label": "B", "text": "{-6, -2, -1, 0, 1, 2, 6}"}, {"label": "C", "text": "{-6, -3, -2, -1, 1, 2, 3, 6}"}, {"label": "D", "text": "{-6, -3, -2, -1, 0, 1, 2, 3, 6}"}], "answerKey": "C", "model_answer": ""}
{"question": "In the NoNicks operating system, the time required by a single file-read operation has four nonoverlapping components:\ndisk seek time-25 msec\ndisk latency time-8 msec\ndisk transfer time- 1 msec per 1,000 bytes\noperating system overhead-1 msec per 1,000 bytes + 10 msec\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes. The ratio of-the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately", "choices": [{"label": "A", "text": "1:4"}, {"label": "B", "text": "1:3.5"}, {"label": "C", "text": "1:1"}, {"label": "D", "text": "1.1:1"}], "answerKey": "B", "model_answer": "LECTURE: A file-read operation involves reading data from a file on a disk. The time required for a file-read operation has four nonoverlapping components:\ndisk seek time: the time required to move the read/write head to the disk block containing the data\ndisk latency time: the time required to service the request to read data\ndisk transfer time: the time required to transfer the data from the disk to the memory\noperating system overhead: the time required to handle the file-read operation within the operating system\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read retrieved blocks of 4,000 bytes. The larger block size in version 2 means that there are fewer disk head movements to retrieve the same amount of data. So, the time required for disk seek time and disk transfer time is less in version 2 than in version 1.\nThe ratio of the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately 1:1. This means that the operating system overhead time is the same in both versions, and the smaller number of disk head movements in version 2 offsets the higher disk latency time."}
{"question": "You want to cluster 7 points into 3 clusters using the k-Means Clustering algorithm. Suppose after the first iteration, clusters C1, C2 and C3 contain the following two-dimensional points: C1 contains the 2 points: {(0,6), (6,0)} C2 contains the 3 points: {(2,2), (4,4), (6,6)} C3 contains the 2 points: {(5,5), (7,7)} What are the cluster centers computed for these 3 clusters?", "choices": [{"label": "A", "text": "C1: (3,3), C2: (4,4), C3: (6,6)"}, {"label": "B", "text": "C1: (3,3), C2: (6,6), C3: (12,12)"}, {"label": "C", "text": "C1: (6,6), C2: (12,12), C3: (12,12)"}, {"label": "D", "text": "C1: (0,0), C2: (48,48), C3: (35,35)"}], "answerKey": "A", "model_answer": "LECTURE: After the first iteration of the k-Means Clustering algorithm, the cluster centers are the two points within the cluster that have the lowest sum of squared distances to all points in the cluster. To understand this, consider the distance between a cluster center and a cluster point. This distance is the sum of the squared differences between the cluster center's coordinates and the point's coordinates. For example, if the cluster center is (3, 3) and the point is (1, 1), the distance between the cluster center and the point is (3 - 1)^2 + (3 - 1)^2 = 4.\nThe algorithm begins with any selection of points as the initial cluster centers. Then, for each point in the dataset, the algorithm assigns the point to the cluster with the lowest sum of squared distances to its cluster centers. After the first iteration, the clusters are updated with the new assignment of points."}
{"question": "Any set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. Which of the following is NOT complete?", "choices": [{"label": "A", "text": "{AND, NOT}"}, {"label": "B", "text": "{NOT, OR}"}, {"label": "C", "text": "{AND, OR}"}, {"label": "D", "text": "{NAND}"}], "answerKey": "C", "model_answer": ""}
{"question": "Consider the collection of all undirected graphs with 10 nodes and 6 edges. Let M and m, respectively, be the maximum and minimum number of connected components in any graph in the collection. If a graph has no selfloops and there is at most one edge between any pair of nodes, which of the following is true?", "choices": [{"label": "A", "text": "M = 10, m = 10"}, {"label": "B", "text": "M = 10, m = 1"}, {"label": "C", "text": "M = 7, m = 4"}, {"label": "D", "text": "M = 6, m = 4"}], "answerKey": "C", "model_answer": ""}
{"question": "Resolution theorem proving for showing that a formula of propositional logic is not satisfiable has which of the following properties?\nI. It is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nII. It is a complete proof system in the sense that there is a proof of unsatisfiability for every unsa tisfiable formula of propositional logic.\nIII. It is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "C", "model_answer": "LECTURE: A proof system is a collection of rules that can be used to prove the validity of a proposition.\nA sound proof system is a proof system that, when a proof can be constructed according to the rules of the proof system, the proposition being proved is actually valid.\nA complete proof system is a sound proof system that, for any proposition, either a proof of the proposition's validity can be constructed according to the rules of the proof system, or a proof of the proposition's invalidity can be constructed.\nA succinct proof system is a proof system in which the length of a proof is never an excessively long function of the size of the proposition being proved.\nSOLUTION: Resolution is a proof system for propositional logic. It is a complete and sound proof system, and it is also succinct. So, resolution proves the following theorems:\nA proof system for propositional logic is complete if, for every formula, either a proof of the formula's unsatisfiability can be constructed, or a proof of the formula's satisfiability can be constructed.\nA proof system for propositional logic is sound if, for every formula, a proof of the formula's unsatisfiability can be constructed only if the formula is unsatisfiable.\nA proof system for propositional logic is succinct if, for every unsatisfiable formula, a proof of the formula's unsatisfiability can be constructed that is polynomial in the size of the formula."}
{"question": "Which of the following statements describe(s) properties of a purely segmented memory system?\nI. It divides memory into units of equal size.\nII. It permits implementation of virtual memory.\nIII. It suffers from internal fragmentation.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "B", "model_answer": "LECTURE: In a purely segmented memory system, memory is divided into units of fixed size. Each unit is called a segment.\nAll segments are of equal size.\nA segment table is used to keep track of the locations of the segments.\nThe segment table contains an entry for each segment. Each entry describes the location of the segment.\nThe segment table does not contain the data of the segments themselves.\nA pure segmentation system can use up to 100% of the available memory.\nIf a segment is too small, it may not be used. This is called internal fragmentation.\nSOLUTION: I. It divides memory into units of equal size.\nThis describes a purely segmented memory system.\nIII. It suffers from internal fragmentation.\nA purely segmented memory system divides memory into equal segments. But, if a program uses a segment for a small amount of data, the remaining space in the segment will be unused.\nA nonpurely segmented memory system can allocate memory in blocks of arbitrary size. This can reduce internal fragmentation.\nA pure segmentation system can use up to 100% of the available memory. But, this is because a segment is always used, even if it contains only a small amount of data.\nII. It permits implementation of virtual memory.\nVirtual memory is a feature of an operating system. It is not specific to a memory management system."}
{"question": "Which of the following statements about floating-point arithmetic is NOT true?", "choices": [{"label": "A", "text": "It is inherently nonassociative because some numbers have no exact representation."}, {"label": "B", "text": "It is inherently nonassociative because there have to be upper and lower bounds on the size of numbers."}, {"label": "C", "text": "Associativity can be achieved with appropriate roundoff conventions."}, {"label": "D", "text": "Some rational numbers have no exact representation."}], "answerKey": "C", "model_answer": ""}
{"question": "Suppose sharing of tiles in a multilevel directory structure is achieved with directory entries that are links pointing to a node containing information about a shared file. Information in this node includes (1) the owner of the file, (2) a count of the number of links to the tile, and (3) the disk block numbers of the file. What is a primary drawback to this approach to sharing?", "choices": [{"label": "A", "text": "If the owner modifies the file, another user who does not share will see the changes."}, {"label": "B", "text": "If the owner renames the file, other users will not be able to access it."}, {"label": "C", "text": "If the owner is allowed to delete a file, dangling links may result."}, {"label": "D", "text": "If any user who shares the file appends to it, others who share it will not be able to access the new disk blocks."}], "answerKey": "C", "model_answer": ""}
{"question": "Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves. Which of the following data structures will allow mergesort to work in O(n log n) time?\nI. A singly linked list\nII. A doubly linked list\nIII. An array", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "SOLUTION: Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves.\nAn array allows you to access any element in the array in constant time. This makes it possible to merge two halves of a sorted array in O(1) time. So, mergesort will work in O(n log n) time for an array.\nA singly linked list allows you to access any element in the list in O(n) time. This makes it impossible to merge two halves of a sorted linked list in O(1) time. So, mergesort will work in O(n log n) time for a singly linked list.\nA doubly linked list allows you to access any element in the list in O(1) time. This makes it possible to merge two halves of a sorted doubly linked list in O(1) time. So, mergesort will work in O(n log n) time for a doubly linked list."}
{"question": "If p(x) is the minimal-degree interpolating polynomial for the real-valued function f(x) at the n + 1 distinct real numbers x0, .... xn what is the maximum possible degree of p(x)?", "choices": [{"label": "A", "text": "n"}, {"label": "B", "text": "n + 1"}, {"label": "C", "text": "n + 2"}, {"label": "D", "text": "2n"}], "answerKey": "A", "model_answer": ""}
{"question": "An internal hash table has 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is", "choices": [{"label": "A", "text": "3"}, {"label": "B", "text": "8"}, {"label": "C", "text": "10"}, {"label": "D", "text": "13"}], "answerKey": "A", "model_answer": "LECTURE: An internal hash table is a data structure that uses a hash function to map keys to indices. The hash function may have some collisions, which are then resolved by a resolution function.\nWhen you insert elements into an internal hash table, the hash function is used to determine the index where the first element should be placed. If that index is already occupied by another element, the resolution function is used to find an empty index. This process is repeated until all elements are inserted.\nAn example of an internal hash table with 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is 8.\nSOLUTION: The key 10 is inserted into the hash table. The hash function h(10) = 2, and the bucket numbered 2 is where the key 10 is placed.\nThe key 8 is inserted into the hash table. The hash function h(8) = 2, and the bucket numbered 2 is where the key 8 is placed.\nThe key 3 is inserted into the hash table. The hash function h(3) = 3, and the bucket numbered 3 is where the key 3 is placed.\nThe key 13 is inserted into the hash table. The hash function h(13) = 2, and the bucket numbered 2 is where the key 13 is placed."}
{"question": "TCP protocol is responsible (among other things) for", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "C", "model_answer": ""}
{"question": "Let A and B be two sets of words (strings) from \u03a3*, for some alphabet of symbols \u03a3. Suppose that B is a subset of A. Which of the following statements must always be true of A and B ?\nI. If A is finite, then B is finite.\nII. If A is regular, then B is regular.\nIII. If A is context-free, then B is context-free.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: Subsets of sets have the following properties:\nA subset of a set A is itself a set.\nThe subset of a set A is a subset of A.\nIf A and B are subsets of a set S, then the union of A and B is a subset of S.\nThe intersection of A and B is a subset of A.\nThe difference of A and B is a subset of S.\nSOLUTION: B is a subset of A.\nSo, the intersection of A and B is a subset of A.\nThe intersection of A and B is B.\nTherefore, B is a subset of A."}
{"question": "For all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings. Which of the following is true?", "choices": [{"label": "A", "text": "a^M = a"}, {"label": "B", "text": "(ax)^M = (xa)^M"}, {"label": "C", "text": "(xy)^M = y^Mx^M"}, {"label": "D", "text": "None of the above"}], "answerKey": "D", "model_answer": "LECTURE: Functions are made up of components called functions. The output of a function depends on the input.\nIf one function is defined in terms of another function, then the first function is a component of the second function.\nA function made up of only one function is a recursive function.\nA recursive function can define its own output function.\nThe base case of a recursive function is the input that causes the function to stop.\nThe recursive case of a recursive function is when the input is not the base case.\nThe output of a recursive function is caused by the input being the base case.\nSOLUTION: The function x^M is defined recursively as follows.\nIf w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings.\nThen (xy)^M = y^Mx^M."}
{"question": "Which of the following is NOT a reasonable justification for choosing to busy-wait on an asynchronous event?", "choices": [{"label": "A", "text": "The wait is expected to be short."}, {"label": "B", "text": "A busy-wait loop is easier to code than an interrupt handler."}, {"label": "C", "text": "There is no other work for the processor to do."}, {"label": "D", "text": "The program executes on a time-sharing system."}], "answerKey": "D", "model_answer": "LECTURE: Asynchronous events are actions that do not require the processor to be in a particular state when they occur. Instead, they are handled by a separate part of the processor called the interrupt handler. Asynchronous events can be handled in one of two ways:\nA busy-wait loop can be used to handle an asynchronous event. In a busy-wait loop, the processor waits for the asynchronous event in a loop. The processor waits for a short time, checks if the asynchronous event has occurred, and if it has not, waits again. This loop will waste a lot of time as the processor will spend most of its time waiting and not doing any other work.\nAn interrupt handler can be used to handle an asynchronous event. In an interrupt handler, the processor waits for the asynchronous event in a loop. The processor waits for a short time, checks if the asynchronous event has occurred, and if it has not, waits again. This loop is called an interrupt handler because the processor is interrupted when the asynchronous event occurs.\nSOLUTION: A busy-wait loop is easier to code than an interrupt handler.\nA busy-wait loop is easier to code than an interrupt handler.\nThere is no other work for the processor to do.\nA program that executes on a time-sharing system may have other work to do.\nThe wait is expected to be short.\nA busy-wait loop may waste a lot of time if the wait is expected to be short."}
{"question": "The language {ww | w in (0 + 1)*} is", "choices": [{"label": "A", "text": "not accepted by any Turing machine"}, {"label": "B", "text": "accepted by some Turing machine, but by no pushdown automaton"}, {"label": "C", "text": "accepted by some pushdown automaton, but not context-free"}, {"label": "D", "text": "context-free, but not regular"}], "answerKey": "B", "model_answer": ""}
{"question": "Which of the following statements about Ethernets is typically FALSE?", "choices": [{"label": "A", "text": "Ethernets use circuit switching to send messages."}, {"label": "B", "text": "Ethernets use buses with multiple masters."}, {"label": "C", "text": "Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly."}, {"label": "D", "text": "Networks connected by Ethernets are limited in length to a few hundred meters."}], "answerKey": "A", "model_answer": ""}
{"question": "Let P be a procedure that for some inputs calls itself (i.e., is recursive). If P is guaranteed to terminate, which of the following statements must be true?\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: Procedures can have arguments and local variables. Arguments are values passed to a procedure. Local variables are values stored within a procedure.\nA procedure can have one or more arguments. Indices can be used to refer to arguments. An index of 1 is a common convention, but any integer can be used as an index.\nLocal variables are not passed to the procedure that uses them. They are stored within the procedure.\nA procedure can have one or more local variables. Local variables are not passed to the procedure that uses them. They are stored within the procedure.\nA procedure calls other procedures. The procedure that is called may or may not have its own arguments and local variables.\nAn execution path is a sequence of steps in a procedure. Each step is either a statement or a call to another procedure.\nA procedure has a termination path when there is an execution path that does not call itself.\nA procedure is recursive when it calls itself.\nA procedure with a termination path is guaranteed to terminate when it does not call itself."}
{"question": "Which of the following comes closest to being a perfectly secure encryption scheme?", "choices": [{"label": "A", "text": "The Caesar Cipher, a substitution cipher"}, {"label": "B", "text": "DES (Data Encryption Standard), a symmetric-key algorithm"}, {"label": "C", "text": "Enigma, a transposition cipher"}, {"label": "D", "text": "One-time pad"}], "answerKey": "D", "model_answer": ""}
{"question": "Of the following problems concerning a given undirected graph G, which is currently known to be solvable in polynomial time?", "choices": [{"label": "A", "text": "Finding a longest simple cycle in G"}, {"label": "B", "text": "Finding a shortest cycle in G"}, {"label": "C", "text": "Finding ALL spanning trees of G"}, {"label": "D", "text": "Finding a largest clique in G"}], "answerKey": "B", "model_answer": ""}
{"question": "The IP protocol is primarily concerned with", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "A", "model_answer": ""}
{"question": "Of the following, which best approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N?", "choices": [{"label": "A", "text": "1/K"}, {"label": "B", "text": "K-1/K"}, {"label": "C", "text": "log_10 (1/N)"}, {"label": "D", "text": "N-1/m"}], "answerKey": "A", "model_answer": ""}
{"question": "Consider a computer system in which processes can request and release one or more resources. Once a process has been granted a resource, the process has exclusive use of that resource until it is released. If a process requests a resource that is already in use, the process enters a queue for that resource, waiting until the resource is available. Which of the following will NOT deal effectively with the problem of deadlock?", "choices": [{"label": "A", "text": "Giving priorities to processes and ordering the wait queues by priority"}, {"label": "B", "text": "Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all"}, {"label": "C", "text": "Numbering the resources and requiring that processes request resources in order of increasing number"}, {"label": "D", "text": "Having processes time out and restart after a random interval of waiting"}], "answerKey": "A", "model_answer": "LECTURE: A deadlock is a situation in which each process is waiting for one or more resources that are being used by other processes. A process that is waiting for a resource that is in use by another process is said to be in a wait queue.\nWhen a process enters a wait queue, it is added to the back of the queue. As each resource is released, the process that is waiting for that resource is removed from the wait queue and is allowed to begin running.\nSOLUTION: Giving priorities to processes and ordering the wait queues by priority, having a process request all its required resources when it first begins, and restarting if it cannot obtain them all, and numbering the resources and requiring that processes request resources in order of increasing number will not deal effectively with the problem of deadlock.\nDeadlocks can occur even when resources are requested in a prioritized order, and deadlocks can also occur when processes request all their resources at once or when resources are numbered and requests are made in order.\nHaving processes time out and restart after a random interval of waiting can help to eliminate deadlocks. If a process does not obtain a resource within a certain time interval, it will assume that a deadlock is occurring and will restart."}
{"question": "\"Magic memory\"' has two operations: Read and Clear. Both are indivisible and mutually exclusive. Clear sets the magic memory to zero. Read returns a value that represents the number of Read operations since the last Clear operation. Which of the following is (are) true of \"Magic memory\"?\nI. It can provide the functionality of an atomic Test-and-Set.\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nIII. It is only useful on a multiprocessor.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: Atomic operations are indivisible and mutually exclusive. An atomic operation can be thought of as a single step. All of the operations in a multi-step atomic block are indivisible and mutually exclusive.\nA non-atomic operation is divisible. It can be broken into multiple parts, where each part is indivisible and non-mutually exclusive.\nSOLUTION: A magic memory is a type of atomic memory. It has two atomic operations: Read and Clear.\nA magic memory is only useful on a multiprocessor. It can be used to coordinate processes running on a shared-memory multiprocessor.\nA magic memory is not an atomic Test-and-Set. It does not have an atomic Test operation.\nA magic memory is only useful on a multiprocessor. It is not useful on a uniprocessor."}
{"question": "Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?", "choices": [{"label": "A", "text": "Abstract Syntax Tree (AST)"}, {"label": "B", "text": "Attribute Grammar"}, {"label": "C", "text": "Symbol Table"}, {"label": "D", "text": "Semantic Stack"}], "answerKey": "C", "model_answer": "LECTURE: A symbol table is a data structure in a compiler that is responsible for managing information about variables and their attributes. When a variable is declared, the compiler creates a entry in the symbol table for that variable. The entry contains the variable's name and its attributes, such as its data type and memory location.\nThe symbol table is used by the compiler to keep track of variables as they are used in the application. When the compiler encounters a variable in the program, it looks up the variable's entry in the symbol table to learn more about the variable.\nSOLUTION: The symbol table is the data structure in a compiler that is responsible for managing information about variables and their attributes. When a variable is declared, the compiler creates an entry in the symbol table for that variable. The entry contains the variable's name and its attributes, such as its data type and memory location.\nThe symbol table is used by the compiler to keep track of variables as they are used in the application. When the compiler encounters a variable in the program, it looks up the variable's entry in the symbol table to learn more about the variable."}
{"question": "Which of the following algorithms has running time \u0398(n^2) in the worst case but \u0398(n log n) on average?", "choices": [{"label": "A", "text": "Bubblesort"}, {"label": "B", "text": "Mergesort"}, {"label": "C", "text": "Heapsort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "D", "model_answer": ""}
{"question": "Languages with a structure that implements abstract data types (e.g., a C++ class) can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation). Which of the following statements about comparisons between direct and indirect representations is (are) true?\nI. Indirect representation noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: A language with a structure that implements abstract data types can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation).\nFor example, consider a language with a structure called a C++ class. The following code declares a C++ class called MyClass and a variable called myObject of type MyClass:\nclass MyClass {\nprivate: int privateValue;\npublic:\nint publicValue;\nvoid setPrivateValue(int value) {\nprivateValue = value;\n}\nint getPrivateValue() {\nreturn privateValue;\n}\n};\nMyClass myObject;\nThe run-time environment sets the initial value of the privateValue component to 10 and sets the initial value of the publicValue component to 0. The name myObject is bound to a stack pointer referencing the heap storage for the object's component values.\nThe direct representation of an object is determined by how the object's name is bound to component values. The indirect representation of an object is determined by the locations of the component values. For a object, the direct representation is always either direct or indirect. An object's direct representation is direct if the object's name is bound to the component values directly. An object's direct representation is indirect if the object's name is bound to a stack pointer referencing the component values.\nFor an object, the indirect representation is always indirect. An object's indirect representation is heap if the object's name is bound to a stack pointer referencing heap storage. An object's indirect representation is stack if the object's name is bound to the component values directly.\nSOLUTION: The following statements are true.\nI. Indirect representation noticeably increases compilation time.\nWhen the compiler compiles a source module that uses indirect representation, it must consider the locations of the component values. This noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nAccessing a component of a variable using direct representation takes less time than accessing a component of a variable using indirect representation. This is because direct representation uses the stack, which is faster than the heap.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.\nWhen the storage size of a component changes, the compiler must recompile the source modules that contain the definition of the object. Indirect representation ensures that the object's name is bound to a stack pointer referencing the heap storage for the component values. This minimizes the number of recompilations that must be performed."}
{"question": "Which of the following is NOT a property of bitmap graphics?", "choices": [{"label": "A", "text": "Fast hardware exists to move blocks of pixels efficiently."}, {"label": "B", "text": "Realistic lighting and shading can be done."}, {"label": "C", "text": "All line segments can be displayed as straight."}, {"label": "D", "text": "Polygons can be filled with solid colors and textures."}], "answerKey": "C", "model_answer": "LECTURE: Bitmap images are made up of a grid of pixels, or points of color. Each pixel is represented by a set of color values.\nA bitmap image can have the following properties:\nSOLUTION: Fast hardware exists to move blocks of pixels efficiently.\nHardware can be designed to move blocks of pixels quickly. This makes it fast to display an image.\nRealistic lighting and shading can be done.\nA bitmap image is a flat image, so lighting and shading cannot be shown realistically.\nAll line segments can be displayed as straight.\nLine segments are made up of two points. As long as the two points are represented by the same color, the line segment will look straight.\nPolygons can be filled with solid colors and textures.\nA colored polygon is a shape made up of many polygons. Solid colors and textures can be used to fill polygons."}
{"question": "Which of the following is true of interrupts?", "choices": [{"label": "A", "text": "They are generated when memory cycles are \"stolen\"."}, {"label": "B", "text": "They are used in place of data channels."}, {"label": "C", "text": "They can indicate completion of an I/O operation."}, {"label": "D", "text": "They cannot be generated by arithmetic operations."}], "answerKey": "C", "model_answer": ""}
{"question": "In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. Which of the following are true of such a tree?\nI. Worst-case search time is logarithmic in the number of nodes.\nII. Average-case search time is logarithmic in the number of nodes.\nIII. Best-case search time is proportional to the height of the tree.\nIV. The height of the tree is logarithmic in the number of nodes.", "choices": [{"label": "A", "text": "I and III only"}, {"label": "B", "text": "II and III only"}, {"label": "C", "text": "II and IV only"}, {"label": "D", "text": "I, II, and IV"}], "answerKey": "D", "model_answer": ""}
{"question": "Bob writes down a number between 1 and 1,000. Mary must identify that number by asking \"yes/no\" questions of Bob. Mary knows that Bob always tells the truth. If Mary uses an optimal strategy, then she will determine the answer at the end of exactly how many questions in the worst case?", "choices": [{"label": "A", "text": "1,000"}, {"label": "B", "text": "999"}, {"label": "C", "text": "500"}, {"label": "D", "text": "10"}], "answerKey": "D", "model_answer": "LECTURE: A strategy is optimal if it allows Mary to determine the answer in the fewest number of questions.\nSOLUTION: Mary can use logical deduction to determine the answer by asking questions that rule out possible numbers. For example, Mary might ask, \"Is the number between 1 and 1,000?\" This question eliminates all numbers outside of the range between 1 and 1,000.\nAfter asking a few questions, Bob will have narrowed down his number to a range of possible numbers. For example, Bob might now have ruled out all numbers except 1. At this point, Mary can ask, \"Is the number 1?\" This question will allow Mary to determine the answer with certainty."}
{"question": "Which of the following is (are) true about virtual memory systems that use pages?\nI. The virtual address space can be larger than the amount of physical memory.\nII. Programs must be resident in main memory throughout their execution.\nIII. Pages correspond to semantic characteristics of the program.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following is usually NOT represented in a subroutine's activation record frame for a stack-based programming language?", "choices": [{"label": "A", "text": "Values of local variables"}, {"label": "B", "text": "A heap area"}, {"label": "C", "text": "The return address"}, {"label": "D", "text": "Stack pointer for the calling activation record"}], "answerKey": "B", "model_answer": "LECTURE: A subroutine is a block of code that performs a specific task. Subroutines can make your program easier to understand and reuse code.\nA subroutine has its own set of variables, called local variables. When a subroutine is called, a new activation record is created for it. An activation record is like a template that stores information about the state of the subroutine.\nAn activation record has the following components:\nThe stack pointer for the calling activation record tells you where the calling activation record is stored on the stack.\nThe stack pointer for the called activation record tells you where the called activation record is stored on the stack.\nThe return address is the location where the called activation record will return after it completes.\nValues of local variables are the values of the local variables in the called activation record.\nA heap area is a region of memory that is not allocated by the stack. Some programming languages use heaps to store data that is created dynamically. Subroutines do not normally allocate space on the heap.\nSOLUTION: The return address is the location where the called activation record will return after it completes. This location is usually not stored in the activation record.\nValues of local variables are the values of the local variables in the called activation record. This location is usually stored in the activation record.\nA heap area is a region of memory that is not allocated by the stack. Subroutines do not normally allocate space on the heap. This location is usually not stored in the activation record.\nThe stack pointer for the calling activation record tells you where the calling activation record is stored on the stack. This location is usually not stored in the activation record."}
{"question": "Which of the following statements about a remote procedure call is true?", "choices": [{"label": "A", "text": "It is used to call procedures with addresses that are farther than 2^16 bytes away."}, {"label": "B", "text": "It cannot return a value."}, {"label": "C", "text": "It cannot pass parameters by reference."}, {"label": "D", "text": "It cannot call procedures implemented in a different language."}], "answerKey": "C", "model_answer": "LECTURE: Procedures and functions are two ways to organize code that is executed together.\nA procedure is a group of statements that performs a task. Procedures can be called from within other procedures or functions.\nA function is a procedure that returns a value.\nRemote procedure calls are used to call procedures that are located in a different address space.\nAn address space is a region of memory. Every program has its own address space.\nA remote procedure call involves the following steps:\n1. The calling program sends a message to the target program, which is in a different address space.\n2. The target program executes the procedure and returns control to the calling program.\n3. The calling program receives the results of the procedure.\nRemote procedure calls can be implemented using function calls or message passing.\n\nSOLUTION: The following statement is true about a remote procedure call:\nIt is used to call procedures with addresses that are farther than 2^16 bytes away.\nThe statement that is not true is:\nIt cannot return a value.\nA remote procedure can return a value.\nIt cannot pass parameters by reference.\nA remote procedure call can pass parameters by reference.\nIt cannot call procedures implemented in a different language.\nA remote procedure call can call procedures implemented in a different language."}
{"question": "Of the following sorting algorithms, which has a running time that is LEAST dependent on the initial ordering of the input?", "choices": [{"label": "A", "text": "Insertion sort"}, {"label": "B", "text": "Quicksort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Selection sort"}], "answerKey": "C", "model_answer": "LECTURE: All of the comparing algorithms compare two values and determine which is larger. The running time of an algorithm is dependent on the initial ordering of the input. For example, bubble sort has a running time of O(n^2), which means that its running time can increase quickly as the initial sorting of the input changes.\nSelection sort has a running time of O(n^2), which is dependent on the initial ordering of the input. It compares each value in the array with the one that follows it. So, if the first few values in the array are out of order, selection sort will take longer to sort the array.\nInsertion sort has a running time of O(n^2), which is dependent on the initial ordering of the input. It sorts the array by placing the values in order within a subarray of a given size. If the subarray is not already sorted, insertion sort must compare and move each value until the subarray is sorted.\nMerge sort has a running time of O(n log n), which is not dependent on the initial ordering of the input. It sorts the array by dividing it into two subarrays and then merging the subarrays back together. If the initial ordering of the input affects the time it takes to divide the array into subarrays, merge sort's running time will increase.\nQuicksort has a running time of O(n log n), which is not dependent on the initial ordering of the input. It sorts the array by selecting the middle value of the array and putting the other values in order around it. This process is repeated on each subarray. If the initial ordering of the input affects the time it takes to select the middle value, quicksort's running time will increase."}
{"question": "A particular parallel program computation requires 100 seconds when executed on a single processor. If 40 percent of this computation is \"inherently sequential\" (i.e., will not benefit from additional processors), then the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are", "choices": [{"label": "A", "text": "20 and 10 seconds"}, {"label": "B", "text": "30 and 15 seconds"}, {"label": "C", "text": "50 and 25 seconds"}, {"label": "D", "text": "70 and 55 seconds"}], "answerKey": "D", "model_answer": "LECTURE: When considering the effect of adding processors to a parallel program, you need to determine how much of the computation is inherently sequential versus inherently parallel. Inherently sequential parts of a program are not helped by adding more processors. Idle processors are wasted resources.\nThe amount of sequential work in a program depends on the program's data dependencies. Data dependencies describe how the values in the program's data change as the program runs. Some examples of data dependencies include x = x + y, x = x * y, and x.store(y, 16).\nWhen a program has no data dependencies, all of its work is inherently parallel. This means that adding more processors will not reduce the program's elapsed time.\nWhen a program has only one data dependency, all of its work is inherently sequential. This means that adding more processors will not reduce the program's elapsed time.\nIf a program has more than one data dependency, its work is inherently parallel. This means that adding more processors can potentially reduce the program's elapsed time.\nSOLUTION: To determine how much of the computation is inherently sequential, you need to count the number of data dependencies in the program.\nThe given computation has 100 seconds of elapsed time, which is the time it takes to run the program once. This value is used to calculate the theoretically best possible elapsed times for the program with 2 and 4 processors.\nThe calculation assumes that the program can use any number of processors up to 4. For example, the program could have elapsed times of 10 and 5 seconds if it could use 2 processors.\nChoice \"A. \" is incorrect.\nChoice \"B. \" is incorrect.\nChoice \"C. \" is incorrect.\nChoice \"D. \" is incorrect."}
{"question": "Consider the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude. In which representation is there overflow from the addition of the integers 011000 and 011000?", "choices": [{"label": "A", "text": "Two's complement only"}, {"label": "B", "text": "Sign and magnitude and one's complement only"}, {"label": "C", "text": "Two's complement and one's complement only"}, {"label": "D", "text": "All three representations"}], "answerKey": "D", "model_answer": ""}
{"question": "Of the following, which best characterizes computers that use memory-mapped I/O?", "choices": [{"label": "A", "text": "The computer provides special instructions for manipulating I/O ports."}, {"label": "B", "text": "I/O ports are placed at addresses on the bus and are accessed just like other memory locations."}, {"label": "C", "text": "To perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}, {"label": "D", "text": "Ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}], "answerKey": "B", "model_answer": ""}
{"question": "Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that", "choices": [{"label": "A", "text": "integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs"}, {"label": "B", "text": "P = NP"}, {"label": "C", "text": "even if P = NP, integer factorization is still likely not to be polynomial-time computable"}, {"label": "D", "text": "testing primality is computationally intractable"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following sets of bit strings CANNOT be described with a regular expression?", "choices": [{"label": "A", "text": "All bit strings whose number of zeros is a multiple of five"}, {"label": "B", "text": "All bit strings starting with a zero and ending with a one"}, {"label": "C", "text": "All bit strings with an even number of zeros"}, {"label": "D", "text": "All bit strings with more ones than zeros"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following conditions can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac)?\nI. At least three of p_1, p_2, p_3, p_4 are true.\nII. Exactly three of p_1, p_2, p_3, p_4 are true.\nIII. An even number of p_1, p_2, p_3, p_4 are true.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "Boolean variable is a variable that can only take on the values true or false.\nA Boolean formula is a formula that uses only the Boolean variables and the connectives \u2227, \u2228, and the negation of a variable, denoted by \u00ac.\nA Boolean formula in the variables p_1, p_2, p_3, p_4 and the connectives \u2227, \u2228 (without \u00ac) can be used to express the conditions that can be true or false.\nThe connective \u2227 means \"and.\" A formula with only the connective \u2227 will evaluate to true only when all of its subformulas evaluate to true.\nThe connective \u2228 means \"or.\" A formula with only the connective \u00f3r will evaluate to true when any of its subformulas evaluate to true.\nA Boolean formula in the variables p_1, p_2, p_3, p_4 and the connectives \u2227, \u2228 (without \u00ac) can express the following conditions:\nAt most one of p_1, p_2, p_3, p_4 are true.\nExactly one of p_1, p_2, p_3, p_4 are true.\nAn odd number of p_1, p_2, p_3, p_4 are true.\nAt least three of p_1, p_2, p_3, p_4 are true.\nExactly three of p_1, p_2, p_3, p_4 are true.\nAn even number of p_1, p_2, p_3, p_4 are true."}
{"question": "Two alternatives for interconnecting a set of processors with bidirectional links are (1) the fully interconnected network, in which each processor is directly connected to every other processor, and (2) the ring network, in which each processor is connected to two other processors. The worst-case path length for a network is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes. For each type of interconnection of n processors, a figure of merit can be formed as the product of the number of links required for the network times the worst-case path length connecting any two processors. The ratio of this figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is", "choices": [{"label": "A", "text": "1/(n^2)"}, {"label": "B", "text": "1/(n(n-1))"}, {"label": "C", "text": "1/n"}, {"label": "D", "text": "(n-1)/n"}], "answerKey": "D", "model_answer": ""}
{"question": "For a connected, undirected graph G = (V, E), which of the following must be true?\nI. \u03a3_{v\u2208V} degree(v) is even.\nII. |E| \u2265 |V| \u2212 1\nIII. G has at least one vertex with degree 1.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of vertices and edges. Vertices are also called nodes. Edges connect vertices.\nAn undirected graph is a graph where each edge connects two vertices in the same way. For example, two edges connecting the same two vertices are included in an undirected graph.\nA connected graph is a graph where, if there are vertices in the graph, there is a path between every pair of vertices.\nThe degree of a vertex is the number of edges that connect to that vertex.\nSOLUTION: A graph is connected if there is a path between every pair of vertices.\nFor a graph to be connected, at least one vertex must have a degree of 1.\nSo, III. G has at least one vertex with degree 1. is true.\nThe sum of the degrees of all the vertices is the sum of the edges in the graph.\nFor a connected graph, the sum of the degrees of all the vertices is even.\nSo, I. \u03a3_{v\u2208V} degree(v) is even. is true.\nFor a graph to have at least one edge, it must have at least two vertices.\nSo, II. |E| \u2265 |V| \u2212 1 is true."}
{"question": "In multiprogrammed systems it is advantageous if some programs such as editors and compilers can be shared by several users. Which of the following must be true of multiprogrammed systems in order that a single copy of a program can be shared by several users?\nI. The program is a macro.\nII. The program is recursive.\nIII. The program is reentrant.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "C", "model_answer": "LECTURE: A program is a macro if it performs a specific task, such as printing a document or formatting text. A macro can be designed to include specific instructions for different types of tasks.\nA program is recursive if it includes instructions that call themselves. A recursive program can solve problems by breaking them down into smaller, identical problems.\nA program is reentrant if it can be called multiple times from within other parts of the same program. A reentrant program can solve problems that can be broken down into smaller, independent pieces.\nSOLUTION: Regardless of whether a program is macro, recursive, or reentrant, it can be shared by several users in a multiprogrammed system."}
{"question": "Which of the following decimal numbers has an exact representation in binary notation?", "choices": [{"label": "A", "text": "0.1"}, {"label": "B", "text": "0.2"}, {"label": "C", "text": "0.3"}, {"label": "D", "text": "0.5"}], "answerKey": "D", "model_answer": "LECTURE: To specify an interval, the endpoints may be written with both a number and a fraction. The fraction comes after the number. For example, the endpoint 10/2 specifies the interval from 10 to 2. The interval includes 2, but not 10.\nIf the number is increased, the interval expands. For example, if the endpoint is updated to 10/2, the interval expands to include 2.\nIf the number is decreased, the interval contracts. For example, if the endpoint is updated to 2/10, the interval contracts to include only 2.\nSOLUTION: To have an exact representation in binary notation, the decimal number's endpoint must be either 0 or 1.\nThe endpoint of 0.1 is 0.1. This endpoint is not equal to 0 or 1. So, 0.1 does not have an exact representation in binary notation.\nThe endpoint of 0.2 is 0.2. This endpoint is not equal to 0 or 1. So, 0.2 does not have an exact representation in binary notation.\nThe endpoint of 0.3 is 0.3. This endpoint is not equal to 0 or 1. So, 0.3 does not have an exact representation in binary notation.\nThe endpoint of 0.5 is 0.5. This endpoint is equal to 1. So, 0.5 has an exact representation in binary notation."}
{"question": "Function signatures describe the types of the arguments to a function as well as the return value of the function. For instance, the addition function on reals has a signature of\nadd : real x real -> real\nsince it takes two real numbers and returns a real number. But, for a language that allows functions as return values, addition could be considered to have the signature\nadd : real -> (real -> real)\nwhich means that add takes a single real (the first operand) and returns a new function that itself takes a single real (the second operand) and returns a real (the result). This process of reducing a function with multiple arguments to a function with fewer arguments is called currying. Which of the following is correct?", "choices": [{"label": "A", "text": "Currying can be applied to any function to the point where it has exactly one input argument."}, {"label": "B", "text": "Currying cannot be applied to functions of more than two arguments."}, {"label": "C", "text": "Currying cannot be applied to functions that return functions as arguments."}, {"label": "D", "text": "Currying cannot be applied w functions that haw arguments that are functions."}], "answerKey": "A", "model_answer": ""}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-back policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2000"}], "answerKey": "A", "model_answer": ""}
{"question": "In which of the following representations of numbers by 8-bit words is the addition of the integers 109 and -42 within range?\nI. One's complement\nII. Two's complement\nIII. Sign and magnitude", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: In order to perform arithmetic operations on numbers represented by 8-bit words, we need to determine the positions of the numbers on the word.\nAn 8-bit word has 8 bits, or 8 digits. Each digit represents a number between 0 and 255.\nThe number represented by an 8-bit word is composed of two parts: the sign and the magnitude.\nThe sign is the first bit of the 8-bit word. It represents the sign of the number.\nA value of 0 for the sign bit means that the number is positive. A value of 1 for the sign bit means that the number is negative.\nThe magnitude is the other 7 bits of the 8-bit word. They represent the absolute value of the number.\nTo perform an arithmetic operation on a number represented by an 8-bit word, first compare the values of the corresponding bits in the two numbers.\nIf the values are equal, the bits in the resulting 8-bit word will be equal to the bits in one of the original 8-bit words.\nIf the values are not equal, the bits in the resulting 8-bit word will be equal to the values of the original 8-bit words.\nFor example, consider the 8-bit words 10101010 and 01101100.\nThe values of the bits in these words are compared, bit by bit, from the right.\nThe first comparison is between the values of the rightmost bits.\nThese bits are equal, so the bits in the resulting 8-bit word will be equal to the bits in the original 8-bit words.\nThe other comparisons are between values of 1 and 0.\nSince 1 is greater than 0, the bits in the resulting 8-bit word will be equal to the values of the original 8-bit words.\nSo, the addition of the integers 109 and -42 is within range when represented by the 8-bit words 10101010 and 01101100."}
{"question": "If a malicious process is granted temporary administrator-level access to a system", "choices": [{"label": "A", "text": "the threat is over as soon as the process is killed"}, {"label": "B", "text": "the threat is over after the operating system is rebooted"}, {"label": "C", "text": "the thread is over after rebooting the machine and replacing files that show a virus infection"}, {"label": "D", "text": "the threat is often permanent until the entire disk is wiped clean"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following statements about horizontal versus vertical microarchitecture is (are) true?\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nII. Horizontal microinstructions are unencoded.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: Microarchitecture is the architecture of a computer's hardware, including its complex data paths, control units, and caching.\nMicroarchitecture is not to be confused with the overall architecture of a computer system. Computer architecture is concerned with the overall design of the system, including the hardware and software.\nVertical microarchitecture is simpler and has fewer functional units. It is composed of simple, fundamental units, such as registers and ALUs (arithmetic logic units).\nA simple way to classify microarchitecture is by the number of functional units. Vertical microarchitecture has just a few functional units, if any. Horizontal microarchitecture has many functional units."}
{"question": "A \"strictly binary tree\" is a binary tree in which every node that is not a leaf has two children. Suppose that for a class of strictly binary trees there exists c > 0 such that, for any tree in the class, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. Which of the following best characterizes the height h of any tree in this class, where N is the number of nodes in the tree and N > 1 ?", "choices": [{"label": "A", "text": "h <= log2(N)"}, {"label": "B", "text": "h = 1/c * log2(N)"}, {"label": "C", "text": "h < c log2(N)"}, {"label": "D", "text": "h > c log2(N)"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following sorting algorithms has average-case and worst-case running times of O(n log n)?", "choices": [{"label": "A", "text": "Bubble sort"}, {"label": "B", "text": "Insertion sort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "C", "model_answer": "LECTURE: Algorithms have analysis, which is a formal way of breaking down an algorithm and estimating how it performs. Analysis can help you predict how long an algorithm will take to run, how much memory it will use, or what its space complexity is.\nSorting algorithms are an important example of algorithms with simple analysis. We can analyze a sorting algorithm by examining how it organizes its input into a sorted order.\nFor example, consider the bubble sort algorithm:\nBubble sort has a simple analysis. When it is written out explicitly, it is easy to see that the algorithm makes several comparisons and swaps each time it is run. By making and swapping, the algorithm sorts the input.\nThe number of comparisons and swaps the algorithm makes depends on the size of the input. For small inputs, the algorithm makes very few comparisons and swaps. But as the size of the input grows, the number of comparisons and swaps grows much faster.\nSo, the bubble sort algorithm has average-case performance of O(n^2). The average-case is the case where one-half of the inputs are less than the other one-half. This is a common situation, and the bubble sort algorithm takes about n^2 comparisons to sort n inputs in the average case.\nThe worst-case performance of bubble sort is also O(n^2). The worst-case is the case where the input is in the opposite order of the correct order. This is a rare situation, and the bubble sort algorithm takes about n^2 comparisons to sort n inputs in the worst case.\nInsertion sort also has a simple analysis. It makes a number of insertions, which are quick to make. So, insertion sort has average-case and worst-case performance of O(n).\nMerge sort and quicksort also have analysis. The analysis for these algorithms is too complex to write out explicitly, but it can be shown that they have performance of O(n log n).\nThese algorithms have the same performance in the average case and the worst case. O(n log n) is a much better performance than O(n^2). So, merge sort and quicksort are much faster than bubble sort and insertion sort.\nSOLUTION: To do this problem, you need to determine which sorting algorithm has performance of O(n log n). You know that all four algorithms have performance of O(n log n). So, any of the algorithms could be the correct answer."}
{"question": "Consider the following equations concerning a stack module that has the operations Push, Pop, Top, and IsEmpty. Which of the equations does NOT represent the conventional semantics of a stack?", "choices": [{"label": "A", "text": "IsEmpty(Push(Stack,Elem)) = true"}, {"label": "B", "text": "Pop(Push(Stack,Elem)) = Stack"}, {"label": "C", "text": "Top(Push(Stack,Elem)) = Elem"}, {"label": "D", "text": "IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false"}], "answerKey": "A", "model_answer": ""}
{"question": "Assume that any assignment statement can be executed in unit time. If as many identical processors as needed are used, what is the minimum number of time units needed to execute the assignments\nA := B + C\nB := A - B\nC := A * E\nD := A/F\nE := B - C\nF := A + B\nwith the same result as if the assignments were executed in the order shown?", "choices": [{"label": "A", "text": "1"}, {"label": "B", "text": "2"}, {"label": "C", "text": "3"}, {"label": "D", "text": "4"}], "answerKey": "C", "model_answer": "LECTURE: In an assignment statement, the value of one variable is assigned to another variable. For example, A = B + C.\nAfter the assignment statement A = B + C is executed, the value of A is greater than its original value. The value of B is unchanged. The value of C is unchanged.\nSOLUTION: The assignments must be executed in the correct order. If the assignments are executed in the order shown, the value of A is changed to its original value before the other variables are assigned their final values.\nThe correct order is D, E, F, B, A.\nIn this order, the assignments are executed in under 2 time units."}
{"question": "Two expressions E and F are said to be unifiable if there are substitutions for the variables of E and F that make the expressions lexically identical. In the following three expressions, only w, x, y, and z are variables.\nI. f(w,w)\nII. f(x,1)\nIII. f(y,g(z))\nWhich pairs of these expressions is (are) pairs of unifiable expressions?", "choices": [{"label": "A", "text": "(I, II) only"}, {"label": "B", "text": "(I, III) only"}, {"label": "C", "text": "(II, III) only"}, {"label": "D", "text": "(I, II) and (I, III) only"}], "answerKey": "D", "model_answer": "LECTURE: An expression is a well-formed expression that may or may not be a statement.\nAn expression can be a variable or a combination of a variable and an operator.\nAn operator is a symbol that performs a specific operation.\nThe variables in an expression are the values that the expression evaluates to.\nAn expression is unifiable if there are substitutions for the variables in the expression that make the expression evaluate to a value.\nFor example, the expressions f(z, g(z)) and f(x, y) are unifiable."}
{"question": "Which of the following instruction-set features is NOT generally considered an obstacle to aggressive pipelining of an integer unit?", "choices": [{"label": "A", "text": "Condition codes set by every instruction"}, {"label": "B", "text": "Variable-length encoding of instructions"}, {"label": "C", "text": "Instructions requiring widely varying numbers of cycles to execute"}, {"label": "D", "text": "Several different classes (sets) of registers"}], "answerKey": "D", "model_answer": ""}
{"question": "Let k >= 2. Let L be the set of strings in {0, 1}^* such that x \\in L if and only if the number of 0's in x is divisible by k and the number of 1's in x is odd. The minimum number of states in a deterministic finite automaton (DFA) that recognizes L is", "choices": [{"label": "A", "text": "k + 2"}, {"label": "B", "text": "2k"}, {"label": "C", "text": "k log k"}, {"label": "D", "text": "k^2"}], "answerKey": "B", "model_answer": "LECTURE: A deterministic finite automaton (DFA) is a machine that can be in one of a finite number of states and transition to another state when a input symbol is received. The possible states are called the DFA's state space.\nThe machine can be in one of two states, called the start and accept states. When the machine is in the start state, it is waiting for input. The accept state is reserved for a special state that the machine enters when it has processed the input correctly.\nA DFA's transition table shows the machine's state space and the next state for each possible state and input symbol. A DFA's state space can be sorted in different ways. One common way is to sort it by the DFA's input symbol.\nFor example, if the DFA is in state 3 and the input symbol is 1, the DFA will transition to state 2. These transitions are represented in the DFA's transition table:\n | 3 | 2 |\n1 | 2 | 3 |\nThe DFA's state space is [2, 3].\nAnother common way to sort the state space is to sort it by the input symbol's position. The input symbol 1 is in position 1, and the input symbol 0 is in position 2. These positions are represented in the DFA's transition table:\n | 3 | 2 |\n1 | 2 | 3 |\nThe DFA's state space is [2, 3].\nThe DFA's state space is shown below in both ways:\n | 3 | 2 |\n1 | 2 | 3 |"}
{"question": "Let G = (V, E) be a finite directed acyclic graph with |E| > 0. Which of the following must be true?\nI. G has a vertex with no incoming edge.\nII. G has a vertex with no outgoing edge.\nIII. G has an isolated vertex, that is, one with neither an incoming edge nor an outgoing edge.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of vertices and edges. A vertex is a point, and an edge is a line segment that connects two points.\nA graph is directed if each of its edges has a direction. A graph is acyclic if it has no directed cycles.\nA directed acyclic graph (DAG) is a directed graph that is acyclic.\nA DAG is finite if it has a finite number of vertices.\nSOLUTION: A DAG is acyclic if and only if it has no directed cycles.\nSo, G has a vertex with no incoming edge or G has a vertex with no outgoing edge. But G cannot have both.\nSo, G has an isolated vertex."}
{"question": "Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v. Let (u, v) be an edge in G that is not in T, such that pre(u) < pre(v). Which of the following statements about u and v must be true?\nI. post(u) < post(v)\nII. u is an ancestor of v in T.\nIII. If w is the lowest common ancestor of u and v in T, then w = u.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "LECTURE: Depth-first search is a algorithm that explores a graph or a tree by visiting its nodes in a depth-first order. It does this by visiting the children of a node before visiting the node itself.\nA depth-first search tree is a tree that is constructed by performing a depth-first search. The nodes in the tree are the ones that are visited during the search.\nA connected graph is a graph that remains connected when any number of its edges are removed.\nAn undirected graph is a graph that does not have any directed edges.\nA lowest common ancestor of two vertices in a tree is a vertex that is a common ancestor of them. The lowest common ancestor of two vertices in a tree is the vertex that is furthest from the root.\nA preorder traversal of a tree is a traversal in which each node is visited immediately after all of its children have been visited.\nA postorder traversal of a tree is a traversal in which each node is visited immediately before all of its children have been visited.\nSOLUTION: Let w be the lowest common ancestor of u and v in T. There are two cases, depending on whether w is u or not.\nCase 1: w = u. In this case, pre(u) = pre(w) and post(u) = post(w). So, post(u) < post(v) and u is an ancestor of v in T.\nCase 2: w is not equal to u. In this case, pre(u) < pre(w) and post(u) > post(w). So, post(u) < post(v) and u is an ancestor of v in T."}
{"question": "In systems with support for automatic memory management, a garbage collector typically has the responsibility for reclaiming allocated memory objects whose contents cannot affect any future legal computation. Such objects are identified by determining that they cannot be reached from a root set. Which of the following is NOT part of the root set in a typical garbage collector?", "choices": [{"label": "A", "text": "Actual parameters of the active procedures"}, {"label": "B", "text": "Dynamically allocated objects on the heap"}, {"label": "C", "text": "Global variables of the program"}, {"label": "D", "text": "Local variables on the call stack"}], "answerKey": "B", "model_answer": ""}
{"question": "In the Internet Protocol (IP) suite of protocols, which of the following best describes the purpose of the Address Resolution Protocol?", "choices": [{"label": "A", "text": "To translate Web addresses to host names"}, {"label": "B", "text": "To determine the IP address of a given host name"}, {"label": "C", "text": "To determine the hardware address of a given host name"}, {"label": "D", "text": "To determine the hardware address of a given IP address"}], "answerKey": "D", "model_answer": "LECTURE: The Internet Protocol (IP) suite of protocols is a set of rules that govern the communication of data across network interfaces. The protocols in the suite work together to move data.\nEach protocol in the Internet Protocol (IP) suite serves a specific purpose. Here's what each protocol does:\nInternet Protocol (IP):\nIP is responsible for addressing. IP addresses are numerical labels assigned to devices on a network.\nInternet Assistant Protocol (IAP):\nIAP is responsible for translating addresses. It maps a private network's addresses to a public network's addresses.\nMedia Access Control (MAC) Protocol:\nMAC is responsible for controlling access to a network. It uses a fixed-length header on each network packet.\nHardware Address:\nA hardware address is a unique number that identifies a network device. It is also known as a MAC address.\nWeb Address:\nA Web address is a reference to a resource on the World Wide Web. It specifies the website, domain, and path to a resource.\nWhen you type a Web address into a web browser, the web browser uses the Internet Protocol (IP) to determine the hardware address of the device that can provide the resource. Then, the web browser uses the Media Access Control (MAC) Protocol to send the packet to the correct device."}
{"question": "Which of the following language features requires that stack-based storage allocation be used rather than static allocation?", "choices": [{"label": "A", "text": "Recursive procedures"}, {"label": "B", "text": "Arbitrary goto's"}, {"label": "C", "text": "Two-dimensional arrays"}, {"label": "D", "text": "Integer-valued functions"}], "answerKey": "A", "model_answer": "LECTURE: All programming languages have a set of rules that describe how the code may be written. These rules define the language's grammar.\nA language feature is a part of the language that is defined by the language's grammar. Some language features may require certain storage allocations.\nStatic allocation and stack-based allocation are two possible ways that storage can be allocated.\nStatic allocation is the process of allocating storage at the beginning of your program. Static allocation can be used for procedures and objects that do not change their length or size.\nStack-based allocation is the process of allocating storage for a procedure or object on the stack. The stack is a region of memory that is used to store temporary data.\nSome language features may require stack-based allocation. These features cannot be implemented using static allocation.\nOther language features may require static allocation. These features can be implemented using stack-based allocation, but they may not work correctly.\nSOLUTION: Recursive procedures require stack-based allocation. Each call to a recursive procedure is stored on the stack.\nTwo-dimensional arrays require stack-based allocation. Each two-dimensional array is stored on the stack.\nInteger-valued functions require static allocation. The functions' values can be stored in static memory.\nArbitrary goto's can be implemented using either stack-based allocation or static allocation."}
{"question": "Which of the following is not a sentence that is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z?", "choices": [{"label": "A", "text": "xyz"}, {"label": "B", "text": "xy"}, {"label": "C", "text": "xxzy"}, {"label": "D", "text": "xxxxy"}], "answerKey": "A", "model_answer": ""}
{"question": "Let T (n) be defined by T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1. Which of the following represents the order of growth of T(n) as a function of n?", "choices": [{"label": "A", "text": "\u0398(n)"}, {"label": "B", "text": "\u0398(n log n)"}, {"label": "C", "text": "\u0398(n^2)"}, {"label": "D", "text": "\u0398(n^2 log n)"}], "answerKey": "C", "model_answer": "LECTURE: The notation \u0398(f(n)) represents the set of all functions g(n) for which there exist positive constants c and n0 such that |g(n)| \u2264 c |f(n)| for all n \u2265 n0.\nIn other words, g(n) is in \u0398(f(n)) if the growth of g(n) is similar to the growth of f(n).\nMore formally, let f(n) = Thennf is in \u0398(f(n)).\nThe notation \u03a9(f(n)) is defined in a similar way."}
{"question": "Which of the following problems is (are) decidable?\nI. Given a (finite) string w, is w a prefix of the decimal expansion of \u03c0?\nII. Given a program and an input, is the program\u2019s output the decimal expansion of \u03c0?\nIII. Given a program that takes as input a prefix of the decimal expansion of \u03c0, is the program\u2019s output always the same for every prefix?", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A problem is decidable if there is a procedure that, given a string, a program, and an input, will determine whether the string is a prefix of the output of the program on the input.\nThe problem of whether a string is a prefix of the decimal expansion of \u03c0 is decidable. It can be done by computer.\nThe problem of whether a program takes as input a prefix of the decimal expansion of \u03c0 is also decidable. It can be done by computer.\nThe problem of whether the program\u2019s output is the decimal expansion of \u03c0 is not decidable. There is no procedure that can determine whether a program with input x will output \u03c0 for all possible inputs x.\nThe problem of whether a program\u2019s output is always the same for every prefix is not decidable. There is no procedure that can determine whether two prefixes of \u03c0 are the same."}
{"question": "Which of the following statements about circuits is (are) true?\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nIII. Both sequential and combinational circuits must be controlled by an external clock.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: A circuit is a path through which electricity flows. A simple circuit has two parts: a set of components and a path for the electric current to flow.\nThere are two main types of circuits: combinational and sequential.\nCombinational circuits are made up of components such as gates and light-emitting diodes. They do not have a memory of their own. They respond to the present value of the input.\nSequential circuits are made up of components such as flip-flops. They have a memory of their own. They can use their memory to regulate their output.\nSOLUTION: A circuit is considered memoryless when it does not use its memory in response to the present value of the input. A combinational circuit is a memoryless circuit.\nA sequential circuit has a memory of its own. It can use its memory to regulate its output.\nBoth sequential and combinational circuits must be controlled by an external clock. The clock tells the components when to start and stop their processing."}
{"question": "Two single-user workstations are attached to the same local area network. On one of these workstations, file pages are accessed over the network from a file server; the average access time per page is 0.1 second. On the other of these workstations, file pages are accessed from a local disk; the average access time per page is 0.05 second. A particular compilation requires 30 seconds of computation and 200 file page accesses. What is the ratio of the total time required by this compilation if run on the diskless (file server) workstation to the total time required if run on the workstation with the local disk, if it is assumed that computation is not overlapped with file access?", "choices": [{"label": "A", "text": "1/1"}, {"label": "B", "text": "5/4"}, {"label": "C", "text": "5/3"}, {"label": "D", "text": "10/5"}], "answerKey": "B", "model_answer": ""}
{"question": "Assume that a debugger places a breakpoint at a load instruction at virtual address 0x77E81234 (hexadecimal notation) in a debugged process P. If the text segment of P begins at 0x77E80000 in P\u2019s virtual address space and if the debugger has mapped this same text segment at 0x01000000 in its virtual address space, which of the following is the virtual address used by the debugger in its WRITE operation, along with a description of how the debugger has mapped the virtual memory page containing this address?", "choices": [{"label": "A", "text": "0x01001234; page mapped with READ/WRITE access"}, {"label": "B", "text": "0x01001234; page mapped with COPY-ON-WRITE access"}, {"label": "C", "text": "0x76E81234; page mapped with READ/WRITE access"}, {"label": "D", "text": "0x76E81234; page mapped with COPY-ON-WRITE access"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following considerations applies (apply) to choosing the page size in a paging system?\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": ""}
{"question": "Two processors, M-5 and M-7, implement the same instruction set. Processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. Processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds. Which of the following is (are) true?\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline.\nII. The latency of a single instruction is shorter on M-7\u2019s pipeline than on M-5\u2019s pipeline.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III"}, {"label": "D", "text": "II and III"}], "answerKey": "A", "model_answer": "LECTURE: Pipelining is a technique that allows multiple instructions to be processed simultaneously. Pipelining is implemented in the form of a pipeline. A pipeline has a set of stages, and each instruction passes through the pipeline by spending some time in each stage.\nThe number of stages in a pipeline affects its speed and its latency. More stages allow for more instructions to be processed simultaneously, which increases the pipeline's speed. However, adding stages also increases the time it takes for an instruction to make its way through the pipeline, which increases the pipeline's latency.\nA processor's clock cycle is the time it takes for the processor to process one clock pulse. Clock cycles and pipeline stages are related because each stage of a pipeline takes one clock cycle to complete. So, a processor with a higher clock cycle will have a slower pipeline.\nThe maximum throughput of a pipeline is a function of the number of stages in the pipeline. Maximum throughput is the number of instructions per clock cycle that the pipeline can process.\nThe latency of a single instruction is the time it takes for that instruction to pass through the pipeline. Latency is the sum of the times it takes for the instruction to pass through each stage of the pipeline.\nSOLUTION: M-7's pipeline has more stages than M-5's pipeline. So, M-7's pipeline has better maximum throughput than M-5's pipeline.\nThe latency of a single instruction is shorter on M-7's pipeline than on M-5's pipeline. This is because M-7's pipeline has more stages.\nPrograms executing on M-7 will always run faster than programs executing on M-5. This is because M-7's pipeline has better maximum throughput and shorter latency."}
{"question": "Which of the following pairs of 8-bit, two's-complement numbers will result in overflow when the members of the pairs are added?", "choices": [{"label": "A", "text": "11111111, 00000001"}, {"label": "B", "text": "00000001, 10000000"}, {"label": "C", "text": "11111111, 10000001"}, {"label": "D", "text": "10000001, 10101010"}], "answerKey": "D", "model_answer": ""}
{"question": "Two computers communicate with each other by sending data packets across a local area network. The size of these packets is 1,000 bytes. The network has the capacity to carry 1,000 packets per second. The CPU time required to execute the network protocol to send one packet is 10 milliseconds. The maximum rate at which one computer can send data to another is approximately", "choices": [{"label": "A", "text": "10,000 bytes/second"}, {"label": "B", "text": "25,000 bytes/ second"}, {"label": "C", "text": "100,000 bytes/ second"}, {"label": "D", "text": "500,000 bytes/ second"}], "answerKey": "C", "model_answer": "The maximum rate at which one computer can send data to another is approximately 1,000 packets per second. Each packet is 1,000 bytes. So, the maximum rate at which one computer can send data to another is 1,000,000 bytes/second."}
{"question": "Consider the following grammar.\nS \u2192 ( S )\nS \u2192 x\nWhich of the following statements is (are) true?\nI. The grammar is ambiguous.\nII. The grammar is suitable for top-down parsing.\nIII. The grammar is suitable for bottom-up parsing.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: A context-free grammar is a set of rules of the form:\nA \u2192 \u03b2\nA \u2192 \u03b3\nA \u2192 \u03b1\nA \u2192 \u03b5\nwhere A is a nonterminal symbol, and \u03b2, \u03b3, \u03b1, and \u03b5 are strings of terminal and nonterminal symbols.\nThe grammar is said to be admissible if no rule contains a string of terminal symbols as its right-hand side.\nA grammar is context-free if and only if it is admissible and contains epsilon productions.\nA grammar is top-down if it is admissible and contains no epsilon productions.\nA grammar is bottom-up if it is admissible and contains only epsilon productions.\nSOLUTION: The grammar is suitable for bottom-up parsing. But it is not suitable for top-down parsing.\nA grammar is top-down if it is admissible and contains no epsilon productions. This grammar has epsilon productions, so it is not top-down.\nA grammar is bottom-up if it is admissible and contains only epsilon productions. This grammar contains no epsilon productions, so it is not bottom-up.\nThis grammar is ambiguous. You can use the first production to generate S \u2192 S. But you can also use the second production to generate S \u2192 x."}
{"question": "Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT:", "choices": [{"label": "A", "text": "Counting distinct values: Given a set of n keys, determine the number of distinct key values."}, {"label": "B", "text": "Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary."}, {"label": "C", "text": "Range search: Given values a and b, find all the records whose key value is in the range a, b."}, {"label": "D", "text": "Symbol table lookup: Given a program identifier, find its type and address."}], "answerKey": "C", "model_answer": "LECTURE: Hash tables allow for efficient storage and retrieval of data. They are based on a hash function, which maps data values to indices.\nWhen data is inserted into a hash table, it is hashed, or mapped, to an index. The hash function is designed to assign indexes such that they are evenly distributed. This makes it unlikely that two values will be stored at the same index.\nWhen data is retrieved from a hash table, the hash function is used again to find the index where the data is stored.\nIf the data was stored at that index, it is retrieved. Otherwise, that index may contain other data.\nSOLUTION: Counting distinct values: Given a set of n keys, determine the number of distinct key values.\nThis problem involves counting the number of distinct values that are stored in a hash table.\nDynamic dictionary: Support the operations of insert, delete, and search in a dictionary.\nA dynamic dictionary supports insert, delete, and search operations.\nRange search: Given values a and b, find all the records whose key value is in the range a, b.\nRange search is a variation of the search operation. It involves searching for values whose key is in a range.\nSymbol table lookup: Given a program identifier, find its type and address.\nA symbol table is a data structure that stores information about identifiers used in a program. It supports lookups of identifiers by type and address."}
{"question": "Let A be a finite set with m elements, and let B be a finite set with n elements. The number of distinct functions mapping A into B is", "choices": [{"label": "A", "text": "n^m"}, {"label": "B", "text": "n!/(n - m)!"}, {"label": "C", "text": "n!"}, {"label": "D", "text": "n!/(m!(n - m)!)"}], "answerKey": "A", "model_answer": "LECTURE: Finite sets are sets with a fixed number of elements. The number of elements in a finite set is called its length.\nLet A be a finite set with length m.\nLet B be a finite set with length n.\nThe number of functions from A to B is written as f(A,B).\nThe number of functions from A to B is equal to the number of functions from B to A. So, f(A,B) = f(B,A).\nFor example, if A = {a, b, c} and B = {x, y}, then there are 2 functions from A to B:\nf(A,B) = {{a, x}, {b, y}}.\nThere are 2 ways to make this statement:\nThe number of functions from a finite set A to a finite set B is m times n.\nThis says that the number of functions from A to B is determined by the lengths of A and B.\nThe number of functions from A to B is m! times n!.\nThis says that the number of functions from A to B is determined by the number of elements in A and the number of elements in B."}
{"question": "To compute the matrix product M_1M_2, where M_1 has p rows and q columns and where M_2 has q rows and r columns, takes time proportional to pqr, and the result is a matrix of p rows and r columns. Consider the product of three matrices N_1N_2N_3 that have, respectively, w rows and x columns, x rows and y columns, and y rows and z columns. Under what condition will it take less time to compute the product as (N_1N_2)N_3 (i.e., multiply the first two matrices first) than to compute it as N_1(N_2 N_3)?", "choices": [{"label": "A", "text": "There is no such condition; i.e., they will always take the same time."}, {"label": "B", "text": "1/x + 1/z < 1/w + 1/y"}, {"label": "C", "text": "x > y"}, {"label": "D", "text": "1/w + 1/x < 1/y + 1/z"}], "answerKey": "B", "model_answer": ""}
{"question": "The hit ratio of a cache memory is the percentage of accesses (reads and writes) for which data are found in the cache. Write-through is a policy whereby every write operation updates main memory. Write-back is a policy whereby a write operation to a line found in the cache does not affect main memory until the line is evicted from the cache. Write-allocation is a policy whereby a cache line is allocated and loaded on a write-miss. If it is assumed that write-allocation is always used, which of the following is true?", "choices": [{"label": "A", "text": "Write-back usually results in a better hit ratio than write-through."}, {"label": "B", "text": "Write-through usually results in a better hit ratio than write-back."}, {"label": "C", "text": "The percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through."}, {"label": "D", "text": "The percentage of write operations resulting in a main memory operation will never be larger for writethrough than for write-back."}], "answerKey": "C", "model_answer": ""}
{"question": "A particular disk unit uses a bit string to record the occupancy or vacancy of its tracks, with O denoting vacant and 1 denoting occupied. A 32-bit segment of this string has the hexadecimal value D4FE2003. The percentage of occupied tracks for the corresponding part of the disk, to the nearest percent, is", "choices": [{"label": "A", "text": "12%"}, {"label": "B", "text": "25%"}, {"label": "C", "text": "38%"}, {"label": "D", "text": "44%"}], "answerKey": "D", "model_answer": ""}
{"question": "An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. Which of the following undirected graphs must have an Euler circuit?\nI. A complete graph with 12 vertices\nII. A complete graph with 13 vertices\nIII. A tree with 13 vertices", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "B", "model_answer": ""}
{"question": "Which of the following characteristics of a programming language is best specified using a context-free grammar?", "choices": [{"label": "A", "text": "Identifier length"}, {"label": "B", "text": "Maximum level of nesting"}, {"label": "C", "text": "Operator precedence"}, {"label": "D", "text": "Type compatibility"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following statements about datagrams sent by a node in a network using IPv4 protocol is (are) true?\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nIII. Datagrams are reassembled only at the destination.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "LECTURE: In a network, data is sent in small pieces called datagrams. The datagrams are sent by one node and received by another.\nWhen a node in a network sends a datagram to a destination node, the datagram is sent over one or more links. A link is a path between two nodes.\nIn the Internet, the datagram is sent using the Internet Protocol (IP). IP breaks up a message into one or more datagrams.\nWhen a datagram is sent over a link, the datagram must be the size of the smallest maximum transmission unit (MTU) of that link. The MTU is the largest possible size for a datagram on a link.\nIf a datagram is larger than the link's MTU, the datagram must be broken into fragments. Each fragment must be smaller than the link's MTU.\nThe fragments are sent over the link individually.\nAt the destination, the fragments are reassembled into a complete datagram."}
{"question": "A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. Which of the following job-scheduling policies is starvation-free?", "choices": [{"label": "A", "text": "Round-robin"}, {"label": "B", "text": "Priority queuing"}, {"label": "C", "text": "Shortest job first"}, {"label": "D", "text": "Youngest job first"}], "answerKey": "A", "model_answer": "LECTURE: A computer's memory is divided into segments, each of which has a starting address and a size. When a program is loaded into memory, its segments are stored in the memory from the starting address to the starting address plus the size.\nThe segment that contains the program's instructions is called the program segment. The segment that contains the program's data is called the data segment.\nTogether, the program segment and the data segment are called the program.\nA process is in the memory if it is either the program or the data of a running program.\nThe memory that is not used by the process is called free memory.\nThe memory that is used by the process is called used memory.\nSOLUTION: Round-robin is the only job-scheduling policy that is starvation-free.\nRound-robin rotates among the jobs in a first-come, first-served manner. When a job is added to a queue that is using round-robin, it becomes the new head of the queue.\nIf no jobs are added to a queue that is using round-robin, the head of the queue will not starve for indefinite.\nPriority queuing is not starvation-free. A job with a low priority can starve for an indefinite period.\nShortest job first is not starvation-free. The shortest job in a queue can starve for an indefinite period.\nYoungest job first is not starvation-free. The youngest job in a queue can starve for an indefinite period."}
{"question": "Of the following, which gives the best upper bound for the value of f(N) where f is a solution to the recurrence f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0?", "choices": [{"label": "A", "text": "O(log N)"}, {"label": "B", "text": "O(N log N)"}, {"label": "C", "text": "O(log N) + 0(1)"}, {"label": "D", "text": "O((log N)^2)"}], "answerKey": "D", "model_answer": ""}
{"question": "Company X shipped 5 computer chips, 1 of which was defective, and Company Y shipped 4 computer chips, 2 of which were defective. One computer chip is to be chosen uniformly at random from the 9 chips shipped by the companies. If the chosen chip is found to be defective, what is the probability that the chip came from Company Y?", "choices": [{"label": "A", "text": "2 / 9"}, {"label": "B", "text": "4 / 9"}, {"label": "C", "text": "1 / 2"}, {"label": "D", "text": "2 / 3"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following problems can be solved by a standard greedy algorithm?\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights\nII. Finding a maximum clique in an undirected graph\nIII. Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A graph is a collection of nodes (or vertices) and edges. The nodes can be any objects, such as people, buildings, or pieces of data. The edges connect the nodes and represent relationships between them.\nFor example, the graph below has 3 nodes (A, B, and C) and 2 edges (A\u2013B and A\u2013C).\nAn undirected graph is a graph without directed edges. An edge in an undirected graph only connects two nodes.\nA directed graph is a graph with directed edges. An edge in a directed graph starts from one node and ends at another node.\nA flow in a directed graph is a way of assigning a number to every edge in the graph. The number represents the amount of flow through the edge. The flow must satisfy two conditions:\nThe flow on any edge cannot be negative.\nThe flow into a node must be equal to the flow out of the node.\nA maximum flow in a directed graph is a flow with the highest possible total flow out of all the edges in the graph.\nA maximum clique in a graph is a clique with the highest possible number of nodes.\nA minimum spanning tree in an undirected graph is a tree that spans the entire graph and has the lowest possible total edge weight.\nA standard greedy algorithm is a simple algorithm that follows the rules below:\nStep 1: Start with an empty set.\nStep 2: For each element that meets the condition, add it to the set.\nStep 3: Return the set.\nThe following problems can be solved by a standard greedy algorithm:\nFinding the maximum sum of elements in a set.\nFinding the maximum size of a subset that meets a condition.\nFinding a minimum spanning tree in an undirected graph with positive-integer edge weights.\nThe following problem cannot be solved by a standard greedy algorithm:\nFinding a minimum clique in an undirected graph.\nTo find a minimum clique, you need to use a different algorithm, such as Gale's algorithm."}
{"question": "A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined. Which of the following is (are) correct?\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: A hash table is a data structure that uses a hash function to map data to a hash value. The hash value is used to determine the location in the hash table where the data should be stored.\nTo determine the correct location, the hash function is applied to the data. The hash function maps the data to an integer. This integer can be used to determine the location in the hash table.\nMost of the data in the hash table is stored at the locations determined by the hash values. These locations are called buckets.\nTo look up a value in the hash table, the hash function is applied to the value. This produces a hash value. The hash value determines the location of the value in the hash table.\nIf the value is found in the hash table, the function returns the value. If the value is not found, the function returns a default value.\nSOLUTION: A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined.\nTrue means the word was in the dictionary. When the hash function is applied to a word, and the appropriate entry in the hash table is found to be true, then the word was in the dictionary.\nFalse means the word was not in the dictionary. When the hash function is applied to a word, and the appropriate entry in the hash table is found to be false, then the word was not in the dictionary.\nHash table size should increase with document size. If the hash table is too small, the hash table will not be able to store all of the words in the document. When this happens, the program will not be able to check the spelling of some of the words in the document."}
{"question": "One approach to handling fuzzy logic data might be to design a computer using ternary (base-3) logic so that data could be stored as \u201ctrue,\u201d \u201cfalse,\u201d and \u201cunknown.\u201d If each ternary logic element is called a flit, how many flits are required to represent at least 256 different values?", "choices": [{"label": "A", "text": "4"}, {"label": "B", "text": "5"}, {"label": "C", "text": "6"}, {"label": "D", "text": "7"}], "answerKey": "C", "model_answer": ""}
{"question": "Local caching of files is common in distributed file systems, but it has the disadvantage that", "choices": [{"label": "A", "text": "Temporary inconsistencies among views of a file by different machines can result"}, {"label": "B", "text": "The file system is likely to be corrupted when a computer crashes"}, {"label": "C", "text": "A much higher amount of network traffic results"}, {"label": "D", "text": "Caching makes file migration impossible"}], "answerKey": "A", "model_answer": ""}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-through policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2048"}], "answerKey": "C", "model_answer": ""}
{"question": "At time 0, five jobs are available for execution on a single processor, with service times of 25, 15, 5, 3, and 2 time units. Which of the following is the minimum value of the average completion time of these jobs?", "choices": [{"label": "A", "text": "50"}, {"label": "B", "text": "208/5"}, {"label": "C", "text": "92/5"}, {"label": "D", "text": "10"}], "answerKey": "C", "model_answer": "LECTURE: The average completion time of a set of jobs is the time it takes to complete all of the jobs. The average completion time of these five jobs is the sum of the service times of all five jobs, which is 25 + 15 + 5 + 3 + 2 = 50 time units.\nThe average completion time of a set of jobs is the time it takes to complete all of the jobs. The average completion time of these five jobs is the sum of the service times of all five jobs, which is 25 + 15 + 5 + 3 + 2 = 50 time units. The minimum value of the average completion time of these jobs is 50 time units."}
{"question": "Let G = (V, E) be a connected, undirected graph, and let a and b be two distinct vertices in V. Let P_1 be the problem of finding a shortest simple path between a and b, and let P_2 be the problem of finding a longest simple path between a and b. Which of the following statements about P_1 and P_2 is true?", "choices": [{"label": "A", "text": "Both P_1 and P_2 can be solved in polynomial time."}, {"label": "B", "text": "P_1 can be solved in polynomial time but P_2 is not known to be solvable in polynomial time."}, {"label": "C", "text": "P_1 is not known to be solvable in polynomial time but P_2 can be solved in polynomial time."}, {"label": "D", "text": "It is not known whether either P_1 or P_2 can be solved in polynomial time."}], "answerKey": "B", "model_answer": ""}
{"question": "A major advantage of direct mapping of a cache is its simplicity. The main disadvantage of this organization is that", "choices": [{"label": "A", "text": "it does not allow simultaneous access to the intended data and its tag"}, {"label": "B", "text": "it is more expensive than other types of cache organizations"}, {"label": "C", "text": "the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache"}, {"label": "D", "text": "its access time is greater than that of other cache organizations"}], "answerKey": "C", "model_answer": ""}
{"question": "Let M be a single-tape, deterministic Turing machine with tape alphabet {blank,0,1}, and let C denote the (possibly infinite) computation of M starting with a blank tape. The input to each problem below is M, together with a positive integer n. Which of the following problems is (are) decidable?\nI. The computation C lasts for at least n steps.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nIII. M scans at least n distinct tape squares during the computation C.", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "D", "model_answer": ""}
{"question": "A 3-way, set-associative cache is", "choices": [{"label": "A", "text": "one in which each main memory word can be stored at any of 3 cache locations"}, {"label": "B", "text": "effective only if 3 or fewer processes are running alternately on the processor"}, {"label": "C", "text": "possible only with write-back"}, {"label": "D", "text": "faster to access than a direct-mapped cache"}], "answerKey": "A", "model_answer": ""}
{"question": "Consider an object-oriented language in which all entities are objects. Two relationships arise: (1) the instance relationship, between an object and the class of which that object is a member, and (2) the subclass relationship, between a class and the superclass from which that class inherits properties. In such a language, when a message is sent to an object requesting execution of one of its methods (procedures), the method is located by following", "choices": [{"label": "A", "text": "one instance link and then zero or more subclass links"}, {"label": "B", "text": "one or more instance links and then one or more subclass links"}, {"label": "C", "text": "one or more instance links"}, {"label": "D", "text": "one subclass link and then one or more instance links"}], "answerKey": "A", "model_answer": ""}
{"question": "In a pipelined RISC computer where all arithmetic instructions have the same CPI (cycles per instruction), which of the following actions would improve the execution time of a typical program?\nI. Increasing the clock cycle rate\nII. Disallowing any forwarding in the pipeline\nIII. Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "D", "model_answer": ""}
{"question": "A microcomputer used for data acquisition and control is required to digitize and process four analog input signals and to output their average continually; i.e., in real time. The time for an external analog-to-digital converter (which is triggered by a CPU instruction) to digitize one input is 12 microseconds, and only one digitization occurs at a time. Five CPU instructions, including the triggering instruction, must be executed for each signal digitized. Ten CPU instructions are executed in order to average each set of four samples and output this value. The time to convert the output from digital to analog form is to be ignored. If it is assumed that suitable data buffering is employed, then the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates, is", "choices": [{"label": "A", "text": "0.8 microseconds"}, {"label": "B", "text": "1.2 microseconds"}, {"label": "C", "text": "1.6 microseconds"}, {"label": "D", "text": "2.4 microseconds"}], "answerKey": "C", "model_answer": "LECTURE: Measurements are written with both a number and a unit. The unit comes after the number. The unit shows what the number means.\nMicroseconds and nanoseconds are units of time. 1 microsecond is less than 1 nanosecond.\n1 microsecond is on the order of 1 million picoseconds.\n1 nanosecond is on the order of 1 billion picoseconds.\nSOLUTION: The average instruction execution time is the maximum time it takes to execute a set of instructions. This time should be less than or equal to the maximum average time allowed.\nThe maximum average instruction execution time is 1.6 microseconds.\nThe time for one instruction execution is 12 microseconds.\nSo, the maximum number of instruction executions for one input signal is 1.6 microseconds / 12 microseconds.\nThis maximum number of instruction executions is 0.13.\nSo, the maximum average instruction execution time for one input signal is 0.13 instructions.\nThe average of four samples is computed by executing 10 instructions.\nSo, the maximum average instruction execution time for all four signals is 0.13 instructions + 10 instructions.\nThis average maximum instruction execution time is 1.6 microseconds."}
{"question": "Suppose that a certain software product has a mean time between failures of 10,000 hours and has a mean time to repair of 20 hours. If the product is used by 100 customers, what is its availability?", "choices": [{"label": "A", "text": "80%"}, {"label": "B", "text": "90%"}, {"label": "C", "text": "98%"}, {"label": "D", "text": "99.80%"}], "answerKey": "D", "model_answer": ""}
