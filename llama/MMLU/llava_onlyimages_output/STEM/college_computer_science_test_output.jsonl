{"question": "The access matrix approach to protection has the difficulty that", "choices": [{"label": "A", "text": "the matrix, if stored directly, is large and can be clumsy to manage"}, {"label": "B", "text": "it is not capable of expressing complex protection requirements"}, {"label": "C", "text": "deciding whether a process has access to a resource is undecidable"}, {"label": "D", "text": "there is no way to express who has rights to change the access matrix itself"}], "answerKey": "A", "model_answer": "SOLUTION: The access matrix approach to protection has the difficulty that deciding whether a process has access to a resource is undecidable."}
{"question": "An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y. Which of the following sets of integers could possibly be the set of all common divisors of two integers?", "choices": [{"label": "A", "text": "{-6,-2, -1, 1, 2, 6}"}, {"label": "B", "text": "{-6, -2, -1, 0, 1, 2, 6}"}, {"label": "C", "text": "{-6, -3, -2, -1, 1, 2, 3, 6}"}, {"label": "D", "text": "{-6, -3, -2, -1, 0, 1, 2, 3, 6}"}], "answerKey": "C", "model_answer": ""}
{"question": "In the NoNicks operating system, the time required by a single file-read operation has four nonoverlapping components:\ndisk seek time-25 msec\ndisk latency time-8 msec\ndisk transfer time- 1 msec per 1,000 bytes\noperating system overhead-1 msec per 1,000 bytes + 10 msec\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes. The ratio of-the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately", "choices": [{"label": "A", "text": "1:4"}, {"label": "B", "text": "1:3.5"}, {"label": "C", "text": "1:1"}, {"label": "D", "text": "1.1:1"}], "answerKey": "B", "model_answer": "LECTURE: A computer's file system is designed to organize data on a storage device. One important aspect of a file system is the way it handles file reads and writes.\nThe time it takes to read a file from a storage device is called the file read time. This time is determined by several factors, including the disk seek time, the disk latency time, the disk transfer time, and the operating system overhead.\nThe disk seek time is the time it takes to locate the disk block that contains the data. This time includes the time required to spin the disk to the proper location.\nThe disk latency time is the time it takes for the disk to start moving after a read or write request is made. This time is determined by the operation of the disk's actuator, which moves the read/write head to the proper location.\nThe disk transfer time is the time it takes to transfer data from the disk to memory. This time is determined by the amount of data being transferred and the speed of the disk.\nThe operating system overhead is the time it takes for the operating system to manage the file read operation. This time includes the time required to manage the allocation of system resources for the read operation.\nTogether, these four factors determine the time it takes to read a file from a storage device.\nSOLUTION: In version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read retrieved blocks of 4,000 bytes. This change decreased the disk transfer time by 50%, but increased the disk latency time by 50% and the operating system overhead by 25%.\nThe disk latency time is now 8 msec. The operating system overhead is now 1 msec per 1,000 bytes + 10 msec.\nSo, the time required to read a large file under version 2 is given by the formula:\ntime required = (disk seek time + disk latency time + disk transfer time + operating system overhead) / 1,000\n= (25 msec + 8 msec + 1 msec per 1,000 bytes + 10 msec) / 1,000\n= 45 msec per 1,000 bytes + 10 msec\n= 55 msec per 1,000 bytes\nThis is less than the time required to read the same large file under version 1. So, the ratio of the time required to read a large file under version 2 to the time required to read the same large file under version 1 is less than 1."}
{"question": "You want to cluster 7 points into 3 clusters using the k-Means Clustering algorithm. Suppose after the first iteration, clusters C1, C2 and C3 contain the following two-dimensional points: C1 contains the 2 points: {(0,6), (6,0)} C2 contains the 3 points: {(2,2), (4,4), (6,6)} C3 contains the 2 points: {(5,5), (7,7)} What are the cluster centers computed for these 3 clusters?", "choices": [{"label": "A", "text": "C1: (3,3), C2: (4,4), C3: (6,6)"}, {"label": "B", "text": "C1: (3,3), C2: (6,6), C3: (12,12)"}, {"label": "C", "text": "C1: (6,6), C2: (12,12), C3: (12,12)"}, {"label": "D", "text": "C1: (0,0), C2: (48,48), C3: (35,35)"}], "answerKey": "A", "model_answer": ""}
{"question": "Any set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. Which of the following is NOT complete?", "choices": [{"label": "A", "text": "{AND, NOT}"}, {"label": "B", "text": "{NOT, OR}"}, {"label": "C", "text": "{AND, OR}"}, {"label": "D", "text": "{NAND}"}], "answerKey": "C", "model_answer": "LECTURE: A complete set of Boolean operators is one that is able to represent any Boolean expression.\nA set of operators is sufficient for a set of Boolean expressions if each expression in the set can be written in terms of the set of operators.\nA set of operators is necessary for a set of Boolean expressions if every operator in the set is used in at least one expression in the set.\nA set of operators is minimal for a set of Boolean expressions if every operator in the set is used in exactly one expression in the set.\nAn OR gate and an AND gate are minimal.\nAn AND gate is necessary for the set {AND, OR}, but an OR gate is not.\nAn AND gate is necessary for the set {AND, NOT}, but a NOT gate is not.\nA NOT gate is necessary for the set {NOT, OR}, but an OR gate is not.\nNAND is not AND. So, {NAND} is not complete."}
{"question": "Consider the collection of all undirected graphs with 10 nodes and 6 edges. Let M and m, respectively, be the maximum and minimum number of connected components in any graph in the collection. If a graph has no selfloops and there is at most one edge between any pair of nodes, which of the following is true?", "choices": [{"label": "A", "text": "M = 10, m = 10"}, {"label": "B", "text": "M = 10, m = 1"}, {"label": "C", "text": "M = 7, m = 4"}, {"label": "D", "text": "M = 6, m = 4"}], "answerKey": "C", "model_answer": "SOLUTION: The answer is C.\nA graph with no self-loops and no more than one edge between any pair of nodes cannot have more than one connected component. So, every undirected graph with 10 nodes and 6 edges has either 0 or 1 connected components.\nThe only graph with 10 nodes and 6 edges that has 0 connected components is the graph with no edges at all. So, M = 7 and m = 4."}
{"question": "Resolution theorem proving for showing that a formula of propositional logic is not satisfiable has which of the following properties?\nI. It is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nII. It is a complete proof system in the sense that there is a proof of unsatisfiability for every unsa tisfiable formula of propositional logic.\nIII. It is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following statements describe(s) properties of a purely segmented memory system?\nI. It divides memory into units of equal size.\nII. It permits implementation of virtual memory.\nIII. It suffers from internal fragmentation.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "B", "model_answer": ""}
{"question": "Which of the following statements about floating-point arithmetic is NOT true?", "choices": [{"label": "A", "text": "It is inherently nonassociative because some numbers have no exact representation."}, {"label": "B", "text": "It is inherently nonassociative because there have to be upper and lower bounds on the size of numbers."}, {"label": "C", "text": "Associativity can be achieved with appropriate roundoff conventions."}, {"label": "D", "text": "Some rational numbers have no exact representation."}], "answerKey": "C", "model_answer": "LECTURE: In floating-point arithmetic, numbers are represented in a way that uses a smaller number of digits. This means that some numbers have no exact representation. In other words, the result of adding two numbers that have no exact representation may be a number that has no exact representation.\nAssociativity is a property of arithmetic. In an associative operation, the order of the operations does not matter. For example, in the expression 2 + 3 + 4, the order of the operations does not matter. You can calculate the result in any order.\nFloating-point arithmetic is not inherently associative. This means that the order of operations matters. For example, in the expression 2.5 + 3.5 + 4.0, the order of operations matters. You can calculate the result in any order.\nSOLUTION: The statement that associativity can be achieved with appropriate roundoff conventions is true.\nRoundoff conventions can define how numbers are rounded to floating-point numbers. By using different rounding conventions, you can make floating-point arithmetic associative.\nSome rational numbers have no exact representation is a consequence of using a smaller number of digits to represent numbers. It is not a reason why floating-point arithmetic is not associative.\nIn order to have upper and lower bounds on the size of numbers, the numbers must be represented using a finite number of digits. This means that some numbers have no exact representation. This statement is true, but it is not a reason why floating-point arithmetic is not associative.\nIt is inherently nonassociative because some numbers have no exact representation is a reason why floating-point arithmetic is not associative."}
{"question": "Suppose sharing of tiles in a multilevel directory structure is achieved with directory entries that are links pointing to a node containing information about a shared file. Information in this node includes (1) the owner of the file, (2) a count of the number of links to the tile, and (3) the disk block numbers of the file. What is a primary drawback to this approach to sharing?", "choices": [{"label": "A", "text": "If the owner modifies the file, another user who does not share will see the changes."}, {"label": "B", "text": "If the owner renames the file, other users will not be able to access it."}, {"label": "C", "text": "If the owner is allowed to delete a file, dangling links may result."}, {"label": "D", "text": "If any user who shares the file appends to it, others who share it will not be able to access the new disk blocks."}], "answerKey": "C", "model_answer": ""}
{"question": "Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves. Which of the following data structures will allow mergesort to work in O(n log n) time?\nI. A singly linked list\nII. A doubly linked list\nIII. An array", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "SOLUTION: Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves.\nTo do this, mergesort needs to be able to access all parts of the list. A singly linked list has a pointer to the next node in the list, but not to the previous node. A doubly linked list has pointers to both the next and previous nodes in the list. An array has a fixed size and does not have pointers.\nSo, mergesort can work in O(n log n) time with an array."}
{"question": "If p(x) is the minimal-degree interpolating polynomial for the real-valued function f(x) at the n + 1 distinct real numbers x0, .... xn what is the maximum possible degree of p(x)?", "choices": [{"label": "A", "text": "n"}, {"label": "B", "text": "n + 1"}, {"label": "C", "text": "n + 2"}, {"label": "D", "text": "2n"}], "answerKey": "A", "model_answer": "SOLUTION: A polynomial of degree n can interpolate at most n distinct values. So, the maximum possible degree of p(x) is n."}
{"question": "An internal hash table has 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is", "choices": [{"label": "A", "text": "3"}, {"label": "B", "text": "8"}, {"label": "C", "text": "10"}, {"label": "D", "text": "13"}], "answerKey": "A", "model_answer": "SOLUTION: The key 13 is inserted into the hash table, and it lands in bucket 2.\nThe hash function for 13 is 13 mod 5 = 3. So, 3 elements are in bucket 2.\nThe key 8 is inserted into the hash table, and it lands in bucket 2.\nThe hash function for 8 is 8 mod 5 = 3. So, 4 elements are in bucket 2.\nLinear resolution is used to find that 5 elements are in bucket 2. The key 24 is inserted into the hash table, and it lands in bucket 2.\nThe hash function for 24 is 24 mod 5 = 2. So, 5 elements are in bucket 2.\nThe key 10 is inserted into the hash table, and it lands in bucket 2.\nThe hash function for 10 is 10 mod 5 = 2. So, 6 elements are in bucket 2.\nThe key 3 is inserted into the hash table, and it lands in bucket 2.\nThe hash function for 3 is 3 mod 5 = 3. So, 7 elements are in bucket 2."}
{"question": "TCP protocol is responsible (among other things) for", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "C", "model_answer": "SOLUTION: The Transmission Control Protocol (TCP) is a transport layer protocol that is responsible for providing reliable, ordered, and error-checked delivery of a stream of data between applications running on different hosts.\nTCP is not involved in routing packets through the network. That is, TCP does not determine the best path for a packet to take from its source to its destination.\nTCP is not concerned with the differences among operating system architectures. TCP is a protocol that operates at the transport layer of the network stack; it does not concern itself with the underlying hardware or operating system.\nTCP is responsible for reliable delivery of packets between directly connected machines. This means that TCP guarantees that packets will be delivered in order and without errors as long as there is a clear, direct path from the sender to the receiver.\nTCP is responsible for reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected. This means that TCP guarantees that all of the packets in a message will be delivered in order and without errors, even if the messages must be sent through one or more intermediary machines."}
{"question": "Let A and B be two sets of words (strings) from \u03a3*, for some alphabet of symbols \u03a3. Suppose that B is a subset of A. Which of the following statements must always be true of A and B ?\nI. If A is finite, then B is finite.\nII. If A is regular, then B is regular.\nIII. If A is context-free, then B is context-free.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: Computers can use automata to help decide whether a string is in a language. An automaton is a mathematical model, and one common type of automaton is a finite state machine.\nA finite state machine has a finite number of states and is used to describe a regular language. Regular languages are languages that can be described with regular expressions.\nA context-free grammar is a set of rules that describe how to build strings in a language. A context-free language is a language that can be described with a context-free grammar.\nSOLUTION: A finite set is a set with a finite number of elements. So, if A is finite, then B is also finite.\nA regular language is a language that can be described with a regular expression. So, if A is regular, then B is also regular.\nA context-free language is a language that can be described with a context-free grammar. So, if A is context-free, then B is also context-free."}
{"question": "For all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings. Which of the following is true?", "choices": [{"label": "A", "text": "a^M = a"}, {"label": "B", "text": "(ax)^M = (xa)^M"}, {"label": "C", "text": "(xy)^M = y^Mx^M"}, {"label": "D", "text": "None of the above"}], "answerKey": "D", "model_answer": "SOLUTION: The base cases are e^M = e and (aw)^M = aw^Ma.\nFor the recursive case, consider (ax)^M and (xa)^M.\nBy the definition of M, (ax)^M = (xa)^M.\nNow consider (xy)^M and y^Mx^M.\nBy the definition of M, (xy)^M = y^Mx^M."}
{"question": "Which of the following is NOT a reasonable justification for choosing to busy-wait on an asynchronous event?", "choices": [{"label": "A", "text": "The wait is expected to be short."}, {"label": "B", "text": "A busy-wait loop is easier to code than an interrupt handler."}, {"label": "C", "text": "There is no other work for the processor to do."}, {"label": "D", "text": "The program executes on a time-sharing system."}], "answerKey": "D", "model_answer": "SOLUTION: A busy-wait loop is a type of loop that spins or hogs the processor by checking the status of a condition repeatedly. In a busy-wait loop, the loop body is usually small, and the loop waits for a condition to become true by checking it many times per second.\nA busy-wait loop can be a reasonable choice when the wait is expected to be short. Short waits do not cost much in terms of overall execution time.\nHowever, a busy-wait loop is not the only way to wait asynchronously. An interrupt handler is a different type of asynchronous event handler. An interrupt handler is a function that is called when an interrupt occurs. Interrupt handlers can handle interrupts asynchronously, which can improve the performance of a program.\nThere is no other work for the processor to do. This is not a reason to use a busy-wait loop. In fact, this situation is a good reason to use an interrupt handler or some other type of asynchronous event handler.\nA program that executes on a time-sharing system may use a busy-wait loop to keep a process running on a time-sharing system. On a time-sharing system, each process gets a share of the processor's time to execute. A busy-wait loop can keep a process running by hogging the processor."}
{"question": "The language {ww | w in (0 + 1)*} is", "choices": [{"label": "A", "text": "not accepted by any Turing machine"}, {"label": "B", "text": "accepted by some Turing machine, but by no pushdown automaton"}, {"label": "C", "text": "accepted by some pushdown automaton, but not context-free"}, {"label": "D", "text": "context-free, but not regular"}], "answerKey": "B", "model_answer": "LECTURE: A language is a set of strings. A Turing machine is a theoretical machine that can manipulate a string. A pushdown automaton is another type of theoretical machine.\nBoth Turing machines and pushdown automata can recognize languages. That is,, they can determine whether a string is in a language or not.\nSome languages can be recognized by Turing machines, but not by pushdown automata.\nSome languages can be recognized by pushdown automata, but not by Turing machines.\nSome languages can be recognized by both Turing machines and pushdown automata.\nSome languages are not recognized by any Turing machine or pushdown automaton.\nA language is context-free if it can be recognized by a context-free grammar.\nA language is regular if it can be recognized by a regular expression.\nSOLUTION: The language {ww | w in (0 + 1)*} is a language that can be recognized by a pushdown automaton, but not context-free.\nThis language contains the string 00.\nBut the string 00 is not in the language.\nSo, the language is not context-free."}
{"question": "Which of the following statements about Ethernets is typically FALSE?", "choices": [{"label": "A", "text": "Ethernets use circuit switching to send messages."}, {"label": "B", "text": "Ethernets use buses with multiple masters."}, {"label": "C", "text": "Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly."}, {"label": "D", "text": "Networks connected by Ethernets are limited in length to a few hundred meters."}], "answerKey": "A", "model_answer": "SOLUTION: Ethernets are a family of network protocols used to connect computers and other devices to local area networks (LANs).\nEthernet protocols use a collision-detection method to ensure that messages are transmitted properly. This method detects and resolves collisions, or conflicts, that can occur when two or more devices try to transmit a message over the network at the same time.\nNetworks connected by Ethernets are limited in length to a few hundred meters. Ethernet was designed for small local networks, and its range is limited.\nEthernet protocols use a collision-detection method to ensure that messages are transmitted properly. This method detects and resolves collisions, or conflicts, that can occur when two or more devices try to transmit a message over the network at the same time.\nEthernets use circuit switching to send messages. Circuit switching is a method of transmitting messages that sets up a dedicated path, or circuit, between two devices for the duration of the message.\nBuses with multiple masters can cause problems with message transmission. A bus is a communication path that uses a shared medium. With a bus, multiple devices can attempt to transmit messages at the same time. This can cause collisions and other transmission problems."}
{"question": "Let P be a procedure that for some inputs calls itself (i.e., is recursive). If P is guaranteed to terminate, which of the following statements must be true?\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "SOLUTION: P is a procedure that calls itself recursively. Let's review what that means.\nA procedure is a series of instructions that perform a task. A procedure may call itself, which means that it follows a call to the procedure with an immediately subsequent call to the same procedure.\nA recursive procedure is a procedure that calls itself within its body.\nFor a recursive procedure P to terminate, P must eventually reach a base case. P's base case is any case that is not a recursive case. In other words, when P reaches its base case, it has completed its task.\nBecause P is a procedure that calls itself, P has an execution path where it does not call itself only if it reaches its base case on that path.\nSo, the only way for P to have an execution path where it does not call itself is for P to have a base case.\nYou can see that this is true for all four cases.\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter."}
{"question": "Which of the following comes closest to being a perfectly secure encryption scheme?", "choices": [{"label": "A", "text": "The Caesar Cipher, a substitution cipher"}, {"label": "B", "text": "DES (Data Encryption Standard), a symmetric-key algorithm"}, {"label": "C", "text": "Enigma, a transposition cipher"}, {"label": "D", "text": "One-time pad"}], "answerKey": "D", "model_answer": "SOLUTION: Perfect security requires that the ciphertext reveals no information about the plaintext. For an encryption scheme to be perfectly secure, it must be unbreakable by any attacker, including those who can modify the encryption scheme or choose the plaintext.\nSubstitution ciphers and transposition ciphers are not perfectly secure. With a substitution cipher, an attacker can use frequency analysis to determine the most likely symbol in the plaintext. With a transposition cipher, an attacker can use brute force to try all possible permutations of the plaintext.\nThe One-Time Pad is a perfectly secure encryption scheme. An attacker who intercepts the ciphertext can never determine the plaintext.\nThe Data Encryption Standard (DES) is a symmetric-key algorithm. It is not perfectly secure. An attacker can use a technique called a brute-force search to break DES."}
{"question": "Of the following problems concerning a given undirected graph G, which is currently known to be solvable in polynomial time?", "choices": [{"label": "A", "text": "Finding a longest simple cycle in G"}, {"label": "B", "text": "Finding a shortest cycle in G"}, {"label": "C", "text": "Finding ALL spanning trees of G"}, {"label": "D", "text": "Finding a largest clique in G"}], "answerKey": "B", "model_answer": "SOLUTION: A longest simple cycle in a graph is a cycle that is longer than all other cycles in the graph. A shortest cycle in a graph is a cycle that is shorter than all other cycles in the graph. These problems are solvable in polynomial time on a graph with an Eulerian circuit.\nA graph with an Eulerian circuit is a graph that contains a cycle that is longer than all other cycles in the graph. This is equivalent to saying that the graph is a cycle-free graph with an Eulerian trail.\nA largest clique in a graph is a set of vertices that form a clique. Cliques can be found in polynomial time using a greedy algorithm.\nFinding all spanning trees of a graph is a well-known NP-complete problem."}
{"question": "The IP protocol is primarily concerned with", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "A", "model_answer": "SOLUTION: IP (Internet Protocol) is a network layer protocol. The network layer is concerned with routing packets through the network.\nPackets are a collection of data and a packet header. The packet header contains the source and destination addresses of the packet.\nThe primary purpose of the IP protocol is to route packets through a network. IP tells each node in the network where to send the packets it receives.\nIP does not provide any mechanism for reliable delivery of packets. It does not check to see if packets have been delivered. It does not re-send packets that have not been delivered.\nMany applications require reliable delivery of data. Several layers of upper layer protocols use IP to send their data. These upper layer protocols provide reliable data delivery."}
{"question": "Of the following, which best approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N?", "choices": [{"label": "A", "text": "1/K"}, {"label": "B", "text": "K-1/K"}, {"label": "C", "text": "log_10 (1/N)"}, {"label": "D", "text": "N-1/m"}], "answerKey": "A", "model_answer": "SOLUTION: In a complete K-ary tree of depth N, the number of nonterminal nodes is K-1. The total number of nodes is N. So, the ratio of nonterminal nodes to the total number of nodes is:\nK-1/K = 1/K\nThis is the same as the answer: A."}
{"question": "Consider a computer system in which processes can request and release one or more resources. Once a process has been granted a resource, the process has exclusive use of that resource until it is released. If a process requests a resource that is already in use, the process enters a queue for that resource, waiting until the resource is available. Which of the following will NOT deal effectively with the problem of deadlock?", "choices": [{"label": "A", "text": "Giving priorities to processes and ordering the wait queues by priority"}, {"label": "B", "text": "Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all"}, {"label": "C", "text": "Numbering the resources and requiring that processes request resources in order of increasing number"}, {"label": "D", "text": "Having processes time out and restart after a random interval of waiting"}], "answerKey": "A", "model_answer": "LECTURE: Deadlock occurs when multiple processes are waiting for resources that are held by other processes. A deadlock can be resolved by having one of the processes terminate, but this is not an effective way to deal with deadlock.\nAn effective way to deal with deadlock is to prevent it from occurring in the first place. One way to prevent deadlock is to use a resource allocation scheme that guarantees that a process can obtain all the resources it needs without holding on to any unnecessary resources.\nSOLUTION: Giving priorities to processes and ordering the wait queues by priority, having a process request all its required resources when it first begins, and restarting if it cannot obtain them all, and numbering the resources and requiring that processes request resources in order of increasing number are all ways to prevent deadlock by ensuring that processes request all the resources they need before they begin executing.\nHaving processes time out and restart after a random interval of waiting is not an effective way to deal with deadlock. This approach can actually increase the risk of deadlock, because it can cause processes to hold on to resources that are not strictly necessary, which can lead to other processes waiting for those resources."}
{"question": "\"Magic memory\"' has two operations: Read and Clear. Both are indivisible and mutually exclusive. Clear sets the magic memory to zero. Read returns a value that represents the number of Read operations since the last Clear operation. Which of the following is (are) true of \"Magic memory\"?\nI. It can provide the functionality of an atomic Test-and-Set.\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nIII. It is only useful on a multiprocessor.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?", "choices": [{"label": "A", "text": "Abstract Syntax Tree (AST)"}, {"label": "B", "text": "Attribute Grammar"}, {"label": "C", "text": "Symbol Table"}, {"label": "D", "text": "Semantic Stack"}], "answerKey": "C", "model_answer": "LECTURE: A symbol table is a data structure in a compiler that is responsible for managing information about variables and their attributes. It is used by the compiler to keep track of the definitions, declarations, and attributes of the variables that are used in a program.\nA symbol table typically has the following components:\nNames: The names of the variables.\nTypes: The data types of the variables.\nValues: The values of the variables. (The values of variables are typically not stored in the symbol table. Instead, the symbol table stores the expressions that are used to calculate the values of the variables.)\nAttributes: The attributes of the variables. An attribute of a variable tells you how the variable should be compiled or how it should behave at runtime.\nAn abstract syntax tree (AST) is a tree-based data structure that is used to represent the syntactic structure of a program. It is constructed by a parser as it reads through a program.\nAn attribute grammar is a set of production rules that define the attributes of the elements in a language. An attribute grammar can be used to define a language's syntax and to implement a compiler for that language.\nA semantic stack is a data structure that is used to keep track of the current scope in a program. It is used by the compiler to determine which variables are accessible from a particular point in the program."}
{"question": "Which of the following algorithms has running time \u0398(n^2) in the worst case but \u0398(n log n) on average?", "choices": [{"label": "A", "text": "Bubblesort"}, {"label": "B", "text": "Mergesort"}, {"label": "C", "text": "Heapsort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "D", "model_answer": "LECTURE: An algorithm's time complexity is a measure of the algorithm's efficiency. The time complexity of an algorithm is determined by the number of operations it performs.\nBig O notation is a way to express a function's growth rate. For example, the following Big O notations are common:\n\u2022 O(1) means that the function performs a constant number of operations.\n\u2022 O(log n) means that the function performs a number of operations that grows logarithmically with n.\n\u2022 O(n) means that the function performs a number of operations that grows linearly with n.\n\u2022 O(n^2) means that the function performs a number of operations that grows quadratically with n.\n\u2022 O(2^n) means that the function performs a number of operations that grows exponentially with n.\nSOLUTION: Mergesort, Heapsort, and Bubblesort all have running times of O(n^2) in the worst case. So, they do not meet the requirement that there is an algorithm with running time \u0398(n^2) in the worst case but \u0398(n log n) on average.\nQuicksort has a running time of O(n log n). So, it meets the requirement."}
{"question": "Languages with a structure that implements abstract data types (e.g., a C++ class) can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation). Which of the following statements about comparisons between direct and indirect representations is (are) true?\nI. Indirect representation noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following is NOT a property of bitmap graphics?", "choices": [{"label": "A", "text": "Fast hardware exists to move blocks of pixels efficiently."}, {"label": "B", "text": "Realistic lighting and shading can be done."}, {"label": "C", "text": "All line segments can be displayed as straight."}, {"label": "D", "text": "Polygons can be filled with solid colors and textures."}], "answerKey": "C", "model_answer": "SOLUTION: A property of bitmap graphics is that all line segments can be displayed as straight.\nA bitmap is a raster, or image, format. It is a grid of pixels, or small images. Line segments can be displayed as straight in a bitmap, but only if they are drawn one pixel at a time."}
{"question": "Which of the following is true of interrupts?", "choices": [{"label": "A", "text": "They are generated when memory cycles are \"stolen\"."}, {"label": "B", "text": "They are used in place of data channels."}, {"label": "C", "text": "They can indicate completion of an I/O operation."}, {"label": "D", "text": "They cannot be generated by arithmetic operations."}], "answerKey": "C", "model_answer": "SOLUTION: Interrupts are a way for a running program to tell the CPU to stop running and do something else instead. Interrupts cannot be generated by arithmetic operations.\nWhen an interrupt occurs, the CPU stops running the program it was executing and starts running a different program that is designed to handle the interrupt. This new program is called the interrupt service routine, or ISR."}
{"question": "In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. Which of the following are true of such a tree?\nI. Worst-case search time is logarithmic in the number of nodes.\nII. Average-case search time is logarithmic in the number of nodes.\nIII. Best-case search time is proportional to the height of the tree.\nIV. The height of the tree is logarithmic in the number of nodes.", "choices": [{"label": "A", "text": "I and III only"}, {"label": "B", "text": "II and III only"}, {"label": "C", "text": "II and IV only"}, {"label": "D", "text": "I, II, and IV"}], "answerKey": "D", "model_answer": "SOLUTION: In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. So, the height of the tree is logarithmic in the number of nodes.\nWorst-case search time is proportional to the height of the tree. So, worst-case search time is logarithmic in the number of nodes.\nBest-case search time is proportional to the height of the tree. So, best-case search time is logarithmic in the number of nodes.\nAverage-case search time is determined by the height of the tree. So, average-case search time is logarithmic in the number of nodes."}
{"question": "Bob writes down a number between 1 and 1,000. Mary must identify that number by asking \"yes/no\" questions of Bob. Mary knows that Bob always tells the truth. If Mary uses an optimal strategy, then she will determine the answer at the end of exactly how many questions in the worst case?", "choices": [{"label": "A", "text": "1,000"}, {"label": "B", "text": "999"}, {"label": "C", "text": "500"}, {"label": "D", "text": "10"}], "answerKey": "D", "model_answer": "LECTURE: A question is a question, right? Well, yes and no.\nSome questions can be answered with a single yes or no. Other questions are more complicated and require more than one question to answer.\nImagine a student needs to determine if she has a pencil. She can answer this question with a single yes or no.\nBut imagine a scientist needs to determine an animal's weight. She may need to ask multiple questions to find the answer. First, she might need to ask if the animal is alive. If the animal is alive, she can then ask about its weight.\nIn general, the fewer questions you have to ask to answer a question, the more efficient the question is. Efficiency is a good thing.\nSOLUTION: Mary needs to determine a number between 1 and 1,000. She can do this by asking one question.\nIf Mary asks a single question, she can determine the answer with one question in the worst case."}
{"question": "Which of the following is (are) true about virtual memory systems that use pages?\nI. The virtual address space can be larger than the amount of physical memory.\nII. Programs must be resident in main memory throughout their execution.\nIII. Pages correspond to semantic characteristics of the program.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following is usually NOT represented in a subroutine's activation record frame for a stack-based programming language?", "choices": [{"label": "A", "text": "Values of local variables"}, {"label": "B", "text": "A heap area"}, {"label": "C", "text": "The return address"}, {"label": "D", "text": "Stack pointer for the calling activation record"}], "answerKey": "B", "model_answer": "LECTURE: A subroutine is a block of code that performs a specific task. Subroutines can be called by other parts of a program.\nWhen a subroutine is called, an activation record is created. An activation record contains information about the call, including the values of any arguments that were passed to the subroutine.\nWhen the subroutine returns, the activation record is removed from the stack. The activation record for a subroutine is destroyed when control is returned to the part of the program that called the subroutine.\nAn activation record has a fixed size. It contains a stack pointer for the calling activation record and a return address. The stack pointer points to the top of the stack for the calling activation record. The return address is the address that the calling activation record will be stored at when the subroutine is done executing.\nWhen the subroutine begins, it uses the stack pointer and return address from the activation record to find its own local variables. The stack pointer points to the top of the stack for the subroutine. The return address is the address that the subroutine will be stored at when it is done executing.\nSOLUTION: A heap area is a block of memory that is managed by a program. A heap area can be created and destroyed automatically by a program.\nA subroutine's activation record does not need to contain a heap area. The activation record contains the stack pointer for the calling activation record and the return address.\nThe stack pointer for the calling activation record points to the top of the stack for the calling activation record. The calling activation record contains the values of local variables.\nThe return address is the address that the calling activation record will be stored at when the subroutine is done executing. The calling activation record contains the values of local variables."}
{"question": "Which of the following statements about a remote procedure call is true?", "choices": [{"label": "A", "text": "It is used to call procedures with addresses that are farther than 2^16 bytes away."}, {"label": "B", "text": "It cannot return a value."}, {"label": "C", "text": "It cannot pass parameters by reference."}, {"label": "D", "text": "It cannot call procedures implemented in a different language."}], "answerKey": "C", "model_answer": "SOLUTION: A remote procedure call (RPC) is a type of program call that is used to call procedures that are implemented in a different address space.\nAn RPC can return a value.\nTo accomplish its goals, an RPC can pass parameters by reference.\nAn RPC can call procedures that are implemented in a different language.\nAn RPC is used to call procedures with addresses that are farther than 2^16 bytes away."}
{"question": "Of the following sorting algorithms, which has a running time that is LEAST dependent on the initial ordering of the input?", "choices": [{"label": "A", "text": "Insertion sort"}, {"label": "B", "text": "Quicksort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Selection sort"}], "answerKey": "C", "model_answer": ""}
{"question": "A particular parallel program computation requires 100 seconds when executed on a single processor. If 40 percent of this computation is \"inherently sequential\" (i.e., will not benefit from additional processors), then the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are", "choices": [{"label": "A", "text": "20 and 10 seconds"}, {"label": "B", "text": "30 and 15 seconds"}, {"label": "C", "text": "50 and 25 seconds"}, {"label": "D", "text": "70 and 55 seconds"}], "answerKey": "D", "model_answer": "LECTURE: A parallel program is one that can be executed on multiple processors at the same time. The execution of a parallel program may take less time than the execution of an equivalent sequential program. This is because the parallel program can be executed on multiple processors at the same time.\nThe amount of time that a parallel program takes to execute is called the elapsed time. The elapsed time for a parallel program is given by the following formula:\nelapsed time = proportion of inherently sequential work / proportion of parallel work \u00d7 sequential time\nThe proportion of inherently sequential work is a measure of the portion of the program that is not parallelizable. This proportion is given by the formula:\nproportion of inherently sequential work = (time taken to execute the inherently sequential work) / (total time taken to execute the program)\nThe remaining portion of the program is parallelizable. The proportion of parallel work is a measure of the portion of the program that is parallelizable. This proportion is given by the formula:\nproportion of parallel work = (time taken to execute the parallelizable work) / (total time taken to execute the program)\nSubstituting the formulas for the proportion of inherently sequential work and the proportion of parallel work into the formula for the elapsed time, we get:\nelapsed time = (40% / 60%) / (20% + 40% / 60%) \u00d7 100 seconds\nelapsed time = 10 seconds\nThis means that the theoretically best possible elapsed time for this program running with 2 processors is 10 seconds.\nTo get the actual elapsed time for a program, you can measure the time that it takes to execute the program on a particular computer. The actual elapsed time may be different from the theoretically best possible elapsed time, as it may be affected by factors such as the computer's hardware and the way the program is executed.\nSOLUTION: The program takes 100 seconds to execute on a single processor. The proportion of inherently sequential work is 40% and the proportion of parallel work is 60%. So, the theoretically best possible elapsed time for the program running with 2 processors is 10 seconds.\nThe proportion of inherently sequential work is 40% and the proportion of parallel work is 60%. So, the theoretically best possible elapsed time for the program running with 4 processors is 20 seconds."}
{"question": "Consider the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude. In which representation is there overflow from the addition of the integers 011000 and 011000?", "choices": [{"label": "A", "text": "Two's complement only"}, {"label": "B", "text": "Sign and magnitude and one's complement only"}, {"label": "C", "text": "Two's complement and one's complement only"}, {"label": "D", "text": "All three representations"}], "answerKey": "D", "model_answer": "LECTURE: A computer uses numbers to represent data. These numbers are called numbers with binary (base-2) representation.\nOne type of number with binary representation is the six-bit number. A six-bit number is a number with six binary digits.\nSOLUTION: In the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude, there is overflow from the addition of the integers 011000 and 011000. This means that the result of the addition is not representable in this representation.\nOverflow occurs in the two's complement representation. The two's complement of 011000 is 100111. In this representation, there is overflow from the addition of 011000 and 011000.\nThe sign and magnitude representation does not have overflow.\nThe one's complement representation does not have overflow."}
{"question": "Of the following, which best characterizes computers that use memory-mapped I/O?", "choices": [{"label": "A", "text": "The computer provides special instructions for manipulating I/O ports."}, {"label": "B", "text": "I/O ports are placed at addresses on the bus and are accessed just like other memory locations."}, {"label": "C", "text": "To perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}, {"label": "D", "text": "Ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}], "answerKey": "B", "model_answer": "SOLUTION: Memory-mapped I/O means that the I/O ports are placed at addresses on the bus and are accessed just like other memory locations. This is different from using special instructions to manipulate I/O ports.\nWhen I/O ports are memory-mapped, ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations. This allows the use of the same instruction to access both memory and I/O ports.\nTo perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}
{"question": "Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that", "choices": [{"label": "A", "text": "integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs"}, {"label": "B", "text": "P = NP"}, {"label": "C", "text": "even if P = NP, integer factorization is still likely not to be polynomial-time computable"}, {"label": "D", "text": "testing primality is computationally intractable"}], "answerKey": "A", "model_answer": "SOLUTION: Many cryptographic protocols base their security on the assumption that integer factorization is a computationally difficult task.\nOne of the reasons why integer factorization serves this purpose is that we believe that integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs."}
{"question": "Which of the following sets of bit strings CANNOT be described with a regular expression?", "choices": [{"label": "A", "text": "All bit strings whose number of zeros is a multiple of five"}, {"label": "B", "text": "All bit strings starting with a zero and ending with a one"}, {"label": "C", "text": "All bit strings with an even number of zeros"}, {"label": "D", "text": "All bit strings with more ones than zeros"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following conditions can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac)?\nI. At least three of p_1, p_2, p_3, p_4 are true.\nII. Exactly three of p_1, p_2, p_3, p_4 are true.\nIII. An even number of p_1, p_2, p_3, p_4 are true.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "LECTURE: A Boolean variable is a variable that can have only two values: true and false. A Boolean formula is a formula that uses Boolean variables and the connectives \u2227, \u2228, and \u00ac.\nThe connectives \u2227, \u2228, and \u00ac have the following meanings:\n\u2227 is the AND connective. A formula using \u2227 has the value true only if all of its sub-formulas have the value true.\n\u2228 is the OR connective. A formula using \u2228 has the value true if any of its sub-formulas have the value true.\n\u00ac is the NOT connective. \u00acP is true if P is false.\n\nAn expression is a combination of one or more variables and one or more constants. An expression uses the connectives \u2227, \u2228, and \u00ac.\nA Boolean formula is a formula that uses only constants and variables that are included in one or more expressions.\nA formula that is a combination of simpler formulas is called a Boolean expression.\nA Boolean expression that is a formula uses the same connectives as a Boolean formula.\nA constant is a value that does not change. A variable is a value that may change.\n\nSOLUTION: The condition in question can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227, \u2228.\nTo satisfy the condition, at least three of the p_i must be true. This means that the formula must have the value true. The only way for the formula to have the value true is for all of the p_i to be true. This means that the formula must use the \u2228 connective.\nThe formula cannot use the \u2227 connective. If the formula used the \u2227 connective, it would have the value true only if all of the p_i were true. This would mean that the formula would have the value true only if an even number of the p_i were true.\nThe formula cannot use the \u00ac connective. If the formula used the \u00ac connective, it would have the value true if an odd number of the p_i were true.\nSo, the formula must use the \u2228 connective and must have the value true if an odd number of the p_i are true. This means that the formula must be of the form:\n(p_1 \u2228 p_2 \u2228 p_3) \u2227 (p_4 \u2228 \u00acp_1 \u2228 \u00acp_2 \u2228 \u00acp_3)\nThis formula uses the \u2228 connective and has the value true if an odd number of the p_i are true."}
{"question": "Two alternatives for interconnecting a set of processors with bidirectional links are (1) the fully interconnected network, in which each processor is directly connected to every other processor, and (2) the ring network, in which each processor is connected to two other processors. The worst-case path length for a network is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes. For each type of interconnection of n processors, a figure of merit can be formed as the product of the number of links required for the network times the worst-case path length connecting any two processors. The ratio of this figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is", "choices": [{"label": "A", "text": "1/(n^2)"}, {"label": "B", "text": "1/(n(n-1))"}, {"label": "C", "text": "1/n"}, {"label": "D", "text": "(n-1)/n"}], "answerKey": "D", "model_answer": "LECTURE: For a network, the worst-case path length is a figure of merit. It tells you the maximum distance between a node and any other node in the network.\nOne way to calculate the worst-case path length is to consider the ring network. In a ring network, the worst-case path length is the same for all pairs of nodes. So, for each node, the worst-case path length is the number of links in the ring, times the minimum number of links needed to get from that node to any other node in the ring.\nThe fully interconnected network has a higher worst-case path length than a ring network. This is because each node in a fully interconnected network has more links to other nodes than in a ring network. So, the figure of merit for the fully interconnected network is higher than that of the ring network.\nSOLUTION: To see this, consider an example with 4 processors. In a fully interconnected network, each processor is connected to every other processor. So, each processor has 3 links. The worst-case path length is 3. In a ring network, each processor is connected to two other processors. So, each processor has 2 links. The worst-case path length is also 2. The figure of merit for the fully interconnected network is 3 times the worst-case path length, which is 3 times 2 = 6. The figure of merit for the ring network is 2 times the worst-case path length, which is 2 times 2 = 4. So, the ratio of the figure of merit for the fully interconnected network to that for the ring network is 6/4 = 1.5.\nFor even n > 2, each node in the fully interconnected network has n links. So, the figure of merit for the fully interconnected network is n times the worst-case path length, which is n times the number of links between any two nodes. The figure of merit for the ring network is 2 times the worst-case path length, which is 2 times the number of links between any two nodes. So, the ratio of the figure of merit for the fully interconnected network to that for the ring network is n times the worst-case path length/2 times the worst-case path length, which is n/2."}
{"question": "For a connected, undirected graph G = (V, E), which of the following must be true?\nI. \u03a3_{v\u2208V} degree(v) is even.\nII. |E| \u2265 |V| \u2212 1\nIII. G has at least one vertex with degree 1.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "SOLUTION: A graph is connected if there is a path between any two vertices. An undirected graph is one in which each edge is paired with another edge, and both edges are assigned the same direction.\nG has at least one vertex with degree 1. A vertex with degree 1 is a isolated vertex. In a connected graph, all vertices are connected to each other. So, if a vertex has degree 1, it means that it is not connected to any other vertices.\nSince G is connected, it does not have any isolated vertices. So, III is not true.\nThe parity of an integer is either even or odd. An even integer is a multiple of 2.\nDegree(v) is the number of edges incident to vertex v. So, \u03a3_{v\u2208V} degree(v) is the sum of the degrees of all vertices.\nSince G is connected, \u03a3_{v\u2208V} degree(v) is even if and only if each degree is even.\nSo, I. is true.\nIn a graph, the number of edges is also known as the degree of the graph.\nSo, II. is true."}
{"question": "In multiprogrammed systems it is advantageous if some programs such as editors and compilers can be shared by several users. Which of the following must be true of multiprogrammed systems in order that a single copy of a program can be shared by several users?\nI. The program is a macro.\nII. The program is recursive.\nIII. The program is reentrant.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following decimal numbers has an exact representation in binary notation?", "choices": [{"label": "A", "text": "0.1"}, {"label": "B", "text": "0.2"}, {"label": "C", "text": "0.3"}, {"label": "D", "text": "0.5"}], "answerKey": "D", "model_answer": "LECTURE: A decimal number is a number that is written in the decimal system. In the decimal system, numbers are written in the form a.b.c..., where a is the first number, b is the second number, and c is the third number.\nA binary number is a number that is written in the binary system. In the binary system, numbers are written in the form a.b.c.d..., where a is the first number, b is the second number, c is the third number, and d is the fourth number.\nMost computers use binary numbers. They can be designed to perform calculations and operations on binary numbers.\nA decimal number has an exact representation in binary notation if and only if every digit in the decimal representation of the number is either 0 or 1.\nSOLUTION: To have an exact representation in binary notation, the decimal number must have a binary representation that is either 0.0 or 1.0.\n0.1 is not equal to 0.2.\n0.1 is a number between 0 and 1, and 0.2 is a number between 0 and 1.\nBoth 0.1 and 0.2 have an exact representation in binary notation.\n0.3 is not equal to 0.5.\n0.3 is a number between 0 and 1, and 0.5 is a number between 0 and 1.\n0.3 has a binary representation that is between 0.0 and 1.0. So, 0.3 has an exact representation in binary notation.\n0.5 is a number that is not between 0 and 1. So, 0.5 does not have an exact representation in binary notation."}
{"question": "Function signatures describe the types of the arguments to a function as well as the return value of the function. For instance, the addition function on reals has a signature of\nadd : real x real -> real\nsince it takes two real numbers and returns a real number. But, for a language that allows functions as return values, addition could be considered to have the signature\nadd : real -> (real -> real)\nwhich means that add takes a single real (the first operand) and returns a new function that itself takes a single real (the second operand) and returns a real (the result). This process of reducing a function with multiple arguments to a function with fewer arguments is called currying. Which of the following is correct?", "choices": [{"label": "A", "text": "Currying can be applied to any function to the point where it has exactly one input argument."}, {"label": "B", "text": "Currying cannot be applied to functions of more than two arguments."}, {"label": "C", "text": "Currying cannot be applied to functions that return functions as arguments."}, {"label": "D", "text": "Currying cannot be applied w functions that haw arguments that are functions."}], "answerKey": "A", "model_answer": "SOLUTION: Currying is the process of transforming a function that takes multiple arguments into a function that takes a single argument and returns a function that takes the remaining argument.\nCurrying can be applied to any function to the point where it has exactly one input argument.\nA function that takes a single input argument and returns a function that takes a single additional argument has the signature:\nadd : real -> (real -> real)\nThis function takes a single real number as its input and returns a new function that takes a single real number as its input and returns a real number as its output."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-back policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2000"}], "answerKey": "A", "model_answer": ""}
{"question": "In which of the following representations of numbers by 8-bit words is the addition of the integers 109 and -42 within range?\nI. One's complement\nII. Two's complement\nIII. Sign and magnitude", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: An 8-bit word can represent numbers in the range from -128 to 127.\nTo write a number in sign and magnitude form, you write the sign of the number in the most significant bit and the magnitude of the number in the remaining bits. The magnitude of a number is the same as the number itself.\nFor example, the 8-bit word 0000128 represents the number -128.\nTo represent the number 0 in 8-bit word form, you write 0 in the most significant bit and 0 in the remaining 7 bits.\nFor example, the 8-bit word 00000000 represents the number 0.\nOne's complement is a way of writing a number in 8-bit word form. To write a number in one's complement form, you write 1 in the most significant bit and use the remaining 7 bits to write the two-complement of the magnitude of the number.\nFor example, the 8-bit word 11111111 represents the number 127.\nTo write the two's complement of a number in 8-bit word form, you write 1 in the most significant bit and use the remaining 7 bits to write the two's complement of the magnitude of the number.\nFor example, the 8-bit word 11111071 represents the number -125.\nThe sign and magnitude form of a number is the same as writing the number in ordinary decimal form.\nFor example, the 8-bit word 00001001 represents the number 100.\nSOLUTION: To add 109 and -42 in sign and magnitude form, you first add the two numbers. Then, you write the result in sign and magnitude form.\n109 + (-42) = 171\nIn sign and magnitude form, 171 is represented by the 8-bit word 00001111.\nSo, the addition of 109 and -42 is within range.\nTo add 109 and -42 in two's complement form, you first add the two numbers. Then, you write the result in two's complement form.\n109 + (-42) = 171\nIn two's complement form, 171 is represented by the 8-bit word 11111071.\nSo, the addition of 109 and -42 is within range.\nTo add 109 and -42 in one's complement form, you first add the two numbers. Then, you write the result in one's complement form.\n109 + (-42) = 171\nIn one's complement form, 171 is represented by the 8-bit word 11111111.\nSo, the addition of 109 and -42 is not within range."}
{"question": "If a malicious process is granted temporary administrator-level access to a system", "choices": [{"label": "A", "text": "the threat is over as soon as the process is killed"}, {"label": "B", "text": "the threat is over after the operating system is rebooted"}, {"label": "C", "text": "the thread is over after rebooting the machine and replacing files that show a virus infection"}, {"label": "D", "text": "the threat is often permanent until the entire disk is wiped clean"}], "answerKey": "D", "model_answer": "SOLUTION: When a malicious process is granted temporary administrator-level access to a system, it can do serious harm. If you're logged in as a standard user and a malicious process gets elevated privileges, the best way to stop the threat is to kill the offending process. However, the threat is over only if the process was the only thing caused by the malware.\nMany pieces of malware are designed to survive by creating new threads or processes that run as regular users. These threads and processes can do things like install additional malware, modify system settings, or upload data. So, after you kill the original process, these additional threads and processes may continue to pose a threat.\nTo stop all of the threads and processes, you need to find and terminate them. This may involve inspecting system logs and other data to identify the processes and threads that the malware has created.\nIn some cases, a malicious process may be able to damage a system so badly that it won't boot. In this case, you may need to reboot the machine and replace any files that show a virus infection. This can remove the threat, but it may also erase all of the data on the system.\nIf the malware is designed to be permanent, it may be difficult to remove. In this case, the threat is often permanent until the entire disk is wiped clean."}
{"question": "Which of the following statements about horizontal versus vertical microarchitecture is (are) true?\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nII. Horizontal microinstructions are unencoded.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "SOLUTION: II. is false.\nHorizontal microinstructions are not unencoded."}
{"question": "A \"strictly binary tree\" is a binary tree in which every node that is not a leaf has two children. Suppose that for a class of strictly binary trees there exists c > 0 such that, for any tree in the class, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. Which of the following best characterizes the height h of any tree in this class, where N is the number of nodes in the tree and N > 1 ?", "choices": [{"label": "A", "text": "h <= log2(N)"}, {"label": "B", "text": "h = 1/c * log2(N)"}, {"label": "C", "text": "h < c log2(N)"}, {"label": "D", "text": "h > c log2(N)"}], "answerKey": "C", "model_answer": "SOLUTION: The ratio of the lengths of any two root-to-leaf paths is bounded above by c, which means that the height of the tree is bounded above by c log2(N).\nSo, h < c log2(N)."}
{"question": "Which of the following sorting algorithms has average-case and worst-case running times of O(n log n)?", "choices": [{"label": "A", "text": "Bubble sort"}, {"label": "B", "text": "Insertion sort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "C", "model_answer": "SOLUTION: Merge sort and quicksort are O(n log n) in their worst-case and average-case running times. Bubble sort and insertion sort are not.\nMerge sort and quicksort use dividing and conquering to sort the data. This strategy takes advantage of the fact that smaller subproblems can be sorted in O(n log n) time.\nBubble sort and insertion sort use simpler strategies. Bubble sort compares each pair of adjacent elements and swaps them if they are in the wrong order. Insertion sort puts each element in its proper position by comparing it with adjacent elements.\nBoth bubble sort and insertion sort have O(n^2) average-case and worst-case running times."}
{"question": "Consider the following equations concerning a stack module that has the operations Push, Pop, Top, and IsEmpty. Which of the equations does NOT represent the conventional semantics of a stack?", "choices": [{"label": "A", "text": "IsEmpty(Push(Stack,Elem)) = true"}, {"label": "B", "text": "Pop(Push(Stack,Elem)) = Stack"}, {"label": "C", "text": "Top(Push(Stack,Elem)) = Elem"}, {"label": "D", "text": "IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false"}], "answerKey": "A", "model_answer": "LECTURE: Equations are used to describe how a function behaves. Equations for algorithms often contain statements that describe the behavior of the algorithm for each possible input.\nA set of equations that describes the behavior of an algorithm is called the algorithm's conventional semantics. The conventional semantics for a stack can be described with the following equations:\nPush(Stack, Elem)\nTop(Stack) = Elem\nPop(Stack) = Elem\nIsEmpty(Stack) = false\nIsEmpty(Push(Stack, Elem)) = true\nThese equations describe the behavior of a stack. The first three equations define the behavior of the Push, Top, and Pop operations, respectively. The last two equations describe the behavior of the stack when it is empty.\nThe equation IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false does not describe the conventional semantics of a stack. It is not a correct equation to include in the conventional semantics for a stack.\nThe purpose of the Push operation is to add an element to the top of a stack. The Pop operation should remove the element that was added to the stack by the Push operation. The Top operation should return the most recently added element.\nIsEmpty should return false when the stack is not empty."}
{"question": "Assume that any assignment statement can be executed in unit time. If as many identical processors as needed are used, what is the minimum number of time units needed to execute the assignments\nA := B + C\nB := A - B\nC := A * E\nD := A/F\nE := B - C\nF := A + B\nwith the same result as if the assignments were executed in the order shown?", "choices": [{"label": "A", "text": "1"}, {"label": "B", "text": "2"}, {"label": "C", "text": "3"}, {"label": "D", "text": "4"}], "answerKey": "C", "model_answer": "LECTURE: The order in which statements are executed affects the result of the program. This is known as the order of evaluation.\nFor example, consider the following program:\nx := 1\ny := 2\nz := x + y\nw := x - y\nIn this program, the statement z := x + y is executed before the statement w := x - y. So, the value of z is 3, and the value of w is 1.\nNow consider the following program:\nx := 1\ny := 2\nw := x - y\nz := x + y\nIn this program, the statement w := x - y is executed before the statement z := x + y. So, the value of w is 1, and the value of z is 3.\nThe order of evaluation affects the result of the program. You can change the order of evaluation by rewriting the program.\nFor example, the following program is equivalent to the second program above:\nx := 1\ny := 2\nw := x - y\nz := x + y\nBy reordering the statements, you can change the order of evaluation.\nSOLUTION: To execute the assignments in the order shown, you need to follow these steps:\nB.\nC.\nD.\nE.\nF.\nA.\nThe order of evaluation is as follows:\nA is assigned the value of B + C.\nB is assigned the value of A - B.\nC is assigned the value of A * E.\nD is assigned the value of A/F.\nE is assigned the value of B - C.\nF is assigned the value of A + B.\nFinally, the result is A."}
{"question": "Two expressions E and F are said to be unifiable if there are substitutions for the variables of E and F that make the expressions lexically identical. In the following three expressions, only w, x, y, and z are variables.\nI. f(w,w)\nII. f(x,1)\nIII. f(y,g(z))\nWhich pairs of these expressions is (are) pairs of unifiable expressions?", "choices": [{"label": "A", "text": "(I, II) only"}, {"label": "B", "text": "(I, III) only"}, {"label": "C", "text": "(II, III) only"}, {"label": "D", "text": "(I, II) and (I, III) only"}], "answerKey": "D", "model_answer": "LECTURE: Two expressions are unifiable if there is a substitution that makes the expressions equal.\nFor example, the expressions f(a,b) and g(a,c) are unifiable. The substitution a=b and c=d makes f(a,b) equal to g(a,c).\n\nSOLUTION: Each of the three expressions has a different variable. So, no pairs of the expressions are unifiable."}
{"question": "Which of the following instruction-set features is NOT generally considered an obstacle to aggressive pipelining of an integer unit?", "choices": [{"label": "A", "text": "Condition codes set by every instruction"}, {"label": "B", "text": "Variable-length encoding of instructions"}, {"label": "C", "text": "Instructions requiring widely varying numbers of cycles to execute"}, {"label": "D", "text": "Several different classes (sets) of registers"}], "answerKey": "D", "model_answer": "LECTURE: Pipelining is a technique that is widely used in the design of CPUs. Pipelining a unit means that the unit is designed to have several stages, each of which performs a different step of the unit's operation.\nAn instruction-set feature that is not generally considered an obstacle to aggressive pipelining of an integer unit is condition codes set by every instruction. Setting condition codes is a useful technique for optimizing the performance of a CPU. However, it is not a significant obstacle to pipelining.\nInstructions requiring widely varying numbers of cycles to execute are a significant obstacle to aggressive pipelining of an integer unit. The cycle time of a CPU is the time it takes to perform a single cycle. Pipelining a unit means that the unit has several stages. Instructions that require widely varying numbers of cycles to execute can make it difficult to synchronize the stages of a unit.\nHaving several different classes (sets) of registers is a significant obstacle to aggressive pipelining of an integer unit. In a pipelined integer unit, each stage needs to have access to a set of registers. Having several different classes of registers can make it difficult to design a pipelined integer unit that is both efficient and easy to implement.\nVariable-length encoding of instructions is a significant obstacle to aggressive pipelining of an integer unit. Pipelining a unit means that the unit has several stages. Each stage needs to be able to process a different number of bits. Variable-length encoding of instructions makes it difficult to design a pipelined integer unit that is both efficient and easy to implement."}
{"question": "Let k >= 2. Let L be the set of strings in {0, 1}^* such that x \\in L if and only if the number of 0's in x is divisible by k and the number of 1's in x is odd. The minimum number of states in a deterministic finite automaton (DFA) that recognizes L is", "choices": [{"label": "A", "text": "k + 2"}, {"label": "B", "text": "2k"}, {"label": "C", "text": "k log k"}, {"label": "D", "text": "k^2"}], "answerKey": "B", "model_answer": "SOLUTION: A DFA with k states can recognize L if and only if it has a transition for every symbol in {0, 1} and a state for every string in L.\nEvery string in L has either k 0's and k-1 1's or k-1 0's and k 1's. So, the DFA must have two states, one with k 0's and k-1 1's and the other with k-1 0's and k 1's.\nThe DFA must also have a transition for every symbol. There are two symbols: 0 and 1. So, the DFA must have two transitions, one from each state to the other state.\nThere are k+1 symbols in {0, 1}. So, the DFA must have k+2 states.\nThis counts the number of states in the DFA. So, the minimum number of states in a DFA that recognizes L is k + 2."}
{"question": "Let G = (V, E) be a finite directed acyclic graph with |E| > 0. Which of the following must be true?\nI. G has a vertex with no incoming edge.\nII. G has a vertex with no outgoing edge.\nIII. G has an isolated vertex, that is, one with neither an incoming edge nor an outgoing edge.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "D", "model_answer": "SOLUTION: A finite directed acyclic graph has exactly one starting vertex. That is, there is a vertex with no incoming edge.\nG has a vertex with no incoming edge.\nSince G is a finite directed acyclic graph, it has a starting vertex. So, G has a vertex with no incoming edge."}
{"question": "Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v. Let (u, v) be an edge in G that is not in T, such that pre(u) < pre(v). Which of the following statements about u and v must be true?\nI. post(u) < post(v)\nII. u is an ancestor of v in T.\nIII. If w is the lowest common ancestor of u and v in T, then w = u.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": ""}
{"question": "In systems with support for automatic memory management, a garbage collector typically has the responsibility for reclaiming allocated memory objects whose contents cannot affect any future legal computation. Such objects are identified by determining that they cannot be reached from a root set. Which of the following is NOT part of the root set in a typical garbage collector?", "choices": [{"label": "A", "text": "Actual parameters of the active procedures"}, {"label": "B", "text": "Dynamically allocated objects on the heap"}, {"label": "C", "text": "Global variables of the program"}, {"label": "D", "text": "Local variables on the call stack"}], "answerKey": "B", "model_answer": "SOLUTION: A garbage collector reclaims memory that is no longer needed. Memory that is still needed may contain information that is relevant to future computations. This information is called reachable. Memory that is not needed and is not reachable is garbage.\nTo identify garbage, a garbage collector typically follows the pointers in the object graph to find all the objects that can affect future computations. These objects are part of the root set. The global variables of the program, the dynamically allocated objects on the heap, and the local variables on the call stack are not part of the root set. Actual parameters of the active procedures are also not part of the root set."}
{"question": "In the Internet Protocol (IP) suite of protocols, which of the following best describes the purpose of the Address Resolution Protocol?", "choices": [{"label": "A", "text": "To translate Web addresses to host names"}, {"label": "B", "text": "To determine the IP address of a given host name"}, {"label": "C", "text": "To determine the hardware address of a given host name"}, {"label": "D", "text": "To determine the hardware address of a given IP address"}], "answerKey": "D", "model_answer": "SOLUTION: The Address Resolution Protocol (ARP) is responsible for determining the hardware address of a given host name. When a device wants to send a message to another device, it needs to know the hardware address of the destination device. ARP is used to find the hardware address."}
{"question": "Which of the following language features requires that stack-based storage allocation be used rather than static allocation?", "choices": [{"label": "A", "text": "Recursive procedures"}, {"label": "B", "text": "Arbitrary goto's"}, {"label": "C", "text": "Two-dimensional arrays"}, {"label": "D", "text": "Integer-valued functions"}], "answerKey": "A", "model_answer": "LECTURE: Two-dimensional arrays are not required to use stack-based storage allocation.\nA two-dimensional array is a type of data structure that stores multiple values of a single data type. Unlike one-dimensional arrays, which have a single \"rank\" or level, a two-dimensional array has two \"ranks,\" or levels.\nArbitrary goto's are not required to use stack-based storage allocation.\nAn arbitrary goto is a goto statement that can jump to any part of a program. Goto statements are generally considered a bad programming practice, because they make it hard to follow the flow of a program.\nRecursive procedures are required to use stack-based storage allocation.\nA recursive procedure is a procedure that calls itself directly or indirectly. Recursive procedures can be designed to use either stack-based storage allocation or static allocation, but they require stack-based storage allocation to function correctly.\nInteger-valued functions are not required to use stack-based storage allocation.\nAn integer-valued function is a function that returns an integer. Integer-valued functions can be designed to use either stack-based storage allocation or static allocation, but they require stack-based storage allocation to function correctly."}
{"question": "Which of the following is not a sentence that is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z?", "choices": [{"label": "A", "text": "xyz"}, {"label": "B", "text": "xy"}, {"label": "C", "text": "xxzy"}, {"label": "D", "text": "xxxxy"}], "answerKey": "A", "model_answer": ""}
{"question": "Let T (n) be defined by T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1. Which of the following represents the order of growth of T(n) as a function of n?", "choices": [{"label": "A", "text": "\u0398(n)"}, {"label": "B", "text": "\u0398(n log n)"}, {"label": "C", "text": "\u0398(n^2)"}, {"label": "D", "text": "\u0398(n^2 log n)"}], "answerKey": "C", "model_answer": "LECTURE: The order of growth of a function is a measure of its sensitivity to changes in the input value. The order of growth represents the rate at which the function grows as the input value grows.\nSome common orders of growth are:\no o\nThese orders of growth are reduced forms. They do not include multiplicative constants, and they are written in terms of the input value n.\nFor example, consider the function f(n) = n^2. The order of growth of this function is \u03a9(n^2), which is the same as \u0398(n^2).\nAs a function grows, the order of its growth will stay the same, unless its multiplicative constant changes.\nFor example, consider the function g(n) = n^2 log n. The order of growth of this function is \u03a9(n^2 log n), which is different from \u03a9(n^2).\nThe function g(n) grows faster than n^2, but slower than n^2 log n.\nSOLUTION: To describe the order of growth of T(n) as a function of n, consider the definition of T(n).\nT(n) is defined in terms of T(n-1). So, T(n) grows faster than T(n-1).\nBut T(n-1) is defined in terms of T(n-2). So, T(n-1) grows faster than T(n-2).\nAnd T(n-2) is defined in terms of T(n-3). So, T(n-2) grows faster than T(n-3).\nIn general, T(n) grows faster than T(n-2), which grows faster than T(n-3), and so on.\nThis shows that T(n) has a polynomial order of growth.\nSince T(n) grows faster than any constant multiple of n, the order of growth of T(n) is \u0398(n^2)."}
{"question": "Which of the following problems is (are) decidable?\nI. Given a (finite) string w, is w a prefix of the decimal expansion of \u03c0?\nII. Given a program and an input, is the program\u2019s output the decimal expansion of \u03c0?\nIII. Given a program that takes as input a prefix of the decimal expansion of \u03c0, is the program\u2019s output always the same for every prefix?", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "SOLUTION: II. A program that does nothing but check if a given string is a prefix of a decimal expansion of \u03c0 can determine whether that string is a prefix of the decimal expansion of \u03c0.\nIII. Once a program has been written to decide a problem, you can run that program on any input to get the answer to that problem. So, the problem of whether a program's output is the decimal expansion of \u03c0 is decideable.\nI. To decide this problem, you would need to write a program to check if a given string is a prefix of the decimal expansion of \u03c0. But that would require you to write a program to compute the decimal expansion of \u03c0, which is undecidable."}
{"question": "Which of the following statements about circuits is (are) true?\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nIII. Both sequential and combinational circuits must be controlled by an external clock.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "SOLUTION: A combinational circuit may have feedback. A sequential circuit does not have a \"memoryless\" property. Both sequential and combinational circuits must be controlled by an external clock."}
{"question": "Two single-user workstations are attached to the same local area network. On one of these workstations, file pages are accessed over the network from a file server; the average access time per page is 0.1 second. On the other of these workstations, file pages are accessed from a local disk; the average access time per page is 0.05 second. A particular compilation requires 30 seconds of computation and 200 file page accesses. What is the ratio of the total time required by this compilation if run on the diskless (file server) workstation to the total time required if run on the workstation with the local disk, if it is assumed that computation is not overlapped with file access?", "choices": [{"label": "A", "text": "1/1"}, {"label": "B", "text": "5/4"}, {"label": "C", "text": "5/3"}, {"label": "D", "text": "10/5"}], "answerKey": "B", "model_answer": ""}
{"question": "Assume that a debugger places a breakpoint at a load instruction at virtual address 0x77E81234 (hexadecimal notation) in a debugged process P. If the text segment of P begins at 0x77E80000 in P\u2019s virtual address space and if the debugger has mapped this same text segment at 0x01000000 in its virtual address space, which of the following is the virtual address used by the debugger in its WRITE operation, along with a description of how the debugger has mapped the virtual memory page containing this address?", "choices": [{"label": "A", "text": "0x01001234; page mapped with READ/WRITE access"}, {"label": "B", "text": "0x01001234; page mapped with COPY-ON-WRITE access"}, {"label": "C", "text": "0x76E81234; page mapped with READ/WRITE access"}, {"label": "D", "text": "0x76E81234; page mapped with COPY-ON-WRITE access"}], "answerKey": "A", "model_answer": "LECTURE: A process's virtual memory is divided into fixed-size pages. A page is a set of bytes, and the size of a page depends on the process's page size. The process's page size is typically the same as the page size for the virtual memory management system.\nWhen a process starts, the pages in its text segment are mapped to the process's virtual address space. These pages can be mapped to virtual addresses in a variety of ways. One way is to use the copy-on-write technique. When a page is mapped using the copy-on-write technique, the page is not copied to the process's virtual address space until the page is written to. At that time, a copy of the page is made and used to update the original page.\nAnother way to map pages is to use the read-write technique. When a page is mapped using the read-write technique, the page is copied to the process's virtual address space when it is first mapped. Later, when the page is written to, the updated page is used.\nThe read-only technique is similar to the read-write technique, except that the page is not copied to the process's virtual address space when it is first mapped. Instead, the debugger can use the text segment's copy of the page.\nSOLUTION: The text segment of P begins at 0x77E80000 in P's virtual address space. The debugger has mapped this same text segment at 0x01000000 in its virtual address space. To figure out the virtual address used by the debugger in its WRITE operation, you need to determine which pages the debugger mapped with READ/WRITE access and which pages it mapped with COPY-ON-WRITE access.\nThe page containing the virtual address 0x77E81234 is mapped with READ/WRITE access. This page is not the page that contains the virtual address 0x76E81234. So, the debugger did not use a page mapped with COPY-ON-WRITE access for its WRITE operation.\nThe page containing the virtual address 0x76E81234 is mapped with COPY-ON-WRITE access. This page is the page that contains the virtual address 0x77E81234. So, the debugger used a page mapped with COPY-ON-WRITE access for its WRITE operation."}
{"question": "Which of the following considerations applies (apply) to choosing the page size in a paging system?\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "SOLUTION: Page tables are used to map virtual addresses to physical addresses. Larger pages lead to smaller page tables. So, smaller pages have an advantage in this respect.\nFragmentation occurs when a file is divided into multiple pieces, and each piece is stored in a separate physical location. Smaller pages can result in less waste due to internal fragmentation. So, smaller pages have an advantage in this respect.\nThe access time for a disk is determined by the distance of the disk from the center of the disk and the number of disk surfaces that the read/write head has to traverse. Longer pages can be used advantageously because the head has to traverse fewer surfaces when reading a larger page."}
{"question": "Two processors, M-5 and M-7, implement the same instruction set. Processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. Processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds. Which of the following is (are) true?\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline.\nII. The latency of a single instruction is shorter on M-7\u2019s pipeline than on M-5\u2019s pipeline.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III"}, {"label": "D", "text": "II and III"}], "answerKey": "A", "model_answer": "LECTURE: Pipelining is a technique that allows multiple instructions to be executed in parallel. Pipelining a processor means that the processor has multiple stages, and each stage can execute a different part of an instruction.\nWhen a processor is pipelined, it can start executing the next instruction before the current instruction has finished. If a pipeline has N stages, it can execute N instructions at the same time.\nA latency of a pipeline is a time it takes for an instruction to go through the pipeline. A lower latency means that an instruction starts and finishes more quickly.\nA processor's maximum throughput is a rate at which a processor can execute instructions. It is a function of the processor's clock speed and the number of cycles per instruction.\nFor a processor to have a better maximum throughput, it does not necessarily mean that the processor must have a shorter latency. A processor with a shorter latency may not necessarily have a better maximum throughput.\nA processor with a shorter latency does not always mean that programs will run faster on that processor. The difference in latency is one factor that affects the speed of a processor, but it is not the only factor.\nThe number of stages in a pipeline and the clock speed of a processor are both factors that affect a processor's maximum throughput.\nAn processor with a higher clock speed and more stages in its pipeline will have a better maximum throughput.\nSo, for a processor to have a better maximum throughput, it does not necessarily mean that the processor must have a shorter latency. It means that the processor must have a higher clock speed and more stages in its pipeline."}
{"question": "Which of the following pairs of 8-bit, two's-complement numbers will result in overflow when the members of the pairs are added?", "choices": [{"label": "A", "text": "11111111, 00000001"}, {"label": "B", "text": "00000001, 10000000"}, {"label": "C", "text": "11111111, 10000001"}, {"label": "D", "text": "10000001, 10101010"}], "answerKey": "D", "model_answer": ""}
{"question": "Two computers communicate with each other by sending data packets across a local area network. The size of these packets is 1,000 bytes. The network has the capacity to carry 1,000 packets per second. The CPU time required to execute the network protocol to send one packet is 10 milliseconds. The maximum rate at which one computer can send data to another is approximately", "choices": [{"label": "A", "text": "10,000 bytes/second"}, {"label": "B", "text": "25,000 bytes/ second"}, {"label": "C", "text": "100,000 bytes/ second"}, {"label": "D", "text": "500,000 bytes/ second"}], "answerKey": "C", "model_answer": "SOLUTION: The maximum rate at which one computer can send data to another is determined by adding the network capacity to the CPU time.\n1,000 packets per second \u00d7 1,000 bytes per packet = 1,000,000 bytes per second\n10 milliseconds per packet\n1,000,000 bytes per second / 10 milliseconds per packet = 100,000 bytes per second"}
{"question": "Consider the following grammar.\nS \u2192 ( S )\nS \u2192 x\nWhich of the following statements is (are) true?\nI. The grammar is ambiguous.\nII. The grammar is suitable for top-down parsing.\nIII. The grammar is suitable for bottom-up parsing.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "SOLUTION: This grammar is ambiguous.\nIt has two possibilities:\nS \u2192 S\nS \u2192 x\nSo, the grammar is ambiguous."}
{"question": "Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT:", "choices": [{"label": "A", "text": "Counting distinct values: Given a set of n keys, determine the number of distinct key values."}, {"label": "B", "text": "Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary."}, {"label": "C", "text": "Range search: Given values a and b, find all the records whose key value is in the range a, b."}, {"label": "D", "text": "Symbol table lookup: Given a program identifier, find its type and address."}], "answerKey": "C", "model_answer": "SOLUTION: Counting distinct values is a problem whose efficiency is independent of the data's distribution. Whether the data is uniformly distributed or not, the hash function will map all values to the same place in the table, and the counting process will require a time proportional to the number of keys.\nDynamic dictionary supports operations of insert, delete, and search in a dictionary. The time complexity of these operations is proportional to 1, which is independent of the data's distribution.\nRange search is a problem that can be solved using a hash table. The average-case time complexity of range search is proportional to 1, which is independent of the data's distribution.\nSymbol table lookup is a problem that can be solved using a hash table. The average-case time complexity of symbol table lookup is proportional to 1, which is independent of the data's distribution."}
{"question": "Let A be a finite set with m elements, and let B be a finite set with n elements. The number of distinct functions mapping A into B is", "choices": [{"label": "A", "text": "n^m"}, {"label": "B", "text": "n!/(n - m)!"}, {"label": "C", "text": "n!"}, {"label": "D", "text": "n!/(m!(n - m)!)"}], "answerKey": "A", "model_answer": "SOLUTION: Let f(x) be any function from A to B. For each value in A, f(x) takes on a unique value in B. So, the number of distinct functions from A into B is equal to the number of ways that B can be occupied by the elements of A.\nB has n elements. So, the number of ways that B can be occupied by the elements of A is equal to the number of ways that n things can be ordered. This number is given by the factorial function, which is defined for nonnegative integers n as follows:\nn! = 1 \u00b7 2 \u00b7 3 \u00b7 ... \u00b7 n\nFor any positive integer n, n! is equal to the number of ways that n things can be ordered.\nSo, the number of distinct functions from A into B is equal to the number of ways that B can be occupied by the elements of A. This number is equal to n!/(n - m)!."}
{"question": "To compute the matrix product M_1M_2, where M_1 has p rows and q columns and where M_2 has q rows and r columns, takes time proportional to pqr, and the result is a matrix of p rows and r columns. Consider the product of three matrices N_1N_2N_3 that have, respectively, w rows and x columns, x rows and y columns, and y rows and z columns. Under what condition will it take less time to compute the product as (N_1N_2)N_3 (i.e., multiply the first two matrices first) than to compute it as N_1(N_2 N_3)?", "choices": [{"label": "A", "text": "There is no such condition; i.e., they will always take the same time."}, {"label": "B", "text": "1/x + 1/z < 1/w + 1/y"}, {"label": "C", "text": "x > y"}, {"label": "D", "text": "1/w + 1/x < 1/y + 1/z"}], "answerKey": "B", "model_answer": "SOLUTION: The first two matrices have x rows and y columns, and the last matrix has y rows and z columns. So, the product of the first two matrices has x rows and z columns.\nThere is a tradeoff between the number of operations and the number of non-zero elements in the matrix. Matrix multiplication involves yz non-zero elements. Multiplying the first two matrices first involves yz non-zero elements, and the last matrix has z non-zero elements. So, in this case, multiplying the first two matrices first will take less time."}
{"question": "The hit ratio of a cache memory is the percentage of accesses (reads and writes) for which data are found in the cache. Write-through is a policy whereby every write operation updates main memory. Write-back is a policy whereby a write operation to a line found in the cache does not affect main memory until the line is evicted from the cache. Write-allocation is a policy whereby a cache line is allocated and loaded on a write-miss. If it is assumed that write-allocation is always used, which of the following is true?", "choices": [{"label": "A", "text": "Write-back usually results in a better hit ratio than write-through."}, {"label": "B", "text": "Write-through usually results in a better hit ratio than write-back."}, {"label": "C", "text": "The percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through."}, {"label": "D", "text": "The percentage of write operations resulting in a main memory operation will never be larger for writethrough than for write-back."}], "answerKey": "C", "model_answer": "SOLUTION: Write-back and write-through can affect the hit ratio. The hit ratio is affected by the number of write operations that result in a main memory operation.\nWrite-back can increase the hit ratio. This is because a write-back policy does not update main memory until the line is evicted from the cache. So, a write-back policy can keep a line in the cache for a longer time.\nA longer time in the cache can increase the hit ratio. The hit ratio is a measure of the effectiveness of the cache. A higher hit ratio means that the cache is effective.\nA write-back policy can also decrease the hit ratio. This is because a write-back policy can put a written-to line in the cache, even if it has not been accessed for a long time.\nA write-allocation policy can increase the hit ratio. This is because a write-allocation policy loads a cache line on a write-miss. So, a write-allocation policy can keep a line in the cache, even if it is not accessed for a long time.\nThe percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through. This is because a write-back policy updates main memory on a write-miss, just like a write-through policy."}
{"question": "A particular disk unit uses a bit string to record the occupancy or vacancy of its tracks, with O denoting vacant and 1 denoting occupied. A 32-bit segment of this string has the hexadecimal value D4FE2003. The percentage of occupied tracks for the corresponding part of the disk, to the nearest percent, is", "choices": [{"label": "A", "text": "12%"}, {"label": "B", "text": "25%"}, {"label": "C", "text": "38%"}, {"label": "D", "text": "44%"}], "answerKey": "D", "model_answer": "LECTURE: A bit string is a sequence of bits. A bit is a binary digit, which means it has two possible values: 0 or 1.\nYou can use a bit string to record the occupancy or vacancy of a disk's tracks using the following convention:\n0: vacant track\n1: occupied track\nThe hexadecimal value of a 32-bit string is a sequence of 4 hexadecimal digits. This value can be converted to a percentage of occupied tracks as follows:\nFirst, divide the value by 16 and compare the result to 32. The largest value that can be represented by 32 bits is 32, so if the result of the division is greater than or equal to 32, then all of the tracks are occupied.\nIf the result of the division is less than 32, then the percentage of occupied tracks is 100 times the result of the division divided by 32. To express the result as a percentage, move the decimal point to the left 2 places.\nSo, the percentage of occupied tracks for the corresponding part of the disk is:\n100 \u00d7 (D4 / 16) / 32\n100 \u00d7 4 / 32\n= 12.5%\n= 12%"}
{"question": "An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. Which of the following undirected graphs must have an Euler circuit?\nI. A complete graph with 12 vertices\nII. A complete graph with 13 vertices\nIII. A tree with 13 vertices", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "B", "model_answer": ""}
{"question": "Which of the following characteristics of a programming language is best specified using a context-free grammar?", "choices": [{"label": "A", "text": "Identifier length"}, {"label": "B", "text": "Maximum level of nesting"}, {"label": "C", "text": "Operator precedence"}, {"label": "D", "text": "Type compatibility"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following statements about datagrams sent by a node in a network using IPv4 protocol is (are) true?\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nIII. Datagrams are reassembled only at the destination.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "SOLUTION: I. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nA datagram's source must add a header to the data before sending it. The header contains the source's IP address and the datagram's length.\nSo, the size of a datagram at the source is the length of the data + the length of the header.\nThe header's size is the same for all datagrams. So, the size of a datagram at the source is the same as its size at any other point in the network.\nThe size of a datagram at the source is the size of the datagram when it leaves the source.\nSo, a datagram at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nA datagram may be too large to fit in a single packet on a link. So, it may be broken into fragments, with each fragment sent in a separate packet.\nAll fragments of a datagram are sent to the same destination. The destination reassembles the fragments to get the original datagram.\nIII. Datagrams are reassembled only at the destination.\nWhen a datagram is sent, it is broken into fragments. Each fragment is sent in a separate packet.\nThe destination reassembles the fragments to get the original datagram."}
{"question": "A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. Which of the following job-scheduling policies is starvation-free?", "choices": [{"label": "A", "text": "Round-robin"}, {"label": "B", "text": "Priority queuing"}, {"label": "C", "text": "Shortest job first"}, {"label": "D", "text": "Youngest job first"}], "answerKey": "A", "model_answer": "LECTURE: A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service.\nService time is a measure of how long it takes to complete a job. Each of the following policies has a service time that is guaranteed to be finite:\nRound-robin: The next job to be executed is the one that has been waiting the longest. This policy has a service time of one.\nPriority queuing: Jobs are served in order of priority. The priority of a job is a measure of how important the job is. This policy has a service time that is equal to the maximum priority of any job in the queue.\nShortest job first: The next job to be executed is the shortest job in the queue. This policy has a service time of one.\nYoungest job first: The next job to be executed is the youngest job in the queue. This policy has a service time of one.\nIf a job-scheduling policy is starvation-free, then it is guaranteed that no job will wait indefinitely for service. This means that the service time of the policy is finite. So, the only policies that are starvation-free are Round-robin, Shortest job first, and Youngest job first.\nPriority queuing is not starvation-free. A job with a high priority may never be served if the only jobs in the queue have a higher priority."}
{"question": "Of the following, which gives the best upper bound for the value of f(N) where f is a solution to the recurrence f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0?", "choices": [{"label": "A", "text": "O(log N)"}, {"label": "B", "text": "O(N log N)"}, {"label": "C", "text": "O(log N) + 0(1)"}, {"label": "D", "text": "O((log N)^2)"}], "answerKey": "D", "model_answer": "SOLUTION: The goal is to find an upper bound for the value of f(N). An upper bound for f(N) can be found by looking at the value of f(log N) since f(2N + 1) = f(2N) = f(N) + log N.\nAs N increases, log N increases, but f(log N) is a constant. So, f(N) is a function of log N and is therefore upper-bounded by a constant times log N."}
{"question": "Company X shipped 5 computer chips, 1 of which was defective, and Company Y shipped 4 computer chips, 2 of which were defective. One computer chip is to be chosen uniformly at random from the 9 chips shipped by the companies. If the chosen chip is found to be defective, what is the probability that the chip came from Company Y?", "choices": [{"label": "A", "text": "2 / 9"}, {"label": "B", "text": "4 / 9"}, {"label": "C", "text": "1 / 2"}, {"label": "D", "text": "2 / 3"}], "answerKey": "D", "model_answer": "SOLUTION: The probability that the chosen chip is from Company Y is given by the following fraction:\nnumber of defective chips shipped by Company Y / number of chips shipped by Company Y.\nThis fraction is 2 / 4, which is equal to 1 / 2.\nSo, the probability that the chosen chip is from Company Y is 1 / 2."}
{"question": "Which of the following problems can be solved by a standard greedy algorithm?\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights\nII. Finding a maximum clique in an undirected graph\nIII. Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "SOLUTION: A standard greedy algorithm can solve the following problems:\nFinding a minimum spanning tree in an undirected graph with positive-integer edge weights.\nFinding a maximum clique in an undirected graph.\nFinding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities.\nThese three problems can be solved by a standard greedy algorithm.\nA standard greedy algorithm can be used to find the minimum spanning tree by selecting the next edge to add to the tree that connects the two nodes with the smallest weight. This algorithm will always choose the minimum-weight edge to add to the tree.\nA standard greedy algorithm can be used to find the maximum clique by selecting the next node to add to the clique that has the largest degree. This algorithm will always choose the node with the largest degree.\nA standard greedy algorithm can be used to find the maximum flow by selecting the next edge to use as a cut to increase the maximum flow. This algorithm will always choose the edge with the smallest weight."}
{"question": "A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined. Which of the following is (are) correct?\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "SOLUTION: A hash table is a data structure that maps keys to values. In this program, the hash table maps words to booleans that indicate whether the word was in the dictionary.\nWhen the program checks the spelling of a word in a document, it applies the hash function to the word. This produces a value that is used to determine the appropriate entry in the hash table. If the entry is set to true, the word was in the dictionary. If the entry is set to false, the word was not in the dictionary.\nSo, true means the word was in the dictionary.\nAnd false means the word was not in the dictionary.\nThe size of the hash table does not affect whether a word was in the dictionary. So, III is incorrect.\nThe size of the hash table should increase with the number of words in the dictionary, not with the document size. So, II is incorrect.\nThe size of the hash table should increase with the number of words in the dictionary. So, III is incorrect.\nThe size of the hash table should increase with the number of words in the dictionary. So, III is incorrect."}
{"question": "One approach to handling fuzzy logic data might be to design a computer using ternary (base-3) logic so that data could be stored as \u201ctrue,\u201d \u201cfalse,\u201d and \u201cunknown.\u201d If each ternary logic element is called a flit, how many flits are required to represent at least 256 different values?", "choices": [{"label": "A", "text": "4"}, {"label": "B", "text": "5"}, {"label": "C", "text": "6"}, {"label": "D", "text": "7"}], "answerKey": "C", "model_answer": ""}
{"question": "Local caching of files is common in distributed file systems, but it has the disadvantage that", "choices": [{"label": "A", "text": "Temporary inconsistencies among views of a file by different machines can result"}, {"label": "B", "text": "The file system is likely to be corrupted when a computer crashes"}, {"label": "C", "text": "A much higher amount of network traffic results"}, {"label": "D", "text": "Caching makes file migration impossible"}], "answerKey": "A", "model_answer": "SOLUTION: Temporary inconsistencies among views of a file by different machines can result from local caching of files. This means that if two or more machines have different versions of the same file, the versions may differ from each other. This can happen if one machine is caching a file while another machine is modifying the file. In this case, the cached copy of the file will not reflect the changes made by the other machine.\nThe file system is likely to be corrupted when a computer crashes. This means that the file system may become damaged or may lose data in the event of a computer crash. This is a disadvantage of local caching of files.\nA much higher amount of network traffic results from local caching of files. This is because caching can reduce the number of requests for files that need to be retrieved from the main file server. However, this can also result in more traffic on the network when machines request files that are not in their caches.\nCaching makes file migration impossible. This means that if a file is cached, it cannot be moved to a different computer without first being retrieved from the cache."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-through policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2048"}], "answerKey": "C", "model_answer": "SOLUTION: With a direct-mapped cache, the cache blocks are associated with addresses in the address space. The cache blocks are not associated with the contents of the addresses.\nSo, the first byte of each array element is not stored in the cache. When the loop starts, the first byte of each array element is in memory.\nDuring the loop, each array element is accessed. For each access, the cache is updated if it is a write-through cache.\nThe first byte of each array element is not in the cache. So, when the loop writes to these bytes, the changes are written to memory.\nThe second byte of each array element is in the cache. So, when the loop writes to these bytes, the changes are written to the cache, not to memory.\nThe cache has a write-through policy. So, the changes are written to memory.\nThe cache has a 2K-byte size. So, each cache block is 8 bytes.\nThere are 512 elements in the array. So, the total number of bytes in the array is 512 \\* 4 = 2048 bytes.\nThe loop writes to 256 bytes. The first byte of each of the 256 elements is written to. The remaining 2048 - 256 = 1792 bytes are not changed."}
{"question": "At time 0, five jobs are available for execution on a single processor, with service times of 25, 15, 5, 3, and 2 time units. Which of the following is the minimum value of the average completion time of these jobs?", "choices": [{"label": "A", "text": "50"}, {"label": "B", "text": "208/5"}, {"label": "C", "text": "92/5"}, {"label": "D", "text": "10"}], "answerKey": "C", "model_answer": "SOLUTION: The average completion time of the jobs is:\n(25 + 15 + 5 + 3 + 2) / 5 = 208 / 5 = 41.6\nRounding up, the minimum value of the average completion time is 50."}
{"question": "Let G = (V, E) be a connected, undirected graph, and let a and b be two distinct vertices in V. Let P_1 be the problem of finding a shortest simple path between a and b, and let P_2 be the problem of finding a longest simple path between a and b. Which of the following statements about P_1 and P_2 is true?", "choices": [{"label": "A", "text": "Both P_1 and P_2 can be solved in polynomial time."}, {"label": "B", "text": "P_1 can be solved in polynomial time but P_2 is not known to be solvable in polynomial time."}, {"label": "C", "text": "P_1 is not known to be solvable in polynomial time but P_2 can be solved in polynomial time."}, {"label": "D", "text": "It is not known whether either P_1 or P_2 can be solved in polynomial time."}], "answerKey": "B", "model_answer": "LECTURE: A graph is a collection of vertices and edges. A simple path is a path that does not contain any edges that are not part of the graph. A longest path is a path that is not shorter than any other path from the starting vertex to the ending vertex.\nGraphs that are connected have a path that connects all vertices in the graph. An undirected graph is a graph that does not have directions for the edges. So, in an undirected graph, there is a path between any two vertices.\nSOLUTION: The problem of finding a shortest simple path between two vertices has been proven to be solvable in polynomial time. So, P_1 can be solved in polynomial time.\nFor a graph with n vertices, there are n-1 edges. So, the problem of finding a longest path can be solved in polynomial time."}
{"question": "A major advantage of direct mapping of a cache is its simplicity. The main disadvantage of this organization is that", "choices": [{"label": "A", "text": "it does not allow simultaneous access to the intended data and its tag"}, {"label": "B", "text": "it is more expensive than other types of cache organizations"}, {"label": "C", "text": "the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache"}, {"label": "D", "text": "its access time is greater than that of other cache organizations"}], "answerKey": "C", "model_answer": "SOLUTION: The major advantage of direct mapping is its simplicity. The main disadvantage is that it does not allow simultaneous access to the intended data and its tag. Since each block of data in the cache is mapped to a unique location, each block is stored in a different frame. This means that to find a block in the cache, the tag for that block must be looked up. This can add an extra step to the access time."}
{"question": "Let M be a single-tape, deterministic Turing machine with tape alphabet {blank,0,1}, and let C denote the (possibly infinite) computation of M starting with a blank tape. The input to each problem below is M, together with a positive integer n. Which of the following problems is (are) decidable?\nI. The computation C lasts for at least n steps.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nIII. M scans at least n distinct tape squares during the computation C.", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "D", "model_answer": "SOLUTION: II. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nThe proof is by contradiction. Assume that III is not decidable. Then, M cannot scan at least n distinct tape squares during the computation C. So, the computation C lasts for at most n-1 steps. But then, M does not print a 1 at any point after the nth step. This shows that II is decidable."}
{"question": "A 3-way, set-associative cache is", "choices": [{"label": "A", "text": "one in which each main memory word can be stored at any of 3 cache locations"}, {"label": "B", "text": "effective only if 3 or fewer processes are running alternately on the processor"}, {"label": "C", "text": "possible only with write-back"}, {"label": "D", "text": "faster to access than a direct-mapped cache"}], "answerKey": "A", "model_answer": "SOLUTION: A 3-way, set-associative cache is one in which each main memory word can be stored at any of 3 cache locations. This type of cache is called set-associative because each cache location is associated with a set of main memory addresses. All the main memory words that are located in the same set can be stored in any of the cache locations in the set.\nA 3-way cache has 3 ways, or subsets of the cache. Each way has its own set of cache lines. Each cache line in a way is associated with a set of main memory addresses.\nA set-associative cache is effective only if 3 or fewer processes are running alternately on the processor. This is because each cache location is associated with a set of main memory addresses. If more than 3 processes are running on the processor, some of the cache locations will be associated with main memory addresses that are not in the cache.\nA set-associative cache is possible only with write-back. This is because, in a write-back cache, the updated data is written back to main memory before it is replaced in the cache. This ensures that the main memory and the cache have the same data, which is necessary for a set-associative cache.\nA direct-mapped cache is a type of cache in which each cache line is associated with a set of main memory addresses. Each main memory address can be stored in one cache line in the set. A direct-mapped cache is faster to access than a set-associative cache. This is because each main memory address can be stored in one cache line in a direct-mapped cache. In a set-associative cache, each main memory address may be stored in any of several cache lines."}
{"question": "Consider an object-oriented language in which all entities are objects. Two relationships arise: (1) the instance relationship, between an object and the class of which that object is a member, and (2) the subclass relationship, between a class and the superclass from which that class inherits properties. In such a language, when a message is sent to an object requesting execution of one of its methods (procedures), the method is located by following", "choices": [{"label": "A", "text": "one instance link and then zero or more subclass links"}, {"label": "B", "text": "one or more instance links and then one or more subclass links"}, {"label": "C", "text": "one or more instance links"}, {"label": "D", "text": "one subclass link and then one or more instance links"}], "answerKey": "A", "model_answer": "SOLUTION: When a message is sent to an object requesting execution of one of its methods, the method is located by following instance links from the object to the object's class. Then, the subclass links are followed to the subclass(es) that the object's class is linked to.\nSo, the order of links is: one instance link and then zero or more subclass links."}
{"question": "In a pipelined RISC computer where all arithmetic instructions have the same CPI (cycles per instruction), which of the following actions would improve the execution time of a typical program?\nI. Increasing the clock cycle rate\nII. Disallowing any forwarding in the pipeline\nIII. Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "D", "model_answer": "LECTURE: In a pipelined RISC computer, the clock cycle rate is the rate at which the processor clock cycles. The clock cycle rate is equal to the sum of the sizes of the instruction cache and the data cache divided by the number of pipelines.\nThe CPI is a measure of the number of cycles the processor needs to execute an instruction. This CPI is equal to the size of the instruction cache divided by the size of an instruction.\nImproving the execution time of a typical program includes reducing the number of cycles the program takes to finish. Reducing the number of cycles the program takes to finish is the same as reducing the CPI.\nReducing the CPI can be done by decreasing the size of the instruction cache or the data cache. This is because the CPI is equal to the size of the instruction cache divided by the size of an instruction. So, if you decrease the size of the instruction cache or the data cache, the CPI will increase.\nHowever, the clock cycle rate is given by the formula: clock cycle rate = instruction cache size + data cache size / pipelines. So, decreasing the size of the caches will increase the clock cycle rate. This may opposite to the goal of reducing the CPI.\nSo, you should decrease the size of the instruction cache and the data cache."}
{"question": "A microcomputer used for data acquisition and control is required to digitize and process four analog input signals and to output their average continually; i.e., in real time. The time for an external analog-to-digital converter (which is triggered by a CPU instruction) to digitize one input is 12 microseconds, and only one digitization occurs at a time. Five CPU instructions, including the triggering instruction, must be executed for each signal digitized. Ten CPU instructions are executed in order to average each set of four samples and output this value. The time to convert the output from digital to analog form is to be ignored. If it is assumed that suitable data buffering is employed, then the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates, is", "choices": [{"label": "A", "text": "0.8 microseconds"}, {"label": "B", "text": "1.2 microseconds"}, {"label": "C", "text": "1.6 microseconds"}, {"label": "D", "text": "2.4 microseconds"}], "answerKey": "C", "model_answer": "SOLUTION: The microcomputer processes each input signal one at a time. Each input takes 12 microseconds to digitize. Five instructions are executed for each digitization, including the triggering instruction. So, the maximum time it takes to process each input is:\n12 microseconds / input + 5 instructions / input = 17.5 microseconds / input\nThe microcomputer has to process all four inputs. So, the maximum average instruction execution time is:\n17.5 microseconds / input / 4 = 0.8 microseconds."}
{"question": "Suppose that a certain software product has a mean time between failures of 10,000 hours and has a mean time to repair of 20 hours. If the product is used by 100 customers, what is its availability?", "choices": [{"label": "A", "text": "80%"}, {"label": "B", "text": "90%"}, {"label": "C", "text": "98%"}, {"label": "D", "text": "99.80%"}], "answerKey": "D", "model_answer": "LECTURE: The availability of a product is a measure of the proportion of time that the product is expected to be operational and able to fulfill its intended function.\nThe availability of a product can be calculated as follows:\nAvailability = (Mean Time Between Failures / Mean Time to Repair)\nFor example, consider a product with a mean time between failures of 10,000 hours and a mean time to repair of 20 hours.\nAvailability = (10,000 / 20)\nAvailability = 500%\nThis means that the product is expected to be operational and able to fulfill its intended function 500% of the time.\nSOLUTION: The product is expected to be operational and able to fulfill its intended function 500% of the time. This means that the product is expected to be unavailable for use 0% of the time.\nSo, the product is available 100% of the time."}
