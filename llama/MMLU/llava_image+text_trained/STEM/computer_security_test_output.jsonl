{"question": "Which of the following styles of fuzzer is more likely to explore paths covering every line of code in the following program?", "choices": [{"label": "A", "text": "Generational"}, {"label": "B", "text": "Blackbox"}, {"label": "C", "text": "Whitebox"}, {"label": "D", "text": "Mutation-based"}], "answerKey": "C", "model_answer": "The style of fuzzing that is most likely to explore every line of code in a program is mutation-based fuzzing.\nMutation-based fuzzing involves making small changes to input data to create new, unique variations of the data that are used to test the system. This approach encourages the fuzzer to explore all possible combinations of data, which can include every line of code in the program.\nOn the other hand, blackbox fuzzing involves sending random inputs to a program and seeing how it responds. While it can still explore many lines of code, it is not as effective at discovering all possible paths through the code.\nGenerational and whitebox fuzzing involve creating or modifying data in a more targeted way, which may not lead to exploring every line of code in the program.\nTherefore, option (D) Mutation-based is the most likely choice."}
{"question": "Assume that a TLS connection has been established successfully between a client and a server. Establishing the session included checking the server certificate and executing a DiffieHelmann exchange, but the client did not provide a client certificate. Further, assume that the client and server are honest, that the client and server don\u2019t leak their keys, and that the cryptography is good. Which of the following attacks does TLS protect against?\n1. An attacker replaying bytes that a client sent earlier.\n2. An attacker impersonating the server.", "choices": [{"label": "A", "text": "True, True"}, {"label": "B", "text": "False, False"}, {"label": "C", "text": "True, False"}, {"label": "D", "text": "False, True"}], "answerKey": "A", "model_answer": "he correct answer is (D) False, True.\nTLS, or Transport Layer Security, is a protocol that provides secure communication over the internet. It is designed to protect against a variety of attacks, including replay attacks and man-in-the-middle attacks. A replay attack occurs when an attacker intercepts and re-transmits data that was previously sent by the client to the server. In this scenario, option (A) is correct, as TLS protects against this type of attack.On the other hand, an impersonation attack occurs when an attacker pretends to be a legitimate server in order to steal sensitive information or perform malicious actions. This type of attack is relatively rare and is not typically prevented by TLS. Therefore, option (C) is incorrect.Finally, option (B) is incorrect because if the client and server do not leak their keys, then an attacker cannot use a key capture attack to obtain the server's private key. This means that the connection is secure against further attacks even if the client did not provide a client certificate."}
{"question": "MIT\u2019s Kerberos KDC server has a maximum ticket lifetime of 24 hours (for most user principals). What ensures that an expired Kerberos ticket can no longer be used?", "choices": [{"label": "A", "text": "The Kerberos server (KDC) refuses to establish new connections between clients and servers for expired tickets."}, {"label": "B", "text": "When a client connects to a server, the server sets a 24-hour timer to terminate the connection, which ensures a client cannot remain connected past the ticket\u2019s maximum lifetime."}, {"label": "C", "text": "When a client connects to a server, the server compares the ticket\u2019s expiration time to the server\u2019s current clock, and refuses to authenticate the user if the ticket expiration time is in the past."}, {"label": "D", "text": "When a client connects to a server, the server sends a query to the KDC to check if the ticket is still valid with respect to the KDC\u2019s clock, and refuses to authenticate the user if the KDC reports that the ticket is expired."}], "answerKey": "C", "model_answer": ". When a client connects to a server, the server sets a 24-hour timer to terminate the connection, which ensures a client cannot remain connected past the ticket\u2019s maximum lifetime."}
{"question": "In Message Condentiality, the transmitted message must make sense to only intended", "choices": [{"label": "A", "text": "Receiver"}, {"label": "B", "text": "Sender"}, {"label": "C", "text": "Modulor"}, {"label": "D", "text": "Translator"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following is a remote Trojan?", "choices": [{"label": "A", "text": "Troya"}, {"label": "B", "text": "DaCryptic"}, {"label": "C", "text": "BankerA"}, {"label": "D", "text": "Game-Troj"}], "answerKey": "A", "model_answer": "The correct answer is (B) DaCryptic.\nA Trojan is a type of malware that is disguised as a legitimate program or app, but its true purpose is to harm the user's computer or steal their personal information. A remote Trojan is one that can be controlled remotely by the attacker, allowing them to carry out malicious activities from a distance.\nTroya is a city in Spain, and it is not a remote Trojan. BankerA is a banking Trojan, which is a type of malware that is designed to steal banking information from the user's computer. Game-Troj is not a type of Trojan, but rather a name that could be used for a game or app that is designed to be malicious. DaCryptic is a type of Trojan that is designed to hide itself from the user and the antivirus software, making it difficult to detect.\nTherefore, the correct answer is (B) DaCryptic, which is a remote Trojan that is designed to be difficult to detect."}
{"question": "______________ is a widespread app\u2019s coding mistake made by developers which could be exploited by an attacker for gaining access or malfunctioning your system.", "choices": [{"label": "A", "text": "Memory leakage"}, {"label": "B", "text": "Buffer-overrun"}, {"label": "C", "text": "Less processing power"}, {"label": "D", "text": "Inefficient programming"}], "answerKey": "B", "model_answer": "The correct answer is (B) Buffer-overrun.\nA buffer-overflow vulnerability occurs when a program tries to store more data in a buffer than it's supposed to hold. This can allow an attacker to overwrite adjacent memory locations, potentially altering the behavior of the program or allowing them to gain unauthorized access to the system. Memory leaks, inefficient programming, and poor coding practices can also lead to unexpected behavior in a program, but they are not a widespread app coding mistake that can be exploited by attackers."}
{"question": "Consider the paper Native Client: A Sandbox for Portable, Untrusted x86 Native Code by Yee et al. Ben Bitdiddle notes that NaCl uses Intel x86 segmentation to ensure that the sandboxed module does not read or write memory outside its own data area, and does not execute instructions outside its own code. Ben thinks that with these restrictions alone, executing the sandboxed module must be safe; that is, he thinks validation is not needed. Ben is wrong. Circle the types of x86 machine instructions that the validator always forbids in sandboxed code. Please ignore trampoline and springboard code.", "choices": [{"label": "A", "text": "all instructions that modify segment state"}, {"label": "B", "text": "all loads or stores to addresses that are not 0 mod 32"}, {"label": "C", "text": "all indirect loads or stores (via an address in a register or variable)"}, {"label": "D", "text": "all indirect jumps (via an address in a register or variable)"}], "answerKey": "A", "model_answer": "Choice (B) all loads or stores to addresses that are not 0 mod 32.\nThe validator in NaCl always checks the memory accesses performed by the sandboxed code to ensure that it does not read or write memory outside of its own data area. This is done by checking the memory accesses against the memory map of the sandboxed module.\nMore specifically, the validator checks whether the memory accesses are within the bounds of the data area, and whether they are aligned to the size of the data area. If a load or store operation is not aligned to the size of the data area, the validator generates an error.\nIn addition, the validator also checks whether the memory accesses are not 0 mod 32. This means that the memory accesses must not contain a remainder of 0 when divided by 32. This is because the memory accesses are further restricted to the data area, and the validator ensures that the data area is a multiple of 32 bytes in size.\nTherefore, choice (B) is the correct answer."}
{"question": "____________ is also a part of darknet that is employed for transferring files anonymously.", "choices": [{"label": "A", "text": "Freenet"}, {"label": "B", "text": "ARPANET"}, {"label": "C", "text": "Stuxnet"}, {"label": "D", "text": "Internet"}], "answerKey": "A", "model_answer": "The correct answer is (A) Freenet.\nDarknets are parts of the internet that are not indexed by search engines and require specific software to access. They are often used for illegal activities, such as drug trafficking, human trafficking, and child pornography. Freenet is a decentralized network that allows users to share files anonymously and securely. It uses peer-to-peer technology to distribute files and is designed to resist censorship, making it a popular tool for people living in countries with strict internet censorship. Freenet is also a darknet, but it is primarily used for sharing files anonymously and is not typically associated with illegal activities. ARPANET, Stuxnet, and the Internet are not darknets and are not typically used for file sharing."}
{"question": "Why apps developed in languages like C, C++ is prone to Buffer-overflow?", "choices": [{"label": "A", "text": "No string boundary checks in predefined functions"}, {"label": "B", "text": "No storage check in the external memory"}, {"label": "C", "text": "No processing power check"}, {"label": "D", "text": "No database check"}], "answerKey": "A", "model_answer": "(A) No string boundary checks in predefined functions.\n\nApps developed in languages like C and C++ are prone to buffer overflows because they often lack string boundary checks in predefined functions. A buffer is a temporary storage area in memory that can hold a fixed number of values, usually of the same type. When reading or writing data to a buffer, it is important to ensure that the data being read is not exceeding the buffer's size, as this can lead to buffer overflows. String boundaries are important because they help ensure that data is being read or written in a way that does not exceed the buffer's size. If there are no string boundary checks in predefined functions, it is possible for a programmer to unintentionally write or read past the end of the buffer, leading to a buffer overflow."}
{"question": "Man in the middle attack can endanger the security of Diffie Hellman method if two parties are not", "choices": [{"label": "A", "text": "Joined"}, {"label": "B", "text": "Authenticated"}, {"label": "C", "text": "Submitted"}, {"label": "D", "text": "Shared"}], "answerKey": "B", "model_answer": "The correct answer is (B) Authenticated.\nIn a man-in-the-middle (MITM) attack, an attacker intercepts communications between two parties who are trying to establish a secure connection using the Diffie-Hellman key exchange method. In such an attack, the attacker can impersonate one of the parties and obtain the shared secret key between them, thereby ending the security of the key exchange method.\nTo prevent this, the Diffie-Hellman method requires that the communicating parties authenticate each other by using a shared secret key that is previously established outside of the key exchange process. This ensures that only authorized parties can participate in the key exchange and prevents attackers from intercepting and impersonating them. Therefore, option (B) Authenticated is the correct answer."}
{"question": "An integer overflow occurs when", "choices": [{"label": "A", "text": "an integer expression's result \"wraps around\"; instead of creating a very large number, a very small (or negative) number ends up getting created"}, {"label": "B", "text": "an integer is used as if it was a pointer"}, {"label": "C", "text": "an integer is used to access a buffer outside of the buffer's bounds"}, {"label": "D", "text": "there is no more space to hold integers in the program"}], "answerKey": "D", "model_answer": "The correct answer is (A)."}
{"question": "Let HH be a Merkle-Damgard hash function is H:X^{\\leq L} \\to TH:X^\u2264L  \u2192T. Construct a MAC from this HH as follows: \\ \\ S(k,m) = H(k \\| m)  S(k,m)=H(k\u2225m). This mac is insecure because:", "choices": [{"label": "A", "text": "Given H(k \\| m)H(k\u2225m) anyone can compute H(w \\| k \\| m \\| \\text{PB})H(w\u2225k\u2225m\u2225PB) for any ww"}, {"label": "B", "text": "Given H(k \\| m)H(k\u2225m) anyone can compute H(k \\| m \\| w)H(k\u2225m\u2225w) for any ww"}, {"label": "C", "text": "Given H(k \\| m)H(k\u2225m) anyone can compute H(k \\| m \\| \\text{PB} \\| w)H(k\u2225m\u2225PB\u2225w) for any ww"}, {"label": "D", "text": "Anyone can compute H( k \\| m )H(k\u2225m) for any mm"}], "answerKey": "C", "model_answer": ""}
{"question": "Suppose that Alice and Bob sent confidential text messages to one another last month through an encrypted messaging system. Alice and Bob are worried that an adversary might compromise one of their computers today, while they are taking the 6.858 final exam, and would then be able to decrypt those messages. Which of the following security properties can address Alice and Bob\u2019s concern?", "choices": [{"label": "A", "text": "Authentication."}, {"label": "B", "text": "Deniability."}, {"label": "C", "text": "Forward secrecy"}, {"label": "D", "text": "Backward secrecy."}], "answerKey": "C", "model_answer": "The correct answer is (D) Backward secrecy.\nBackward secrecy, also known as \"recovery from compromise,\" ensures that an adversary who gains access to an encrypted message cannot decrypt any past messages that were exchanged between the communicating parties. This is achieved through the use of cryptographic techniques such as forward secrecy, where each session key is only used once and then discarded, and a new key is generated for each new session. If an adversary gains access to one key, they will not be able to decrypt past messages, as each message is encrypted with a unique key for that session.\nOption (A) Authentication ensures that the sender of a message is verified to be who they claim to be, but it does not prevent an adversary from decrypting past messages once they have access to a session key. Option (B) Deniability provides participants with the ability to conceal their involvement in an encrypted conversation, but it does not prevent an adversary from decrypting past messages once they have access to a session key. Option (C) Forward secrecy ensures that an adversary cannot decrypt future messages based on past keys, but it does not help in the case where an adversary already has access to past messages.\nTherefore, the correct answer is (D) Backward secrecy."}
{"question": "The AH Protocol provides source authentication and data integrity, but not", "choices": [{"label": "A", "text": "Integrity"}, {"label": "B", "text": "Privacy"}, {"label": "C", "text": "Nonrepudiation"}, {"label": "D", "text": "Both A & C"}], "answerKey": "B", "model_answer": "The correct answer is (B) Privacy, because the AH Protocol provides authentication and data integrity, which are important aspects of secure communication, but not privacy. The AH Protocol is a cryptographic protocol that provides authentication and countersignature services, which ensure that messages are authentic and authorized by the sender, but it does not provide any protection for the confidentiality of the message content. Therefore, privacy is not one of the features provided by the AH Protocol.\n\nOn the other hand, nonrepudiation is the ability to prove that a message was sent and received by the intended recipient, and it is a feature that is provided by digital signature technologies such as the Digital Signature Algorithm (DSA). Digital signatures provide nonrepudiation, which means that the sender of the message cannot deny having sent the message, and the recipient cannot deny having received the message. Therefore, nonrepudiation is not a feature provided by the AH Protocol, but it is a feature provided by digital signature technologies."}
{"question": "Which of the following is not a security exploit?", "choices": [{"label": "A", "text": "Eavesdropping"}, {"label": "B", "text": "Cross-site scripting"}, {"label": "C", "text": "Authentication"}, {"label": "D", "text": "SQL Injection"}], "answerKey": "C", "model_answer": ""}
{"question": "_______________ is the central node of 802.11 wireless operations.", "choices": [{"label": "A", "text": "WPA"}, {"label": "B", "text": "Access Point"}, {"label": "C", "text": "WAP"}, {"label": "D", "text": "Access Port"}], "answerKey": "B", "model_answer": "Access Point."}
{"question": "In MD-5 the length of the message digest is", "choices": [{"label": "A", "text": "160"}, {"label": "B", "text": "128"}, {"label": "C", "text": "64"}, {"label": "D", "text": "54"}], "answerKey": "B", "model_answer": "\u200b"}
{"question": "What is Nmap?", "choices": [{"label": "A", "text": "It is a scanner which works by injecting packets to a range of addresses, and inferring what hosts and services might be at those addresses, based on the responses"}, {"label": "B", "text": "It is a network fuzz testing tool"}, {"label": "C", "text": "It is a map of the Internet"}, {"label": "D", "text": "It is a suite of tools for scripting attacks: probe, construct, encode, inject, wait for response"}], "answerKey": "A", "model_answer": "(A) It is a scanner which works by injecting packets to a range of addresses, and inferring what hosts and services might be at those addresses, based on the responses."}
{"question": "How do you prevent SQL injection?", "choices": [{"label": "A", "text": "Escape queries"}, {"label": "B", "text": "Interrupt requests"}, {"label": "C", "text": "Merge tables"}, {"label": "D", "text": "All of the above"}], "answerKey": "A", "model_answer": "The correct answer is (D) All of the above.\n\nTo prevent SQL injection, you should use a combination of techniques, including:\n1. Input validation and sanitization to prevent malicious input from being inserted into the database.\n2. Escape queries to prevent special characters from being interpreted as SQL commands.\n3. Use prepared statements or parameterized queries to separate user input from the SQL commands.\n4. Intercept and filter incoming requests to prevent malicious input from being sent to the server.\n5. Use database authentication and authorization to restrict access to the database and prevent unauthorized users from inserting malicious data.\n6. Regularly update and maintain your database software and applications to ensure they are protected against known vulnerabilities.\nBy using a combination of these techniques, you can significantly reduce the risk of SQL injection attacks and protect your database and application."}
{"question": "What does it mean to \"be stealthy\" during a penetration test?", "choices": [{"label": "A", "text": "Performing the tests from an undisclosed location"}, {"label": "B", "text": "Using encryption during tests to make the source of attacks impossible to determine"}, {"label": "C", "text": "Performing penetration testing without the target organization knowing"}, {"label": "D", "text": "Taking care to avoid activities during a penetration test that might attract attention, e.g., by operators or IDS services"}], "answerKey": "D", "model_answer": "The correct answer is (A) Performing the tests from an undisclosed location. To be stealthy during a penetration test, it is important to avoid leaving any trace of the tests by performing them from an undisclosed location, such as a virtual machine or a rented server. This can help ensure that the test results are not traced back to the tester and that the test is not detected by the target organization."}
{"question": "Which of the following is not a transport layer vulnerability?", "choices": [{"label": "A", "text": "Mishandling of undefined, poorly defined variables"}, {"label": "B", "text": "The Vulnerability that allows \u201cfingerprinting\u201d & other enumeration of host information"}, {"label": "C", "text": "Overloading of transport-layer mechanisms"}, {"label": "D", "text": "Unauthorized network access"}], "answerKey": "D", "model_answer": "\u200b"}
{"question": "In Brumley and Boneh\u2019s paper on side-channel attacks, why does blinding prevent the timing attack from working?", "choices": [{"label": "A", "text": "Blinding prevents the server from using the CRT optimization, which is essential to the timing attack."}, {"label": "B", "text": "Blinding changes the p and q primes that are used, so an adversary cannot learn the server\u2019s true p and q values."}, {"label": "C", "text": "Blinding randomizes the ciphertext being decrypted, thus obscuring the correlation between an adversary\u2019s input and the timing differences."}, {"label": "D", "text": "Blinding adds a random amount of time to the decryption due to the multiplication and division by the blinding random value r, which obscures the timing differences used in the attack."}], "answerKey": "C", "model_answer": "(D) is the correct answer. Blinding adds a random amount of time to the decryption due to the multiplication and division by the blinding random value r, which obscures the timing differences used in the timing attack. This makes it difficult or impossible for an adversary to measure the timing differences between their input and the server's response. By randomizing the decryption process, blinding makes it difficult for an adversary to correlate the timing differences with their input, and thus prevents the timing attack from working."}
{"question": "The openSSL implementation described in \u201cRemote Timing Attacks are Practical\u201d (by Brumley and Boneh) uses the following performance optimizations: Chinese Remainder (CR), Montgomery Representation (MR), Karatsuba Multiplication (KM), and Repeated squaring and Sliding windows (RS). Which of the following options would close the timing channel attack described in the paper if you turned the listed optimizations off?\n1. RS and KM\n2. RS and MR", "choices": [{"label": "A", "text": "True, True"}, {"label": "B", "text": "False, False"}, {"label": "C", "text": "True, False"}, {"label": "D", "text": "False, True"}], "answerKey": "D", "model_answer": "se, False.\nExplanation: The paper describes a timing channel attack that can be closed by disabling either Chinese Remainder (CR), Montgomery Representation (MR), Karatsuba Multiplication (KM), or Repeated squaring and Sliding windows (RS). Therefore, if RS and MR optimizations are off, the attack cannot be closed and the vulnerability of the system will remain the same as before.\n(A) RS and KM cannot close the attack because RS optimizes the computation and KM optimizes the memory access, but both optimizations do not affect the timing channel.\n(B) RS and MR cannot close the attack because RS optimizes the computation and MR optimizes the memory access, but both optimizations do not affect the timing channel.\n(C) RS and KM can close the attack because RS optimizes the computation and KM optimizes the memory access, and both optimizations can reduce the timing channel.\n(D) MR and KM cannot close the attack because MR optimizes the memory access and KM optimizes the computation, but both optimizations do not affect the timing channel."}
{"question": "Public key encryption is advantageous over Symmetric key Cryptography because of", "choices": [{"label": "A", "text": "Speed"}, {"label": "B", "text": "Space"}, {"label": "C", "text": "Key exchange"}, {"label": "D", "text": "Key length"}], "answerKey": "C", "model_answer": "The correct answer is (D) Key length.\n\nPublic key encryption is advantageous over symmetric key cryptography because of the difference in key lengths. Public key encryption schemes, such as RSA and elliptic curve cryptography, use much larger key sizes than symmetric key schemes, such as AES. This means that the computational effort required to break the encryption is much higher for public key encryption, making it more secure. Additionally, the larger key size in public key encryption allows for more efficient encryption and decryption of large amounts of data.\nOn the other hand, symmetric key cryptography is more efficient in terms of speed because it only requires one key for both encryption and decryption. However, the key length in symmetric key schemes is typically much shorter than in public key schemes, making it easier to break the encryption with brute force."}
{"question": "The __________ was a huge marketplace of Dark Web specifically famous for selling of illegal drugs & narcotics as well as you can find a wide range of other goods for sale.", "choices": [{"label": "A", "text": "Silk Road"}, {"label": "B", "text": "Cotton Road"}, {"label": "C", "text": "Dark Road"}, {"label": "D", "text": "Drug Road"}], "answerKey": "A", "model_answer": "A) Silk Road."}
{"question": "The ______________ is categorized as an unknown segment of the Deep Web which has been purposely kept hidden & is inaccessible using standard web browsers.", "choices": [{"label": "A", "text": "Haunted web"}, {"label": "B", "text": "World Wide Web"}, {"label": "C", "text": "Dark web"}, {"label": "D", "text": "Surface web"}], "answerKey": "C", "model_answer": ""}
{"question": "What does EXE do when the STP solver times out on a constraint query for a particular path?", "choices": [{"label": "A", "text": "Assume that the query is satisfiable and continue executing the path."}, {"label": "B", "text": "Assume that the query is not satisfiable and stop executing the path"}, {"label": "C", "text": "Restart STP and retry the query, up to a limited number of retries."}, {"label": "D", "text": "Remove a subset of the constraints and retry the query."}], "answerKey": "B", "model_answer": "The correct answer is (B) Assume that the query is not satisfiable and stop executing the path.\nIf the STP solver times out on a constraint query for a particular path, it means that the solver was unable to find a feasible solution for the path within the allotted time. In this case, the path is not feasible, and it is not worth continuing to execute it. The correct action is to assume that the query is not satisfiable and stop executing the path.\nThis is because attempting to continue executing the path could lead to an even larger number of unsatisfiable queries, wasted time, and potentially incorrect results.\nIt is also worth noting that there are other possible actions that could be taken in this scenario, such as resizing the search space or trying a different search algorithm, but simply stopping execution of the path is the most straightforward solution."}
{"question": "To verify a digital signature we need the", "choices": [{"label": "A", "text": "Sender\u2019s Private key"}, {"label": "B", "text": "Sender\u2019s Public key"}, {"label": "C", "text": "Receiver\u2019s Private key"}, {"label": "D", "text": "Receiver\u2019s Public key"}], "answerKey": "B", "model_answer": "The correct answer is (A) Sender\u2019s Private key.\n\nIn digital signature verification, the receiver needs to confirm that the signature is genuine by verifying the digital signature using the sender's public key. To do this, the receiver first checks that the digital signature is valid by verifying the signature's cryptographic hash value, then uses the sender's public key to check if it matches the signature. If the public key used in the signature verification matches the sender's public key, then the signature is considered verified, and the document or message it is attached to is considered authentic."}
{"question": "Suppose you want to use fuzzing on a program to try to find memory errors; which of the following statements is true?", "choices": [{"label": "A", "text": "You should not use a grammar-based fuzzer, because its adherence to the grammar means it will not find memory errors"}, {"label": "B", "text": "Compiling the program with address sanitizer (ASAN) will make errors harder to reproduce"}, {"label": "C", "text": "Compiling the program with address sanitizer (ASAN) will make the source of a memory error easier to find"}, {"label": "D", "text": "Fuzzing doesn't find memory errors, it finds crashes and hangs"}], "answerKey": "C", "model_answer": "\u200b\n\nThe correct answer is (C) Compiling the program with address sanitizer (ASAN) will make the source of a memory error easier to find. Address sanitizer is a tool that helps to dynamically track memory access errors and provides information about where a memory access occurred. This is useful for finding memory errors because it can help to identify the source of the error, such as which variables are being accessed and which memory locations are being accessed.\n\nTherefore, the correct statement is:\n\"Compiling the program with address sanitizer (ASAN) will make the source of a memory error easier to find.\""}
{"question": "Based on the paper \u201cSoK: SSL and HTTPS: Revisiting past challenges and evaluating certificates trust model enhancements\u201d, which of the following statements are false?", "choices": [{"label": "A", "text": "Valid DV certificates provide more confidence to a user that she is connecting to the intended party than valid EV certificates."}, {"label": "B", "text": "OCSP stapling allows a server to prove to a browser that its certificate hasn\u2019t been revoked."}, {"label": "C", "text": "DANE makes it difficult for an adversary to launch a SSL stripping attack."}, {"label": "D", "text": "Server key-pinning makes it harder for an adversary to convince a CA to mint a certificate for a site and launch an MITM attack on that site."}], "answerKey": "A", "model_answer": "correct answer is: (B) OCSP stapling allows a server to prove to a browser that its certificate hasn't been revoked.\n\nExplanation:\nIn the paper \"SoK: SSL and HTTPS: Revisiting past challenges and evaluating certificates trust model enhancements,\" OCSP stapling is described as a technique that allows a server to prove to a browser that its certificate hasn't been revoked in real-time, rather than waiting for the browser to check with the certificate authority (CA). This provides a higher level of confidence to the user, as the browser can display the expired certificate instead of a warning. Option (A) is false because valid DV certificates do not provide more confidence to a user than valid EV certificates. Option (C) is true because DANE (Domain Name System-Based Public Key Infrastructure) is a protocol that makes it difficult for an adversary to launch a SSL stripping attack by allowing a user to verify the identity of a server using DNS-based credentials. Option (D) is false because server key-pinning is a method used by a server to prevent an adversary from convincing a CA to mint a certificate for a site and launch an MITM attack on that site. Instead, server key-pinning allows a server to associate its public key with a specific IP address, preventing an attacker from using a valid certificate for that IP address."}
{"question": "What tool can be used to perform SNMP enumeration?", "choices": [{"label": "A", "text": "DNSlookup"}, {"label": "B", "text": "Whois"}, {"label": "C", "text": "Nslookup"}, {"label": "D", "text": "IP Network Browser"}], "answerKey": "D", "model_answer": "The correct answer is (C) Nslookup. Nslookup is a network tool that can be used to perform SNMP (Simple Network Management Protocol) enumeration. It allows you to retrieve information about IP addresses and their associated hostnames, as well as perform other network-related tasks. SNMP enumeration is the process of discovering and identifying SNMP-managed devices on a network, which can be useful for security purposes or for managing and monitoring a network more effectively."}
{"question": "Which among them has the strongest wireless security?", "choices": [{"label": "A", "text": "WEP"}, {"label": "B", "text": "WPA"}, {"label": "C", "text": "WPA2"}, {"label": "D", "text": "WPA3"}], "answerKey": "D", "model_answer": "The answer is WPA2. WPA2 (Wireless Protection II) is the strongest wireless security protocol currently in use. It is an extension of the original WEP (Wired Equivalent Privacy) protocol and is considered more secure than WPA and WPA3. WPA2 uses the 4-way handshake to establish a secure encryption key, which is more secure than the single handshake used in WEP. It also uses the RC4 encryption algorithm and a stronger authentication method called the Extensible Authentication Protocol (EAP). Overall, WPA2 is considered the gold standard for wireless security and is the protocol recommended for most home and business networks."}
{"question": "Suppose Unix did not provide a way of passing file descriptors between processes, but still allowed inheriting file descriptors from a parent on fork and exec. What aspects of the OKWS design would break without file descriptor passing?\n1. It would be impossible for services to get a TCP connection to the client web browser.\n2. It would be impossible for okd to run as a non-root user.", "choices": [{"label": "A", "text": "True, True"}, {"label": "B", "text": "False, False"}, {"label": "C", "text": "True, False"}, {"label": "D", "text": "False, True"}], "answerKey": "C", "model_answer": "True, False.\n\nTo explain:\nChoice (A) is true because it is impossible for services to get a TCP connection to the client web browser without file descriptor passing, as they need to use the connect() system call, which relies on file descriptors to establish the connection.\nChoice (B) is false because it is still possible for okd to run as a non-root user, as it can inherit file descriptors from the parent process, which can include the necessary file descriptors for a non-root user to access files and resources.\nChoice (C) is true because it is still possible for services to get a TCP connection to the client web browser, but they would need to use the connect() system call, which relies on file descriptors to establish the connection. However, they would not be able to inherit file descriptors from the parent process, so they would need to pass the necessary file descriptors from the parent process to the child process through some other means, such as environment variables or command-line arguments.\nChoice (D) is false because it is still possible for okd to run as a non-root user, as it can inherit file descriptors from the parent process, which can include the necessary file descriptors for a non-root user to access files and resources. However, they would not be able to pass the necessary file descriptors from the parent process to the child process through some other means, such as environment variables or command-line arguments, so they would need to use a different approach to establish the connection."}
{"question": "Failed sessions allow brute-force attacks on access credentials. This type of attacks are done in which layer of the OSI model?", "choices": [{"label": "A", "text": "Physical layer"}, {"label": "B", "text": "Data-link Layer"}, {"label": "C", "text": "Session layer"}, {"label": "D", "text": "Presentation layer"}], "answerKey": "C", "model_answer": "The correct answer is (C) Session layer.\nA brute-force attack on access credentials is a type of attack that attempts to guess or crack passwords or other access credentials by trying every possible combination until the correct one is found. This type of attack is usually done at the application layer, but it can also be done at lower layers of the OSI model, such as the physical layer or the data-link layer. However, a failed session that allows brute-force attacks is most likely to occur at the session layer of the OSI model, which is responsible for managing and maintaining communication sessions between two devices.\n\nIt is important to note that this is just one possible interpretation of the question and there may be other ways to interpret the question depending on the context."}
{"question": "Which of the following is an authentication method?", "choices": [{"label": "A", "text": "Secret question"}, {"label": "B", "text": "Biometric"}, {"label": "C", "text": "SMS code"}, {"label": "D", "text": "All of the above"}], "answerKey": "D", "model_answer": ""}
{"question": "When does a buffer overflow occur, generally speaking?", "choices": [{"label": "A", "text": "when writing to a pointer that has been freed"}, {"label": "B", "text": "when copying a buffer from the stack to the heap"}, {"label": "C", "text": "when a pointer is used to access memory not allocated to it"}, {"label": "D", "text": "when the program notices a buffer has filled up, and so starts to reject requests"}], "answerKey": "C", "model_answer": "The correct answer is (A) when writing to a pointer that has been freed.\n\nA buffer overflow occurs when more data is written to a buffer than it can hold, causing the extra data to overflow into adjacent memory spaces. This can cause problems and can lead to security vulnerabilities in a program, such as a buffer overflow vulnerability. In the other options, (B) is incorrect because it does not accurately describe a buffer overflow, (C) is incorrect because it refers to a different type of memory access issue, and (D) is incorrect because it describes the program's response to a buffer overflow, not the cause of it."}
{"question": "A digital signature needs a", "choices": [{"label": "A", "text": "Private-key system"}, {"label": "B", "text": "Shared-key system"}, {"label": "C", "text": "Public-key system"}, {"label": "D", "text": "All of them"}], "answerKey": "C", "model_answer": "The correct answer is (C) Public-key system.\nA digital signature is a cryptographic technique used to verify the authenticity and integrity of digital messages or documents. It uses a combination of public-key and private-key cryptography to create a secure and tamper-proof signature.\nIn a public-key system, the sender of the digital signature uses their private key to create a digital signature, which can then be verified by anyone using the sender's public key. This ensures that only the sender can create valid signatures for a particular message or document, and that anyone can verify that the signature is authentic.\nOn the other hand, shared-key systems and private-key systems have limitations and security concerns that make them less suitable for digital signatures. Shared-key systems require a shared secret key between the sender and the recipient, which can be difficult to establish and manage, while private-key systems can be vulnerable to key compromise attacks.\nTherefore, the correct answer is (C) Public-key system."}
{"question": "A packet filter firewall filters at the", "choices": [{"label": "A", "text": "Application or transport"}, {"label": "B", "text": "Data link layer"}, {"label": "C", "text": "Physical Layer"}, {"label": "D", "text": "Network or transport layer"}], "answerKey": "D", "model_answer": "The correct answer is (C) Physical Layer.\n\nA packet filter firewall filters traffic at the network layer, but it can also filter traffic at other layers such as the data link layer, network layer, or transport layer. However, the physical layer is where data is transmitted in the form of bits, and a packet filter firewall would filter traffic at this layer.\n\nWhile it's possible for a firewall to filter traffic at other layers, packet filter firewalls are typically set up to filter traffic at the physical layer to ensure maximum security.\n\nTherefore, the answer is (C) Physical Layer."}
{"question": "Let I = (S,V)I=(S,V) be a MAC. Suppose S(k,m)S(k,m) is always 5 bits long. Can this MAC be secure?", "choices": [{"label": "A", "text": "No, an attacker can simply guess the tag for messages"}, {"label": "B", "text": "It depends on the details of the MAC"}, {"label": "C", "text": "Yes, the attacker cannot generate a valid tag for any message"}, {"label": "D", "text": "Yes, the PRG is pseudorandom"}], "answerKey": "A", "model_answer": "I'm sorry, but I cannot provide an answer without more context. The question and choices do not provide enough information to determine the security of the MAC. Further information and analysis would be necessary to answer this question accurately."}
{"question": "Which of the following deals with network intrusion detection and real-time traffic analysis?", "choices": [{"label": "A", "text": "John the Ripper"}, {"label": "B", "text": "L0phtCrack"}, {"label": "C", "text": "Snort"}, {"label": "D", "text": "Nessus"}], "answerKey": "C", "model_answer": "The correct answer is (C) Snort. Snort is a free and open-source network security monitoring tool that can be used for intrusion detection and real-time traffic analysis. It can be used to detect a wide range of attacks and vulnerabilities, including network scans, port scans, denial-of-service (DoS) attacks, and more. Snort uses a rule-based system to identify suspicious patterns in network traffic and can be configured to alert security personnel or take automatic action to block malicious traffic."}
{"question": "The Message condentiality or privacy means that the sender and the receiver expect", "choices": [{"label": "A", "text": "Integrity"}, {"label": "B", "text": "Condentiality"}, {"label": "C", "text": "Authentication"}, {"label": "D", "text": "Nonrepudiation"}], "answerKey": "B", "model_answer": "The correct answer is (B) Condentiality. The term \"conditional disclosure\" refers to the intentional withholding or obscuring of information, whereas \"confidentiality\" refers to the protection of information from unauthorized access and disclosure. Conditional disclosure is a tactic used in cryptography to ensure that information is only revealed under certain circumstances, while confidentiality is a broader concept that encompasses the protection of information from unauthorized access and disclosure. Integrity, authentication, and nonrepudiation are also important concepts in information security and privacy, but they are not directly related to the concept of condentiality."}
{"question": "When a wireless user authenticates to any AP, both of them go in the course of four-step authentication progression which is called _____________", "choices": [{"label": "A", "text": "AP-handshaking"}, {"label": "B", "text": "4-way handshake"}, {"label": "C", "text": "4-way connection"}, {"label": "D", "text": "wireless handshaking"}], "answerKey": "B", "model_answer": "wn\n                                            B) 4-way handshake\n```"}
{"question": "Message authentication is a service beyond", "choices": [{"label": "A", "text": "Message Condentiality"}, {"label": "B", "text": "Message Integrity"}, {"label": "C", "text": "Message Splashing"}, {"label": "D", "text": "Message Sending"}], "answerKey": "B", "model_answer": "The correct answer is (B) Message Integrity."}
{"question": "Which of the following are most vulnerable to injection attacks?", "choices": [{"label": "A", "text": "Session IDs"}, {"label": "B", "text": "Registry keys"}, {"label": "C", "text": "Network communications"}, {"label": "D", "text": "SQL queries based on user input"}], "answerKey": "D", "model_answer": "The most vulnerable to injection attacks are SQL queries based on user input.\n\nInjection attacks involve injecting malicious code or data into a program or system, exploiting vulnerabilities in how the system handles user input. SQL injection attacks target database management systems and involve injecting malicious SQL commands into a database or query. If a user's input is not properly sanitized and validated, an attacker can exploit a vulnerability to execute arbitrary SQL commands, potentially accessing or modifying sensitive data, corrupting data, or disrupting the normal functioning of the application and database. Session IDs and registry keys are generally not vulnerable to injection attacks because they are not used in the context of user input or database queries. Network communications can also be vulnerable to injection attacks, particularly in protocols such as HTTP and SMTP, but they are generally not as vulnerable as SQL queries."}
{"question": "Assume that a TLS connection has been established successfully between a client and a server. Establishing the session included checking the server certificate and executing a DiffieHelmann exchange, but the client did not provide a client certificate. Further, assume that the client and server are honest, that the client and server don\u2019t leak their keys, and that the cryptography is good. Which of the following attacks does TLS protect against?\n1. An attacker replacing bytes sent by a client with bytes of the attacker\u2019s own choosing.\n2. An attacker reading the plaintext bytes sent by a client.", "choices": [{"label": "A", "text": "True, True"}, {"label": "B", "text": "False, False"}, {"label": "C", "text": "True, False"}, {"label": "D", "text": "False, True"}], "answerKey": "A", "model_answer": "The correct answer is (D) False, True. Here's why:\nTLS (Transport Layer Security) is designed to provide confidentiality, integrity, and authentication of data between two communicating endpoints (client and server). When a TLS connection is established, the client and server exchange a series of encrypted messages to establish a secure connection. This includes verifying the server's SSL/TLS certificate, checking the server's public key, and executing a Diffie-Hellman key exchange.\n\nIn the given scenario, the client did not provide a client certificate, so the server cannot verify the client's identity. However, since the client and server are assumed to be honest and do not leak their keys, and the cryptography is assumed to be good, an attacker cannot break the encryption or impersonate the client or server.\n\nTherefore, the only possibility that TLS protects against is an attacker reading the plaintext bytes sent by the client. This is because the server does not have a certificate for the client, and without the certificate, the server cannot verify the client's identity. An attacker could potentially intercept and read the plaintext bytes sent by the client, but the TLS encryption would prevent them from understanding the contents."}
{"question": "Which of the following is a Wireless traffic Sniffing tool?", "choices": [{"label": "A", "text": "Maltego"}, {"label": "B", "text": "BurpSuit"}, {"label": "C", "text": "Nessus"}, {"label": "D", "text": "Wireshark"}], "answerKey": "D", "model_answer": "The correct answer is (D) Wireshark. Wireshark is a Wireless traffic Sniffing tool that allows users to capture, analyze, and dissect wireless network traffic in real-time. It is commonly used by network administrators, security professionals, and researchers to troubleshoot network problems, analyze security threats, and diagnose performance issues. Maltego, BurpSuit, and Nessus are not wireless traffic sniffing tools. Maltego is a threat intelligence tool that helps users gather and analyze data about potential threats to their organization. BurpSuit is a security tool that helps users test the security of web applications. Nessus is a vulnerability scanner that helps users identify vulnerabilities in their systems and applications."}
{"question": "A ___________ is a method in which a computer security mechanism is bypassed untraceable for accessing the computer or its information.", "choices": [{"label": "A", "text": "front-door"}, {"label": "B", "text": "backdoor"}, {"label": "C", "text": "clickjacking"}, {"label": "D", "text": "key-logging"}], "answerKey": "B", "model_answer": ""}
{"question": "Which of the following is not a block cipher operating mode?", "choices": [{"label": "A", "text": "ECB"}, {"label": "B", "text": "CFB"}, {"label": "C", "text": "CBF"}, {"label": "D", "text": "CBC"}], "answerKey": "C", "model_answer": "The correct answer is (D) CBC. CBC stands for Cipher Block Chaining and is one of the most commonly used block cipher modes of operation. It is a mode of operation that uses a single round of encryption to transform plaintext into ciphertext. In CBC, each block of plaintext is encrypted using a different encryption key, and the resulting ciphertext blocks are concatenated to produce the final ciphertext.ECB, CFB, and CBF are other modes of operation that can be used with block ciphers. ECB stands for Electronic Codebook and is a mode of operation that simply encrypts each block of plaintext using the same encryption key. CFB stands for Cipher Feedback and is a mode of operation that uses a feedback loop to generate the encryption key for each block of plaintext. CBF stands for Counter-Based Freedom and is a mode of operation that uses a counter to generate the encryption key for each block of plaintext."}
{"question": "What is a web proxy?", "choices": [{"label": "A", "text": "A piece of software that intercepts and possibly modifies requests (and responses) between a web browser and web server"}, {"label": "B", "text": "An agent that makes decisions on the client's behalf when interacting with web applications"}, {"label": "C", "text": "A piece of software that makes a web application look like a standalone application, making it easier to test"}, {"label": "D", "text": "A simulator for the web, for use when off-line"}], "answerKey": "A", "model_answer": "(A) A web proxy is a piece of software that intercepts and possibly modifies requests (and responses) between a web browser and web server."}
{"question": "Buffer-overflow may remain as a bug in apps if __________ are not done fully.", "choices": [{"label": "A", "text": "boundary hacks"}, {"label": "B", "text": "memory checks"}, {"label": "C", "text": "boundary checks"}, {"label": "D", "text": "buffer checks"}], "answerKey": "C", "model_answer": "The correct answer is (D) buffer checks. Buffer-overflow is a common type of software bug that can occur when a program tries to write data to a buffer that is too small or when it tries to write more data than the buffer can hold. To prevent buffer-overflow bugs, it is important to ensure that buffer sizes are properly configured and that data is properly validated and checked before being written to the buffer. Memory checks and boundary checks are also important for preventing buffer-overflow bugs, but they do not specifically address the issue of ensuring proper buffer configuration and size."}
{"question": "Applications developed by programming languages like ____ and ______ have this common buffer-overflow error.", "choices": [{"label": "A", "text": "C, Ruby"}, {"label": "B", "text": "Python, Ruby"}, {"label": "C", "text": "C, C++"}, {"label": "D", "text": "Tcl, C#"}], "answerKey": "C", "model_answer": "The correct answer is (B) Python, Ruby.\n\nPython and Ruby are both high-level programming languages that are commonly used for web development, scripting, and other applications. However, they have different features and characteristics that make them suitable for different tasks.\nPython is a versatile, high-level language that is known for its simplicity, readability, and ease of use. It has a large standard library and a vast collection of third-party libraries that make it a popular choice for a wide range of applications, from web development and data analysis to artificial intelligence and machine learning.\nRuby is a dynamic, high-level language that is known for its concise syntax and emphasis on simplicity and productivity. It is often used for web development, particularly with the Ruby on Rails framework, and has a strong focus on developer happiness and community.\nBoth Python and Ruby have been used to develop applications that have a common buffer-overflow error. The buffer-overflow error occurs when a program tries to store more data in a buffer than it can handle, and the excess data overflows into adjacent memory. This can cause memory corruption, crashing, or other errors, which can be difficult to debug and fix.\nHowever, the likelihood and severity of buffer-overflow errors can vary depending on the specific programming language and application, as well as other factors such as code quality, design, testing, and maintenance. Therefore, it is important to carefully evaluate and assess the specific risks and challenges of each programming language and application to ensure that it is suitable for a given task."}
{"question": "Encryption and decryption provide secrecy, or condentiality, but not", "choices": [{"label": "A", "text": "Authentication"}, {"label": "B", "text": "Integrity"}, {"label": "C", "text": "Privacy"}, {"label": "D", "text": "All of the above"}], "answerKey": "B", "model_answer": ": The correct answer is (D) All of the above.\nEncryption and decryption both provide confidentiality, which is the protection of sensitive information from unauthorized access. They do this by encoding the information in a way that it can only be accessed with a specific key. This key is known only to the recipient, ensuring that the information remains secret.\nAuthentication, on the other hand, provides a way to verify the identity of the user or system requesting access to the information. It ensures that only authorized parties can access the information.\nIntegrity refers to the assurance that the information has not been tampered with or altered during transmission. This is achieved through digital signatures or message authentication codes, which verify the authenticity of the information.\nSo, all of the above choices are correct, and encryption and decryption do indeed provide secrecy, authentication, and integrity, while privacy refers to the protection of personal information that is not sensitive in nature."}
{"question": "A/an ___________ is a program that steals your logins & passwords for instant messaging applications.", "choices": [{"label": "A", "text": "IM \u2013 Trojans"}, {"label": "B", "text": "Backdoor Trojans"}, {"label": "C", "text": "Trojan-Downloader"}, {"label": "D", "text": "Ransom Trojan"}], "answerKey": "A", "model_answer": "The correct answer is (A) IM \u2013 Trojans.\nIM \u2013 Trojans, also known as Instant Messenger Trojans, are a type of malware that is designed to steal login credentials for instant messaging applications such as Skype, WhatsApp, and others. They typically infect a device through a phishing email or by downloading a malicious attachment. Once installed, the Trojan can intercept and capture login credentials, and then send them to the attacker. Other types of Trojans, such as Backdoor Trojans and Trojan-Downloaders, can also be used to steal login credentials, but IM \u2013 Trojans are specifically designed for this purpose. A Ransom Trojan, on the other hand, is a type of malware that encrypts a victim's files and demands payment in exchange for the decryption key."}
{"question": "The sub key length at each round of DES is__________", "choices": [{"label": "A", "text": "32"}, {"label": "B", "text": "56"}, {"label": "C", "text": "48"}, {"label": "D", "text": "64"}], "answerKey": "B", "model_answer": "The correct answer is (D) 64.\nThe Data Encryption Standard (DES) is a symmetric-key block cipher that uses a 56-bit key to encrypt and decrypt data. At each round of the encryption process, the key is XORed with the input data, and the result is used as the input for the next round. The sub key length at each round of DES is 64 bits, which is the length of the key that is XORed with the input data at each round.\nThe other choices in the question are incorrect because they do not match the sub key length at each round of DES. (A) 32 is the key size, which is the length of the key in bits, not the sub key length at each round. (B) 56 is the total key length, which is the sum of the key size and the sub key length at each round. (C) 48 is the key size, but it is not the correct answer because the correct answer is 56."}
{"question": "Which of the following is true of mutation-based fuzzing?", "choices": [{"label": "A", "text": "It generates each different input by modifying a prior input"}, {"label": "B", "text": "It works by making small mutations to the target program to induce faults"}, {"label": "C", "text": "Each input is mutation that follows a given grammar"}, {"label": "D", "text": "It only makes sense for file-based fuzzing, not network-based fuzzing"}], "answerKey": "A", "model_answer": "B. It works by making small mutations to the target program to induce faults."}
{"question": "What are the types of scanning?", "choices": [{"label": "A", "text": "Port, network, and services"}, {"label": "B", "text": "Network, vulnerability, and port "}, {"label": "C", "text": "Passive, active, and interactive"}, {"label": "D", "text": "Server, client, and network"}], "answerKey": "B", "model_answer": "The correct answer is (B) Network, vulnerability, and port.\n\nScanning refers to the process of examining a computer system, network, or system component to determine what services are available and what their vulnerabilities are. Port scanning is a specific type of scanning that involves determining which ports are open on a target system, which can be used to identify potential vulnerabilities and weaknesses that an attacker could exploit. Vulnerability scanning is a type of scanning that involves identifying and assessing the vulnerabilities of systems, networks, and applications to determine their susceptibility to potential attacks. Active scanning involves actively probing a target system to determine its vulnerabilities, while passive scanning involves monitoring network traffic to identify potential vulnerabilities. Interactive scanning involves actively attempting to exploit vulnerabilities in a target system, while non-interactive scanning involves only passively identifying vulnerabilities."}
{"question": "A sender must not be able to deny sending a message that was sent, is known as", "choices": [{"label": "A", "text": "Message Nonrepudiation"}, {"label": "B", "text": "Message Integrity"}, {"label": "C", "text": "Message Condentiality"}, {"label": "D", "text": "Message Sending"}], "answerKey": "A", "model_answer": "The correct answer is (A) Message Nonrepudiation.\nMessage nonrepudiation refers to the ability to prove that a message was sent and received by the intended recipient, even if the sender attempts to deny sending it later. This ensures that the sender cannot reject or deny sending the message.\nMessage integrity and confidentiality are also important aspects of communication, but they do not directly address the issue of the sender's ability to deny sending the message.\nMessage sending refers to the process of sending the message itself, and it is not the same as message nonrepudiation."}
{"question": "A proxy rewall lters at the", "choices": [{"label": "A", "text": "Physical layer"}, {"label": "B", "text": "Application layer"}, {"label": "C", "text": "Data link layer"}, {"label": "D", "text": "Network layer"}], "answerKey": "B", "model_answer": "The correct answer is: (D) Network layer.\nA proxy firewall filters at the network layer by inspecting and controlling network traffic based on IP addresses and port numbers. It can be used to block access to certain websites or services and can help prevent unauthorized access to a network or device. The physical layer and application layer are lower-level layers in the OSI model, while the data link layer is a medium-access control layer, so they are not the correct answers for this question."}
{"question": "Encapsulating Security Payload (ESP) belongs to which Internet Security Protocol?", "choices": [{"label": "A", "text": "Secure Socket Layer Protocol"}, {"label": "B", "text": "Secure IP Protocol"}, {"label": "C", "text": "Secure Http Protocol"}, {"label": "D", "text": "Transport Layer Security Protocol"}], "answerKey": "B", "model_answer": ""}
{"question": "A special tool is necessary for entering the network which is _______________ that helps the anonymous internet users to access into the Tor\u2019s network and use various Tor services.", "choices": [{"label": "A", "text": "Opera browser"}, {"label": "B", "text": "Firefox"}, {"label": "C", "text": "Chrome"}, {"label": "D", "text": "Tor browser"}], "answerKey": "D", "model_answer": "The correct answer is (D) Tor browser. The Tor browser is a special browser that is specifically designed to access the Tor network and use various Tor services anonymously. It is the only option among the choices that meets this specific requirement. The Opera browser, Firefox, and Chrome are all regular web browsers that cannot be used to access the Tor network or use Tor services anonymously."}
{"question": "How does a buffer overflow on the stack facilitate running attacker-injected code?", "choices": [{"label": "A", "text": "By overwriting the return address to point to the location of that code"}, {"label": "B", "text": "By writing directly to the instruction pointer register the address of the code"}, {"label": "C", "text": "By writing directly to %eax the address of the code"}, {"label": "D", "text": "By changing the name of the running executable, stored on the stack"}], "answerKey": "A", "model_answer": "Answer: A) By overwriting the return address to point to the location of that code.\nExplanation: A buffer overflow occurs when more data is written to a buffer than it can hold, causing the extra data to overflow into adjacent memory regions. In the case of a stack buffer overflow, the attacker can overwrite the return address, which is the memory address that tells the program where to return to after the current function call. By overwriting the return address with the address of the attacker-injected code, the program will execute that code instead of returning to its original state. This can be used to run attacker-injected code and potentially compromise the system's security."}
{"question": "The digest created by a hash function is normally called a", "choices": [{"label": "A", "text": "Modication detection code (MDC)"}, {"label": "B", "text": "Modify authentication connection"}, {"label": "C", "text": "Message authentication control"}, {"label": "D", "text": "Message authentication cipher"}], "answerKey": "A", "model_answer": "The correct answer is (C) Message authentication control. Here's why:\n\nA message authentication code (MAC) is a value generated by computing a cryptographic hash function on a message and a secret key. The resulting digest, also called a MAC, is then appended to the message. The recipient can verify the authenticity of the message by recomputing the MAC using the same key and the received message, and comparing it to the received MAC. If the MAC checks out, the message is considered authentic.\n\nIn contrast, a modification detection code (MDC) is a technique used in storage systems to detect and correct errors in data storage. It involves appending a code to each data block before it is written to storage, and checking the code back from the data when reading it from storage. The code is chosen such that an uncorrected error in the data will result in a mismatch between the expected and actual codes.\n\nA modify authentication connection (MAC) is a protocol used in computer networks to authenticate and encrypt web traffic. It involves generating a MAC for each request using a secret key and the request data, and appending the MAC to the request. The server then verifies the MAC using the same key and the received request.\n\nA message authentication cipher (MAC) is a type of symmetric encryption algorithm that uses a secret key to encrypt and decrypt data, as well as generate a MAC.\n\nTherefore, the correct answer is (C) Message authentication control."}
{"question": "Let F: K \\times R \\to MF:K\u00d7R\u2192M be a secure PRF. For m \\in Mm\u2208M define E(k,m) = \\big[ r \\gets R,\\ \\text{output } \\big(r,\\ F(k,r) \\oplus m\\big)\\ \\big]E(k,m)=[r\u2190R, output (r, F(k,r)\u2295m) ] Is EE symantically secure under CPA?", "choices": [{"label": "A", "text": "Yes, whenever F is a secure PRF"}, {"label": "B", "text": "No, there is always a CPA attack on this system"}, {"label": "C", "text": "Yes, but only if R is large enough so r never repeats (w.h.p)"}, {"label": "D", "text": "It depends on what F is used"}], "answerKey": "C", "model_answer": "The correct answer is (C) Yes, but only if R is large enough so r never repeats (w.h.p).\nThe reason is that the chosen-plaintext attack (CPA) can exploit the fact that the output of the function F is independent of the key kk. Therefore, an attacker can use the same plaintext rr to both encrypt and decrypt messages, allowing them to infer the corresponding ciphertext.\nHowever, this attack is only possible if rrr never repeats for the same plaintext. If rrr does repeat, then the attacker cannot choose the same plaintext for encryption and decryption, and the security of the system is not compromised.\nSo, the security of the system under the chosen-plaintext attack (CPA) depends on the property of the random function FFF. If FFF is a secure PRF and rrr never repeats for the same plaintext, then the system is secure. Otherwise, an attacker can exploit the dependency in the output of FFF to launch a successful CPA attack."}
{"question": "Old operating systems like _______ and NT-based systems have buffer-overflow attack a common vulnerability.", "choices": [{"label": "A", "text": "Windows 7"}, {"label": "B", "text": "Chrome"}, {"label": "C", "text": "IOS12"}, {"label": "D", "text": "UNIX"}], "answerKey": "D", "model_answer": "The correct answer is (D) UNIX.\n\nUNIX, a popular operating system, has had several buffer-overflow vulnerabilities, which can be exploited by attackers to gain unauthorized access to systems. Windows 7, Chrome, and IOS 12 are all newer operating systems that are not known for having buffer-overflow vulnerabilities. Windows 7 is a popular Windows operating system, Chrome is a popular web browser, and IOS 12 is a popular operating system for mobile devices.\n\nChrome and IOS 12 do not have buffer-overflow vulnerabilities because they are designed with secure coding practices that minimize the risk of buffer-overflow attacks. Windows 7 also has had buffer-overflow vulnerabilities in the past, but they have been patched over time. UNIX, on the other hand, has had and continues to have buffer-overflow vulnerabilities, which is why it is the correct answer.\n\nIt's important to note that no operating system is completely immune from vulnerabilities, and all operating systems need to be maintained and updated regularly to ensure their security."}
{"question": "What is a replay attack?", "choices": [{"label": "A", "text": "When the attacker replies to a message sent to it by the system"}, {"label": "B", "text": "An attack that continuously repeats, probing for a weakness"}, {"label": "C", "text": "An attack that uses the system's own messages and so cannot be defended against"}, {"label": "D", "text": "The attacker resends a captured message, and the site accept its and responds in the attacker's favor"}], "answerKey": "D", "model_answer": "The correct answer is (A) When the attacker replies to a message sent to it by the system. A replay attack is a type of cyber attack where the attacker intercepts and replays a message that was previously sent to them, in an attempt to gain unauthorized access or perform malicious actions. The attacker may intercept the message by capturing it using various methods, such as wiretapping or packet sniffing, and then replay it to the system at a later time. Replay attacks can be particularly dangerous in situations where authentication is not performed or is weak, such as in the case of an email system or a chat application."}
{"question": "Statement 1| A U2F USB dongle prevents malware on the user\u2019s computer from stealing the user\u2019s second factor to authenticate as that user even when the user\u2019s computer is turned off. Statement 2| A server using U2F can reliably determine that the user who is attempting to login is indeed behind the computer that sent the login request.", "choices": [{"label": "A", "text": "True, True"}, {"label": "B", "text": "False, False"}, {"label": "C", "text": "True, False"}, {"label": "D", "text": "False, True"}], "answerKey": "C", "model_answer": "(D) False, True.\n\nHere's why:\nStatement 1 is false, and Statement 2 is true. A U2F USB dongle can prevent malware on the user's computer from stealing the user's second factor to authenticate as that user, even when the user's computer is turned off. However, if the user's computer is off, the user will not be able to use their second factor to authenticate, so this protection is not always effective.\nOn the other hand, a server using U2F can reliably determine that the user who is attempting to login is indeed behind the computer that sent the login request. U2F provides a strong level of assurance that the user is who they claim to be, even if the user's computer is compromised by malware.\nTherefore, the correct answer is (D) False, True."}
{"question": "____________________ is the anticipation of unauthorized access or break to computers or data by means of wireless networks.", "choices": [{"label": "A", "text": "Wireless access"}, {"label": "B", "text": "Wireless security"}, {"label": "C", "text": "Wired Security"}, {"label": "D", "text": "Wired device apps"}], "answerKey": "B", "model_answer": "n\nA) Wireless access\n```"}
{"question": "Which of the following are benefits of penetration testing?", "choices": [{"label": "A", "text": "Results are often reproducible"}, {"label": "B", "text": "Full evidence of security: a clean test means a secure system"}, {"label": "C", "text": "Compositionality of security properties means tested components are secure even if others change"}, {"label": "D", "text": "Makes an adversarial neural network converge more quickly"}], "answerKey": "A", "model_answer": "The correct answer is (A) Results are often reproducible and (B) Full evidence of security: a clean test means a secure system.\n\nPenetration testing is a process of testing a system, network, or application to identify vulnerabilities that an attacker could exploit. The benefits of penetration testing include:\n1. Results are often reproducible: If a vulnerability is identified during a penetration test, it can be verified and replicated, providing a high level of confidence that the vulnerability exists and can be exploited.\n2. Full evidence of security: A clean test means a secure system: If the test is successful, it provides evidence that the system is secure, and any vulnerabilities have been identified and addressed.\n\nIt is important to note that penetration testing does not guarantee security, but it can help identify vulnerabilities and provide evidence of the security of a system or application. Penetration testing can also be used to evaluate the effectiveness of security controls and improve security posture over time. Penetration testing is a valuable tool for organizations looking to improve their security posture and protect against potential attacks."}
{"question": "1. _________ framework made cracking of vulnerabilities easy like point and click.", "choices": [{"label": "A", "text": ".Net"}, {"label": "B", "text": "Metasploit"}, {"label": "C", "text": "Zeus"}, {"label": "D", "text": "Ettercap"}], "answerKey": "B", "model_answer": ""}
{"question": "You are given a message (m) and its OTP encryption (c). Can you compute the OTP key from m and c ?", "choices": [{"label": "A", "text": "No, I cannot compute the key."}, {"label": "B", "text": "Yes, the key is k = m xor c."}, {"label": "C", "text": "I can only compute half the bits of the key."}, {"label": "D", "text": "Yes, the key is k = m xor m."}], "answerKey": "B", "model_answer": "The correct answer is (B) Yes, the key is k = m xor c.\nIn OTP (One-Time Pad) encryption, the key is used to encrypt and decrypt the message. The key is a random string of bits that is the same length as the message. To encrypt the message, you XOR (exclusive or) the message with the key, and to decrypt the message, you XOR the message with the key.\nTo compute the key from the message and its OTP encryption, you can simply XOR the message and the OTP encryption, and the resulting bits will be the key. So, the answer is (B) Yes, the key is k = m xor c."}
{"question": "The openSSL implementation described in \u201cRemote Timing Attacks are Practical\u201d (by Brumley and Boneh) uses the following performance optimizations: Chinese Remainder (CR), Montgomery Representation (MR), Karatsuba Multiplication (KM), and Repeated squaring and Sliding windows (RS). Which of the following options would close the timing channel attack described in the paper if you turned the listed optimizations off?\n1. CR and MR\n2. CR", "choices": [{"label": "A", "text": "True, True"}, {"label": "B", "text": "False, False"}, {"label": "C", "text": "True, False"}, {"label": "D", "text": "False, True"}], "answerKey": "A", "model_answer": "True, False."}
{"question": "When the data must arrive at the receiver exactly as they were sent, its called", "choices": [{"label": "A", "text": "Message Condentiality"}, {"label": "B", "text": "Message Integrity"}, {"label": "C", "text": "Message Splashing"}, {"label": "D", "text": "Message Sending"}], "answerKey": "B", "model_answer": "The correct answer is (A) Message Condentiality.\nMessage integrity and message authentication are also important aspects of data transmission, but they are not explicitly referred to as \"exactly as they were sent\". Message confidentiality refers to ensuring that the data is kept secret and only accessible by authorized parties."}
{"question": "What is the difference between a direct leak and a side channel?", "choices": [{"label": "A", "text": "A direct leak creates a denial of service by failing to free memory, while a channel frees memory as a side effect"}, {"label": "B", "text": "A direct leak is one that is intentional, rather than by unintentional"}, {"label": "C", "text": "A direct leak comes via the software system's intended interaction mechanism, where as a side channel leak comes from measurements of other system features, like timing, power usage, or space usage"}, {"label": "D", "text": "There is no difference"}], "answerKey": "C", "model_answer": "The correct answer is (B) A direct leak is one that is intentional, rather than by unintentional means, while a side channel is an unintentional leak that occurs through measurements of other system features, such as timing, power usage, or space usage."}
{"question": "A session symmetric key between two parties is used", "choices": [{"label": "A", "text": "Only once"}, {"label": "B", "text": "Twice"}, {"label": "C", "text": "Multiple times"}, {"label": "D", "text": "Conditions dependant"}], "answerKey": "A", "model_answer": "The correct answer is (A) Only once.\nThe key is used once to encrypt and decrypt data between two parties, and then it is discarded. It is not reused or used multiple times. The key is typically generated randomly and is unique to each session between the two parties. It is not used in any other context or session, and it is not used again in the future. Therefore, the choice (A) is the correct answer."}
{"question": "What is a nop sled", "choices": [{"label": "A", "text": "It is an anonymous version of a mop sled"}, {"label": "B", "text": "It is a sequence of nops preceding injected shellcode, useful when the return address is unknown"}, {"label": "C", "text": "It is a method of removing zero bytes from shellcode"}, {"label": "D", "text": "It is another name for a branch instruction at the end of sequence of nops"}], "answerKey": "B", "model_answer": "B) It is a sequence of nops preceding injected shellcode, useful when the return address is unknown."}
{"question": "Which Nmap scan is does not completely open a TCP connection?", "choices": [{"label": "A", "text": "SYN stealth scan"}, {"label": "B", "text": "TCP connect"}, {"label": "C", "text": "XMAS tree scan"}, {"label": "D", "text": "ACK scan"}], "answerKey": "A", "model_answer": "The Nmap scan that does not completely open a TCP connection is the SYN stealth scan. This type of scan sends a SYN packet to the target port, but does not complete the TCP connection. The target system will respond with a SYN-ACK packet, which the scanning system will recognize as a connection request. The scanning system will then send an ACK packet to complete the TCP connection, but will not send a SYN-ACK packet to complete the connection. This allows the SYN stealth scan to avoid detection by systems that only look for full TCP connection attempts. The other options are incorrect because they involve either completing a full TCP connection (B), scanning for ports that are open but not responding to connection attempts (C), or scanning for open ports without completing a connection (A)."}
{"question": "Based on the paper \u201cClick Trajectories: End-to-End Analysis of the Spam Value Chain\u201d, which of the following statements are true? \u201cSpammers\u201d here refer to operators of various parts of the \u201cspam value chain.\u201d", "choices": [{"label": "A", "text": "Spammers run their spam-advertised web sites on compromised user machines that are part of a botnet."}, {"label": "B", "text": "Spammers need to register domain names in order for their spam-based advertisements to be effective."}, {"label": "C", "text": "There is a high cost for spammers to switch acquiring banks."}, {"label": "D", "text": "B and C"}], "answerKey": "D", "model_answer": "The correct answer is (D) B and C, because:\n1. Option (A) is true. Spammers often use botnets, which are networks of compromised computers, to run their spam-advertised web sites.\n2. Option (B) is true. In order for spam-based advertisements to be effective, spammers need to register domain names.\n3. Option (C) is false. There is no high cost for spammers to switch acquiring banks. In fact, it can be relatively easy for them to do so, as they often use anonymous payment methods to make transactions.\n\n\ubc88\uc5ed\uacb0\uacfc  \n\ubb38\uc81c: \"\ub9c1\ud06c \ud2b8\ub808\uc774\ubc14\uc640\ud06c: \uc804\ud1b5 \ube44\uc988\ub2c8\uc2a4 \ucc44\ub110 \ubd84\uc11d\" \uc11c\ub860\uc11c\uc5d0 \ub530\ub974\uba74 \ub9c1\ud06c \ud2b8\ub808\uc774\ubc14\uc640\ud06c\uc758 \ub2e4\uc591\ud55c \ubd80\ubd84\uc5d0\uc11c \uc791\ub3d9\ud558\ub294 \uae30\uc5c5\uc778 \"\uc2a4\ud338\ub9c1\ubcbd\"\uc758 \ub2e4\uc74c \uc8fc\uc7a5\uc774 \uc633\uc2b5\ub2c8\uae4c?\n\"\uc2a4\ud338\ub9c1\ubcbd\"\uc5d0\uc11c \uc791\ub3d9\ud558\ub294 \ub2e4\uc591\ud55c \ubd80\ubd84\uc5d0\uc11c \uc791\ub3d9\ud558\ub294 \uae30\uc5c5 \uc774\ub984\n\"\uc2a4\ud338\ub9c1\ubcbd\"\uc5d0\uc11c \uc791\ub3d9\ud558\ub294 \ub2e4\uc591\ud55c \ubd80\ubd84\uc5d0\uc11c \uc791\ub3d9\ud558\ub294 \uae30\uc5c5 \uc774\ub984\n\"\uc2a4\ud338\ub9c1\ubcbd\" \uad00\ub828 \ubaa8\ub4e0 \ubd80\ubd84\uc5d0\uc11c \uc791\ub3d9\ud558\ub294 \uae30\uc5c5 \uc774\ub984\n\"\uc2a4\ud338\ub9c1\ubcbd\" \uad00\ub828 \ubaa8\ub4e0 \ubd80\ubd84\uc5d0\uc11c \uc791\ub3d9\ud558\ub294 \uae30\uc5c5 \uc774\ub984\n\ub9c1\ud06c \ud2b8\ub808\uc774\ubc14\uc640\ud06c\uc758 \ub2e4\uc591\ud55c \ubd80\ubd84\uc5d0\uc11c \uc791\ub3d9\ud558\ub294 \uae30\uc5c5\uc774 \uc791\ub3d9\ud558\ub294 \uac83\uc774 \uc633\uc2b5\ub2c8\ub2e4. \ub9c1\ud06c \ud2b8\ub808\uc774\ubc14\uc640\ud06c\ub294 \uac70\ub798\uc640 \uad11\uace0\ub97c \uc704\ud574 \ubb34\uc791\uc704\ub85c \uc0dd\uc131\ub41c \ub3c4\uba54\uc778\uacfc \uc720\ud2f8\ub9ac\ud2f0 \uac70\ub798 \ucc98\ub9ac \uae30\uc5c5\uc744 \ud3ec\ud568\ud558\uc5ec \ub2e4\uc591\ud55c \ubd80\ubd84\uc758 \uc2a4\ud338 \uad11\uace0 \uc0dd\uc131 \uc5d4\uc9c4\uacfc \uad00\ub828\ub41c \ub2e4\uc591\ud55c \uc6b4\uc601 \uacfc\uc815\uc744 \uc704\ud574 \ub2e4\ub978 \uae30\uc5c5 \ub610\ub294 \uc5d4\ud130\ud504\ub77c\uc774 \ubca4\ucc98 \uae30\uc5c5\uc744 \ud3ec\ud568\ud569\ub2c8\ub2e4."}
{"question": "In a _____________ attack, the extra data that holds some specific instructions in the memory for actions is projected by a cyber-criminal or penetration tester to crack the system.", "choices": [{"label": "A", "text": "Phishing"}, {"label": "B", "text": "MiTM"}, {"label": "C", "text": "Buffer-overflow"}, {"label": "D", "text": "Clickjacking"}], "answerKey": "C", "model_answer": "The correct answer is (B) MiTM (Man-in-the-Middle).\nA MiTM attack involves intercepting communication between two parties to eavesdrop, modify, or impersonate their communication. In this attack, the attacker intercepts the communication between the user and the target system, allowing them to see and modify the data being exchanged. The attacker can also inject malicious code or instructions into the communication, which can then be executed by the unsuspecting user.\nThe other choices do not match the description of a MiTM attack. Phishing is a social engineering attack that tricks users into revealing sensitive information. Buffer-overflow is a type of software vulnerability that can allow an attacker to execute arbitrary code, but it is not a type of attack. Clickjacking is a type of attack that involves disguising a button or other clickable element as something else to trick users into clicking on it, but it is not a type of attack."}
{"question": "_______________ is a popular tool used for network analysis in multiprotocol diverse network.", "choices": [{"label": "A", "text": "Snort"}, {"label": "B", "text": "SuperScan"}, {"label": "C", "text": "Burp Suit"}, {"label": "D", "text": "EtterPeak"}], "answerKey": "D", "model_answer": "(D) EtterPeak.\n\nEtterPeak is a popular tool used for network analysis in multiprotocol diverse networks. It allows network administrators to analyze network traffic, identify and mitigate security threats, and monitor network performance. It supports a wide range of protocols and can be used for both wired and wireless networks. Snort is another tool that can be used for network analysis, but it is primarily focused on intrusion detection and prevention, rather than network analysis in general. SuperScan and Burp Suit are tools used for web application security testing and optimization, respectively, but they are not specifically designed for network analysis."}
{"question": "___________________ is alike as that of Access Point (AP) from 802.11, & the mobile operators uses it for offering signal coverage.", "choices": [{"label": "A", "text": "Base Signal Station"}, {"label": "B", "text": "Base Transmitter Station"}, {"label": "C", "text": "Base Transceiver Station"}, {"label": "D", "text": "Transceiver Station"}], "answerKey": "C", "model_answer": "The correct answer is (B) Base Transmitter Station. The Base Transmitter Station (BTS) is a component of a cellular network that transmits radio signals to mobile devices, providing coverage and connectivity to the users. The term \"Transmitter Station\" is more appropriate than \"Access Point\" since it is part of a cellular network, while Access Point is a device used in wireless local area networks (WLANs) to provide wireless network access to devices such as smartphones, laptops, and tablets. Therefore, option (B) is the correct answer."}
{"question": "A __________ is a sequential segment of the memory location that is allocated for containing some data such as a character string or an array of integers.", "choices": [{"label": "A", "text": "stack"}, {"label": "B", "text": "queue"}, {"label": "C", "text": "external storage"}, {"label": "D", "text": "buffer"}], "answerKey": "D", "model_answer": "r."}
{"question": "Which form of encryption does WPA use?", "choices": [{"label": "A", "text": "Shared key"}, {"label": "B", "text": "LEAP"}, {"label": "C", "text": "TKIP"}, {"label": "D", "text": "AES"}], "answerKey": "C", "model_answer": ""}
{"question": "Let suppose a search box of an application can take at most 200 words, and you\u2019ve inserted more than that and pressed the search button; the system crashes. Usually this is because of limited __________", "choices": [{"label": "A", "text": "buffer"}, {"label": "B", "text": "external storage"}, {"label": "C", "text": "processing power"}, {"label": "D", "text": "local storage"}], "answerKey": "A", "model_answer": "The correct answer is (D) local storage. The local storage of a computer or application is the memory space that is allotted for the program to store its data and functions temporarily while it is being used. When the limit of the local storage is reached, the program may crash, leading to the system failure."}
{"question": "___________________ began to show up few years back on wireless access points as a new way of adding or connecting new devices.", "choices": [{"label": "A", "text": "WPA2"}, {"label": "B", "text": "WPA"}, {"label": "C", "text": "WPS"}, {"label": "D", "text": "WEP"}], "answerKey": "C", "model_answer": "The statement \"WPA2 began to show up few years back on wireless access points as a new way of adding or connecting new devices\" suggests that WPA2 is a newer and more secure method of connecting devices to wireless access points than the older methods WEP, WPA, and WPS. Therefore, the correct answer is:\n\n(D) WEP (WEP is the oldest and least secure method, while WPA2 is the most secure and most recently developed method)"}
{"question": "What are the port states determined by Nmap?", "choices": [{"label": "A", "text": "Active, inactive, standby"}, {"label": "B", "text": "Open, half-open, closed "}, {"label": "C", "text": "Open, filtered, unfiltered"}, {"label": "D", "text": "Active, closed, unused"}], "answerKey": "C", "model_answer": "The port states determined by Nmap are: (A) Active, inactive, standby.\nActive: A port is in the active state when it is open and being used by a service or application.\nInactive: A port is in the inactive state when it is closed and not being used by any service or application.\nStandby: A port is in the standby state when it is waiting to be assigned to a service or application. This state is used when the operating system is trying to conserve resources.\nThe other options are not entirely accurate or complete:\n(B) Open, half-open, closed: This option is not accurate because only the first two options are true port states.\n(C) Open, filtered, unfiltered: This option is not accurate because there is no such thing as a port being unfiltered in the context of Nmap.\n(D) Active, closed, unused: This option is not accurate because the active state is used for ports that are open and being used, not closed and unused."}
{"question": "Which among the following is the least strong security encryption standard?", "choices": [{"label": "A", "text": "WEP"}, {"label": "B", "text": "WPA"}, {"label": "C", "text": "WPA2"}, {"label": "D", "text": "WPA3"}], "answerKey": "A", "model_answer": "The least strong security encryption standard among the options is WEP (Wired Equivalent Privacy), which is choice (A). WEP is an older security standard that was developed in the 1990s and was widely used to secure Wi-Fi networks. However, it is now considered to be broken and insecure due to its weak encryption algorithm and vulnerabilities to attacks such as dictionary attacks and brute force attacks. WPA (Wi-Fi Protected Access) and WPA2 (Wi-Fi Protected Access 2) are stronger security standards that have been developed to address the vulnerabilities of WEP and improve the security of Wi-Fi networks. WPA3 (Wi-Fi Protected Access 3) is a more recent security standard that builds on the strengths of WPA2 and introduces new features to further enhance the security of Wi-Fi networks."}
{"question": "Why is it that the compiler does not know the absolute address of a local variable?", "choices": [{"label": "A", "text": "Programs are not allowed to reference memory using absolute addresses"}, {"label": "B", "text": "The size of the address depends on the architecture the program will run on"}, {"label": "C", "text": "As a stack-allocated variable, it could have different addresses depending on when its containing function is called"}, {"label": "D", "text": "Compiler writers are not very good at that sort of thing"}], "answerKey": "C", "model_answer": "\u200b"}
{"question": "The stack is memory for storing", "choices": [{"label": "A", "text": "Local variables"}, {"label": "B", "text": "Program code"}, {"label": "C", "text": "Dynamically linked libraries"}, {"label": "D", "text": "Global variables"}], "answerKey": "A", "model_answer": "The correct answer is (A) Local variables.\nLocal variables are variables that are defined within a function or block of code and are only accessible within that function or block. They are stored in the local memory of the computer, which is part of the CPU and is used"}
{"question": "Can a stream cipher have perfect secrecy?", "choices": [{"label": "A", "text": "Yes, if the PRG is really \u201csecure\u201d"}, {"label": "B", "text": "No, there are no ciphers with perfect secrecy"}, {"label": "C", "text": "Yes, every cipher has perfect secrecy"}, {"label": "D", "text": "No, since the key is shorter than the message"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following does authorization aim to accomplish?", "choices": [{"label": "A", "text": "Restrict what operations/data the user can access"}, {"label": "B", "text": "Determine if the user is an attacker"}, {"label": "C", "text": "Flag the user if he/she misbehaves"}, {"label": "D", "text": "Determine who the user is"}], "answerKey": "A", "model_answer": "The correct answer is (D) Determine who the user is.\nAuthorization is a security mechanism that is used to determine what operations or data a user can access in a system. It is used to check the identity of the user and verify that they have the necessary permissions to access certain resources. The purpose of authorization is to ensure that only authorized users have access to sensitive or confidential information, and to prevent unauthorized users from accessing or modifying that information.\nIn contrast, (A) Restrict what operations/data the user can access is called access control, (B) Determine if the user is an attacker is called authentication, and (C) Flag the user if he/she misbehaves is called auditing."}
{"question": "The message must be encrypted at the sender site and decrypted at the", "choices": [{"label": "A", "text": "Sender Site"}, {"label": "B", "text": "Site"}, {"label": "C", "text": "Receiver site"}, {"label": "D", "text": "Conferencing"}], "answerKey": "C", "model_answer": "The correct answer is (B) Site. The message must be encrypted at the sender site and decrypted at the receiver site. This means that the encryption and decryption occur at the same physical location, which is the site of the receiver. The sender site refers to the physical location where the message is originated, and the conferencing site does not involve encryption or decryption of the message."}
{"question": "A _________________ may be a hidden part of a program, a separate infected program a Trojan in disguise of an executable or code in the firmware of any system\u2019s hardware.", "choices": [{"label": "A", "text": "crypter"}, {"label": "B", "text": "virus"}, {"label": "C", "text": "backdoor"}, {"label": "D", "text": "key-logger"}], "answerKey": "C", "model_answer": "The correct answer is (A) crypter."}
{"question": "How is IP address spoofing detected?", "choices": [{"label": "A", "text": "Installing and configuring a IDS that can read the IP header"}, {"label": "B", "text": "Comparing the TTL values of the actual and spoofed addresses"}, {"label": "C", "text": "Implementing a firewall to the network"}, {"label": "D", "text": "Identify all TCP sessions that are initiated but does not complete successfully"}], "answerKey": "B", "model_answer": "The correct answer is (A) Installing and configuring a IDS that can read the IP header.\nIP address spoofing is the act of fraudulently displaying or modifying the source address in a packet or message to hide the true source of the communication. Here are some ways IP address spoofing can be detected:\n1. Network Traffic Monitoring: By monitoring the network traffic, it is possible to detect unusual patterns of traffic and anomalies that may indicate spoofing activities.\n2. Network Packet Analysis: By analyzing the packets that are transmitted on the network, it is possible to identify the source IP address of the packets and determine if it matches the expected IP address.\n3. IDS: By installing and configuring an IDS that can read the IP header of the packets, it is possible to detect spoofed IP addresses and alert network administrators.\n4. Firewall: By implementing a firewall to the network, it is possible to block packets that are spoofed or contain malicious traffic.\nThe other options, (B) Comparing the TTL values of the actual and spoofed addresses, (C) Implementing a firewall to the network, and (D) Identify all TCP sessions that are initiated but does not complete successfully, may also be used to detect IP address spoofing, but they are not as effective as the methods mentioned above."}
{"question": "Which of the following is not an example of presentation layer issues?", "choices": [{"label": "A", "text": "Poor handling of unexpected input can lead to the execution of arbitrary instructions"}, {"label": "B", "text": "Unintentional or ill-directed use of superficially supplied input"}, {"label": "C", "text": "Cryptographic flaws in the system may get exploited to evade privacy"}, {"label": "D", "text": "Weak or non-existent authentication mechanisms"}], "answerKey": "D", "model_answer": "The correct answer is (D) Weak or non-existent authentication mechanisms.\n\nPresentation layer issues are related to the way that data is represented and transmitted, and how user input is handled. Some common examples of presentation layer issues include poor handling of unexpected input, unintentional or ill-directed use of superficially supplied input, and issues with cryptographic flaws in the system.\nOn the other hand, weak or non-existent authentication mechanisms are a type of authentication layer issue, which is related to the way that a user is authenticated and authorized to access a system or resource. Authenticating a user is important to ensure that they are who they say they are and have the necessary permissions to access a particular resource. Weak or non-existent authentication mechanisms can be exploited by attackers to gain unauthorized access to a system or resource. Therefore, (D) Weak or non-existent authentication mechanisms is not an example of presentation layer issues."}
{"question": "Suppose Unix did not provide a way of passing file descriptors between processes, but still allowed inheriting file descriptors from a parent on fork and exec. What aspects of the OKWS design would break without file descriptor passing?\n1. It would be impossible for services to send messages to oklogd.\n2. It would be impossible for services to get a TCP connection to a database proxy.", "choices": [{"label": "A", "text": "True, True"}, {"label": "B", "text": "False, False"}, {"label": "C", "text": "True, False"}, {"label": "D", "text": "False, True"}], "answerKey": "B", "model_answer": "he correct answer is (D) False, True.\n\nWithout file descriptor passing, services would still be able to inherit file descriptors from a parent on fork and exec. However, it would be impossible for services to get a TCP connection to a database proxy, and services would not be able to send messages to oklogd."}
{"question": "Why would a ping sweep be used?", "choices": [{"label": "A", "text": "To identify live systems"}, {"label": "B", "text": "To locate live systems"}, {"label": "C", "text": "To identify open ports"}, {"label": "D", "text": "To locate firewalls"}], "answerKey": "A", "model_answer": "The correct answer is (A) To identify live systems. A ping sweep is a network scanning technique that involves sending ping packets to a range of IP addresses or hostnames to determine which ones are alive and responding. This can be useful for identifying other devices on a network, determining network boundaries, and detecting network outages or downtime. It can also help with troubleshooting and identifying potential security threats. A ping sweep is different from a port scan, which involves sending packets to specific ports to identify open ports and potential services running on those ports."}
{"question": "The four Primary Security Principles related to messages are", "choices": [{"label": "A", "text": "Confidentiality, Integrity, Non repudiation and Authentication"}, {"label": "B", "text": "Confidentiality, Access Control, Integrity, Non repudiation"}, {"label": "C", "text": "Authentication, Authorization, Availability, Integrity"}, {"label": "D", "text": "Availability, Authorization, Confidentiality, Integrity"}], "answerKey": "A", "model_answer": "Assistant: The correct answer is (A) Confidentiality, Integrity, Non repudiation and Authentication. These three primary security principles are essential for ensuring the security and privacy of messages and other forms of communication. Confidentiality ensures that messages are not disclosed to unauthorized parties. Integrity refers to the accuracy and consistency of messages, and ensures that they are not tampered with or altered by unauthorized parties. Non repudiation ensures that the originator of a message cannot deny sending it, and provides proof of the authenticity of the message."}
{"question": "What was the first buffer overflow attack?", "choices": [{"label": "A", "text": "Love Bug"}, {"label": "B", "text": "SQL Slammer"}, {"label": "C", "text": "Morris Worm"}, {"label": "D", "text": "Code Red"}], "answerKey": "C", "model_answer": ""}
{"question": "The ______________ can cost you money, by sending text messages from your mobile phone numbers.", "choices": [{"label": "A", "text": "IM \u2013 Trojans"}, {"label": "B", "text": "Backdoor Trojans"}, {"label": "C", "text": "SMS Trojan"}, {"label": "D", "text": "Ransom Trojan"}], "answerKey": "C", "model_answer": "Answer: C) SMS Trojan\nExplanation: SMS Trojans are a type of mobile malware that can cost users money by sending text messages from their mobile phone numbers without their consent. The malware can be installed on a mobile device through various means, such as downloading infected apps, opening malicious links, or visiting infected websites. Once installed, the SMS Trojan can access the device's SMS functionality and send unauthorized text messages, resulting in charges to the user's mobile phone bill.\nOther malware types, such as IM Trojans (choice A), Backdoor Trojans (choice B), Ransom Trojans (choice D), and Trojans in general (choice A or B) can also be costly to users by damaging their devices, stealing sensitive information, or demanding ransom payments, respectively. However, SMS Trojans are specifically designed to cost users money through unauthorized text messages."}
{"question": "Three of the following are classic security properties; which one is not?", "choices": [{"label": "A", "text": "Confidentiality"}, {"label": "B", "text": "Availability"}, {"label": "C", "text": "Correctness"}, {"label": "D", "text": "Integrity"}], "answerKey": "B", "model_answer": "The correct answer is (D) Integrity. The three classic security properties are Confidentiality, which ensures that sensitive information is not disclosed to unauthorized parties;"}
