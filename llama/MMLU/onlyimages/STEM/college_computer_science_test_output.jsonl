{"question": "The access matrix approach to protection has the difficulty that", "choices": [{"label": "A", "text": "the matrix, if stored directly, is large and can be clumsy to manage"}, {"label": "B", "text": "it is not capable of expressing complex protection requirements"}, {"label": "C", "text": "deciding whether a process has access to a resource is undecidable"}, {"label": "D", "text": "there is no way to express who has rights to change the access matrix itself"}], "answerKey": "A", "model_answer": "SOLUTION: The access matrix approach to protection has the difficulty that deciding whether a process has access to a resource is undecidable."}
{"question": "An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y. Which of the following sets of integers could possibly be the set of all common divisors of two integers?", "choices": [{"label": "A", "text": "{-6,-2, -1, 1, 2, 6}"}, {"label": "B", "text": "{-6, -2, -1, 0, 1, 2, 6}"}, {"label": "C", "text": "{-6, -3, -2, -1, 1, 2, 3, 6}"}, {"label": "D", "text": "{-6, -3, -2, -1, 0, 1, 2, 3, 6}"}], "answerKey": "C", "model_answer": "SOLUTION: An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y.\nSo, the set of all common divisors of two integers includes only the prime numbers.\nA prime number is a divisor of every integer, so the set of all common divisors of two integers is the set of all prime numbers.\nThe set of all common divisors of two integers is the same for all pairs of integers.\nSo, the set of all common divisors of two integers is {{-6, -2, -1, 1, 2, 6}, {-6, -2, -1, 0, 1, 2, 6}, {-6, -3, -2, -1, 1, 2, 3, 6}, {-6, -3, -2, -1, 0, 1, 2, 3, 6}}."}
{"question": "In the NoNicks operating system, the time required by a single file-read operation has four nonoverlapping components:\ndisk seek time-25 msec\ndisk latency time-8 msec\ndisk transfer time- 1 msec per 1,000 bytes\noperating system overhead-1 msec per 1,000 bytes + 10 msec\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes. The ratio of-the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately", "choices": [{"label": "A", "text": "1:4"}, {"label": "B", "text": "1:3.5"}, {"label": "C", "text": "1:1"}, {"label": "D", "text": "1.1:1"}], "answerKey": "B", "model_answer": "CTURE: The time required to read a file consists of four nonoverlapping components, or parts. These components are:\ndisk seek time: The time it takes to locate the disk block that contains the data.\ndisk latency time: The time it takes for the disk to start moving after the read command is issued.\ndisk transfer time: The time it takes to transfer data from the disk to the memory.\noperating system overhead: The time it takes for the operating system to handle the read command.\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes.\nSo, the ratio of the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately equal to the ratio of:\n4,000 bytes / 1,000 bytes\nto\n1,000 bytes / 4,000 bytes\nThis ratio is equal to 1:3.5."}
{"question": "You want to cluster 7 points into 3 clusters using the k-Means Clustering algorithm. Suppose after the first iteration, clusters C1, C2 and C3 contain the following two-dimensional points: C1 contains the 2 points: {(0,6), (6,0)} C2 contains the 3 points: {(2,2), (4,4), (6,6)} C3 contains the 2 points: {(5,5), (7,7)} What are the cluster centers computed for these 3 clusters?", "choices": [{"label": "A", "text": "C1: (3,3), C2: (4,4), C3: (6,6)"}, {"label": "B", "text": "C1: (3,3), C2: (6,6), C3: (12,12)"}, {"label": "C", "text": "C1: (6,6), C2: (12,12), C3: (12,12)"}, {"label": "D", "text": "C1: (0,0), C2: (48,48), C3: (35,35)"}], "answerKey": "A", "model_answer": "LECTURE: The k-means algorithm is an iterative algorithm that begins with a random selection of k initial cluster centers. It then assigns each data point to the nearest cluster center. Afterward, it updates the cluster centers by computing the mean of the points assigned to each cluster. It then repeats this process for a specified number of iterations.\nOne of the goals of k-means clustering is to find cluster centers that are well separated, which can help ensure that the clusters are distinct. One way to measure the separation of the cluster centers is to calculate the distance between each pair of cluster centers. This distance is called the within-cluster sum of squares (WCSS).\nThe WCSS can be used to determine the cluster centers. To see why, consider that you want to find the positions of the cluster centers that minimize the WCSS. One way to do this is to start with an initial set of cluster centers, calculate the WCSS for each possible set of cluster centers, and then choose the set with the lowest WCSS.\nYou can use the k-means algorithm to find the cluster centers that minimize the WCSS.\nSOLUTION: The first iteration of the k-means algorithm has assigned the following points to the three clusters:C1: {(0,6), (6,0)}C2: {(2,2), (4,4), (6,6)}C3: {(5,5), (7,7)}The within-cluster sum of squares is given by the following sum: 6 + 4 + 2 = 12.So, the cluster centers that minimize the WCSS are (0,0), (48,48), and (35,35)."}
{"question": "Any set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. Which of the following is NOT complete?", "choices": [{"label": "A", "text": "{AND, NOT}"}, {"label": "B", "text": "{NOT, OR}"}, {"label": "C", "text": "{AND, OR}"}, {"label": "D", "text": "{NAND}"}], "answerKey": "C", "model_answer": "LECTURE: A complete set of Boolean operators is one that is sufficient to represent all Boolean expressions.\nA Boolean expression is a boolean expression.\nA complete set of Boolean operators is one that is able to express any boolean expression.\nThere are several ways to define a complete set of Boolean operators. One way is to use the following rules:\nLemma: A set of Boolean operators is complete if and only if it is possible to use the operators in the set to express any Boolean expression that can be written using the logical operators AND, OR, and NOT.\nProof: Follow the steps below.\nStep 1: Define a set of Boolean operators.\nA set of Boolean operators is complete if and only if it is possible to use the operators in the set to express any Boolean expression that can be written using the logical operators AND, OR, and NOT.\nStep 2: Use the logical operators AND, OR, and NOT to write an arbitrary Boolean expression.\nStep 3: Use the set of Boolean operators to write the Boolean expression.\nThe set of operators must be able to express the Boolean expression.\nStep 4: Check if the set of operators is complete.\nTo do this, try to use the set of operators to express a Boolean expression that cannot be written using the logical operators AND, OR, and NOT. If you can do this, then the set of operators is not complete."}
{"question": "Consider the collection of all undirected graphs with 10 nodes and 6 edges. Let M and m, respectively, be the maximum and minimum number of connected components in any graph in the collection. If a graph has no selfloops and there is at most one edge between any pair of nodes, which of the following is true?", "choices": [{"label": "A", "text": "M = 10, m = 10"}, {"label": "B", "text": "M = 10, m = 1"}, {"label": "C", "text": "M = 7, m = 4"}, {"label": "D", "text": "M = 6, m = 4"}], "answerKey": "C", "model_answer": "SOLUTION: In a graph with 10 nodes and no self-loops, each edge connects two distinct nodes. Since there are 10 nodes, each edge can connect at most one pair of nodes. So, each graph in the collection has one connected component.\nThe minimum number of connected components is 1, and the maximum number is 10. So, M = 10 and m = 1."}
{"question": "Resolution theorem proving for showing that a formula of propositional logic is not satisfiable has which of the following properties?\nI. It is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nII. It is a complete proof system in the sense that there is a proof of unsatisfiability for every unsa tisfiable formula of propositional logic.\nIII. It is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "C", "model_answer": "SOLUTION: Proofs that a formula is unsatisfiable are called unsatisfiability proofs.\nA resolution proof is a proof that a formula is unsatisfiable.\nSo, a resolution proof has the property that it is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nThis means that a resolution proof can show that a formula is unsatisfiable, but it cannot show that a formula is satisfiable.\nA resolution proof is a complete proof system in the sense that there is a proof of unsatisfiability for every unsatisfiable formula of propositional logic.\nThis means that if a formula is unsatisfiable, then it has a resolution proof.\nA resolution proof is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.\nThis means that the length of a proof that a formula is unsatisfiable is never too long, and can be quite short."}
{"question": "Which of the following statements describe(s) properties of a purely segmented memory system?\nI. It divides memory into units of equal size.\nII. It permits implementation of virtual memory.\nIII. It suffers from internal fragmentation.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "B", "model_answer": "SOLUTION: In a purely segmented memory system, memory is divided into units of equal size. This property allows multiple programs to access memory without interfering with each other.\nA purely segmented memory system does not support virtual memory. In a purely segmented memory system, each program has its own, separate code and data sections. The program's code and data are loaded into memory at the same time, and they stay in the same location in memory.\nA purely segmented memory system can suffer from internal fragmentation. Internal fragmentation occurs when a program is loaded into memory, but some of the memory is not used. This can happen when a program is updated or changed, and the old, unused parts of the program remain in memory."}
{"question": "Which of the following statements about floating-point arithmetic is NOT true?", "choices": [{"label": "A", "text": "It is inherently nonassociative because some numbers have no exact representation."}, {"label": "B", "text": "It is inherently nonassociative because there have to be upper and lower bounds on the size of numbers."}, {"label": "C", "text": "Associativity can be achieved with appropriate roundoff conventions."}, {"label": "D", "text": "Some rational numbers have no exact representation."}], "answerKey": "C", "model_answer": "SOLUTION: Floating-point arithmetic is based on representing numbers as distances from the origin of a floating-point number line. The exact method used to represent floating-point numbers affects the associativity of arithmetic operations.\nTo determine whether a representation is associative, you need to look at the order in which operations are performed. In the context of floating-point arithmetic, this means looking at the order in which numbers are transformed and rounded.\nAssociativity can be achieved with appropriate rounding conventions. The ordering of operations is not important when the same rounding convention is used.\nSome rational numbers have no exact representation as floating-point numbers. This is a result of the way floating-point numbers are represented, not of the associativity of arithmetic operations."}
{"question": "Suppose sharing of tiles in a multilevel directory structure is achieved with directory entries that are links pointing to a node containing information about a shared file. Information in this node includes (1) the owner of the file, (2) a count of the number of links to the tile, and (3) the disk block numbers of the file. What is a primary drawback to this approach to sharing?", "choices": [{"label": "A", "text": "If the owner modifies the file, another user who does not share will see the changes."}, {"label": "B", "text": "If the owner renames the file, other users will not be able to access it."}, {"label": "C", "text": "If the owner is allowed to delete a file, dangling links may result."}, {"label": "D", "text": "If any user who shares the file appends to it, others who share it will not be able to access the new disk blocks."}], "answerKey": "C", "model_answer": "SOLUTION: The approach described above is similar to a method called hard links. Hard links have a primary drawback: dangling links. A dangling link is a link to a file that is no longer in the directory. Dangling links can lead to errors or security problems. For example, consider the directory structure below.\n\u251c\u2500\u2500 file1\n\u2502   \u251c\u2500\u2500 link1\n\u2502   \u2514\u2500\u2500 link2\n\u2514\u2500\u2500 link3\nIf the owner of the file1 modifies the file, the link1 and link2 become dangling links. Other users who do not own the file1 will not be able to access the file1.\nIf the owner of the file1 renames the file, the link1 and link2 become dangling links. Other users who do not own the file1 will not be able to access the file1.\nIf the owner of the file1 is allowed to delete the file, the link1 and link2 become dangling links. Other users who do not own the file1 will not be able to access the file1.\nIf any user who shares the file1 appends to it, the link1 and link2 become dangling links. Other users who do not own the file1 will not be able to access the new disk blocks."}
{"question": "Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves. Which of the following data structures will allow mergesort to work in O(n log n) time?\nI. A singly linked list\nII. A doubly linked list\nIII. An array", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves.\nMergesort has the following time complexity:\nO(n log n)\nThis means that the running time of Mergesort is proportional to the size of the input (n) raised to the power of 3 (log n).\nTo understand why the time complexity is O(n log n), consider the following breakdown of the algorithm's steps:\n1. Step: Mergesort splits the input list into two equal parts.\n2. Step: Each of the two parts is sorted recursively.\n3. Step: The two sorted parts are merged.\n4. Step: The merged list is returned.\nThe worst-case time complexity of each step is as follows:\n1. Step: Splitting the list into two parts takes constant time.\n2. Step: Sorting a part of a list takes O(n log n) time.\n3. Step: Merging two sorted parts takes O(n) time.\n4. Step: Returning a list takes constant time.\nSo, the overall worst-case time complexity of Mergesort is O(n log n) + O(n) + constant = O(n log n).\nThis means that Mergesort has a good time complexity for large input sizes.\nSOLUTION: To use an array to implement Mergesort, you would need to write a script that uses the array to store the input list.\nThe script would need to handle the case where the input list is longer than the number of slots in the array.\nIf the input list is longer than the number of slots in the array, the script would need to allocate a new array with a larger size, copy the input list to the new array, and then continue the merge process using the new array.\nThis could add significant overhead to the algorithm."}
{"question": "If p(x) is the minimal-degree interpolating polynomial for the real-valued function f(x) at the n + 1 distinct real numbers x0, .... xn what is the maximum possible degree of p(x)?", "choices": [{"label": "A", "text": "n"}, {"label": "B", "text": "n + 1"}, {"label": "C", "text": "n + 2"}, {"label": "D", "text": "2n"}], "answerKey": "A", "model_answer": "SOLUTION: The degree of a polynomial is the highest power of x that the polynomial has. The minimal-degree interpolating polynomial for f at the n+1 points x0, ..., xn has degree less than or equal to n.\nSo, the maximum possible degree of p(x) is n."}
{"question": "An internal hash table has 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is", "choices": [{"label": "A", "text": "3"}, {"label": "B", "text": "8"}, {"label": "C", "text": "10"}, {"label": "D", "text": "13"}], "answerKey": "A", "model_answer": "SOLUTION: The key 8 is inserted into the hash table. The other keys are not.\nThe hash function h(i) = i mod 5 is used. So, the key 8 is hashed to bucket 1.\nThe other keys are hashed as follows: 13 to 3, 24 to 4, and 10 to 3.\nBucket 2 is not tried."}
{"question": "TCP protocol is responsible (among other things) for", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "C", "model_answer": "SOLUTION: TCP stands for Transmission Control Protocol. It is a transport layer protocol that is used to guarantee reliable, ordered delivery of data between two machines.\nOne of the key functions of TCP is to provide reliable delivery of packets between directly connected machines. This is because TCP is responsible for dealing with differences in the underlying network architecture and ensuring that packets are delivered in the correct order.\nTCP can also be used to reliably deliver large messages (such as files) between machines that are not necessarily directly connected. This is because TCP can break a message up into smaller packets and guarantee the delivery of each packet.\nRouting packets through the network is the job of the network layer, not the transport layer. The network layer is responsible for determining the best path for a packet to take through an IP network.\nDealing with differences among operating system architectures is the job of the application layer, not the transport layer. The application layer is responsible for providing applications with a way to access the network."}
{"question": "Let A and B be two sets of words (strings) from \u03a3*, for some alphabet of symbols \u03a3. Suppose that B is a subset of A. Which of the following statements must always be true of A and B ?\nI. If A is finite, then B is finite.\nII. If A is regular, then B is regular.\nIII. If A is context-free, then B is context-free.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "SOLUTION: A finite set is a set with a finite number of elements. A set is regular if it includes each element of \u03a3 exactly once. A set is context-free if it does not contain the string 0101... as a substring.\nIf A is finite, then B is also finite.\nIf A is regular, then B is regular.\nIf A is context-free, then B is context-free.\nThese statements are all true of the sets A and B."}
{"question": "For all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings. Which of the following is true?", "choices": [{"label": "A", "text": "a^M = a"}, {"label": "B", "text": "(ax)^M = (xa)^M"}, {"label": "C", "text": "(xy)^M = y^Mx^M"}, {"label": "D", "text": "None of the above"}], "answerKey": "D", "model_answer": "SOLUTION: Look at the function definition.\nFor all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings.\nThen, (ax)^M = (xa)^M and (ay)^M = (ya)^M.\nSo, (xy)^M = (y^Mx^M)."}
{"question": "Which of the following is NOT a reasonable justification for choosing to busy-wait on an asynchronous event?", "choices": [{"label": "A", "text": "The wait is expected to be short."}, {"label": "B", "text": "A busy-wait loop is easier to code than an interrupt handler."}, {"label": "C", "text": "There is no other work for the processor to do."}, {"label": "D", "text": "The program executes on a time-sharing system."}], "answerKey": "D", "model_answer": "LECTURE: In an asynchronous program, an event can trigger a specific action. However, the program does not wait for the event to occur before moving on to the next action. Instead, the program continues to execute other actions while waiting for the event. To ensure that the program does not miss the event, it uses a mechanism called a busy-wait loop.\nA busy-wait loop is a loop that polls the status of the event. The loop checks the status of the event repeatedly. While the loop is running, the program does not do any other work.\nThere are several reasons why a program might choose to use a busy-wait loop instead of an interrupt handler:\nA busy-wait loop is easier to code than an interrupt handler.\nThere is no other work for the processor to do.\nA busy-wait loop can be used in a non-real-time program.\nThe program executes on a time-sharing system.\nSOLUTION: In a time-sharing system, multiple programs share the same processor. Each program is allowed to use the processor for a short period of time, called a time slice. While executing on a time-sharing system, a program does not need to use a busy-wait loop to wait for an asynchronous event. The program can do other work while waiting for the event."}
{"question": "The language {ww | w in (0 + 1)*} is", "choices": [{"label": "A", "text": "not accepted by any Turing machine"}, {"label": "B", "text": "accepted by some Turing machine, but by no pushdown automaton"}, {"label": "C", "text": "accepted by some pushdown automaton, but not context-free"}, {"label": "D", "text": "context-free, but not regular"}], "answerKey": "B", "model_answer": "SOLUTION: Whether a language is regular or not is independent of whether it is accepted by some Turing machine or some pushdown automaton.\nA language is regular if and only if it can be recognized by a finite automaton.\nA finite automaton is a machine that has a finite number of states and transitions.\nA Turing machine is a machine that has a tape and a finite number of states and transitions.\nA pushdown automaton is a machine that has a stack and a finite number of states and transitions.\nSo, the language {ww | w in (0 + 1)*} is not accepted by any Turing machine."}
{"question": "Which of the following statements about Ethernets is typically FALSE?", "choices": [{"label": "A", "text": "Ethernets use circuit switching to send messages."}, {"label": "B", "text": "Ethernets use buses with multiple masters."}, {"label": "C", "text": "Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly."}, {"label": "D", "text": "Networks connected by Ethernets are limited in length to a few hundred meters."}], "answerKey": "A", "model_answer": "SOLUTION: Ethernets use circuit switching to send messages.\nEthernet protocols use a collision-detection method to ensure that messages are transmitted properly.\nNetworks connected by Ethernets are limited in length to a few hundred meters.\nBuses with multiple masters can lead to collisions."}
{"question": "Let P be a procedure that for some inputs calls itself (i.e., is recursive). If P is guaranteed to terminate, which of the following statements must be true?\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: Procedures can be written to call themselves recursively. When a procedure calls itself, the procedure that is doing the calling is said to be on one execution path, and the procedure that is called is said to be on another execution path.\nA procedure has a local variable if the procedure uses the variable within its own code. The value of a local variable is not saved between calls to the procedure.\nA procedure has an execution path where it does not call itself if the procedure follows a path where it does not call itself.\nA procedure refers to a global variable if the procedure uses the same variable within different parts of the procedure. A procedure has at least one parameter if the procedure has a formal parameter that is used within the body of the procedure.\nIf a procedure has a local variable, the variable is not saved between calls to the procedure. So, a local variable does not contribute to the procedure's ability to terminate.\nIf a procedure has an execution path where it does not call itself, then the procedure is not recursive. So, this statement does not tell you that the procedure has a local variable, refers to a global variable, or has at least one parameter.\nIf a procedure is not recursive, then it does not have any execution paths. So, this statement is not true.\nIf a procedure has a local variable, then the variable is not saved between calls to the procedure. So, a local variable does not contribute to the procedure's ability to terminate.\nIf a procedure has an execution path where it does not call itself, then the procedure is not recursive. So, this statement does not tell you that the procedure has a parameter.\nIf a procedure does not have any parameters, then it does not have at least one parameter. So, this statement is not true.\nIf a procedure refers to a global variable, then the variable is used within the procedure. So, this statement does not tell you that the procedure has a local variable, refers to a global variable, or has at least one parameter."}
{"question": "Which of the following comes closest to being a perfectly secure encryption scheme?", "choices": [{"label": "A", "text": "The Caesar Cipher, a substitution cipher"}, {"label": "B", "text": "DES (Data Encryption Standard), a symmetric-key algorithm"}, {"label": "C", "text": "Enigma, a transposition cipher"}, {"label": "D", "text": "One-time pad"}], "answerKey": "D", "model_answer": "SOLUTION: A perfectly secure encryption scheme would prevent any unauthorized access to plaintext.\nThe One-time pad is a perfectly secure encryption scheme. It is a symmetric-key algorithm, and it is impossible to break by any conventional means."}
{"question": "Of the following problems concerning a given undirected graph G, which is currently known to be solvable in polynomial time?", "choices": [{"label": "A", "text": "Finding a longest simple cycle in G"}, {"label": "B", "text": "Finding a shortest cycle in G"}, {"label": "C", "text": "Finding ALL spanning trees of G"}, {"label": "D", "text": "Finding a largest clique in G"}], "answerKey": "B", "model_answer": "SOLUTION: A longest simple cycle in a graph is a cycle that is longer than any other cycle in the graph. A shortest cycle in a graph is a cycle that is shorter than any other cycle in the graph.\nA graph with a largest clique is a graph in which a clique is as large as possible.\nA spanning tree of a graph is a subgraph that is a tree and contains all of the vertices of the graph.\nFinding a largest clique in a graph is currently known to be solvable in polynomial time.\nFinding a shortest cycle in a graph is part of the famous traveling salesman problem, which is known to be NP-hard. So, finding a shortest cycle in a graph is not currently known to be solvable in polynomial time.\nFinding all spanning trees of a graph is a classic problem in graph theory. It is known that this problem can be solved in polynomial time."}
{"question": "The IP protocol is primarily concerned with", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "A", "model_answer": "LECTURE: The Internet Protocol (IP) is a network protocol. Network protocols are concerned with how devices communicate with each other over a network.\nRouting packets through the network is an essential function of the Internet Protocol. This is because, in order for two devices to communicate with each other, packets must be sent through the network to the destination device.\nReliable delivery of packets between directly connected machines is a key feature of the Internet Protocol. This ability to deliver packets reliably is a primary reason why the Internet Protocol has become so successful.\nReliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected is a key feature of the Internet Protocol. This ability to deliver large messages reliably is a primary reason why the Internet Protocol has become so successful.\nDealing with differences among operating system architectures is not a primary concern of the Internet Protocol. The Internet Protocol is an open standard that is designed to be implemented on a wide variety of operating system architectures."}
{"question": "Of the following, which best approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N?", "choices": [{"label": "A", "text": "1/K"}, {"label": "B", "text": "K-1/K"}, {"label": "C", "text": "log_10 (1/N)"}, {"label": "D", "text": "N-1/m"}], "answerKey": "A", "model_answer": ""}
{"question": "Consider a computer system in which processes can request and release one or more resources. Once a process has been granted a resource, the process has exclusive use of that resource until it is released. If a process requests a resource that is already in use, the process enters a queue for that resource, waiting until the resource is available. Which of the following will NOT deal effectively with the problem of deadlock?", "choices": [{"label": "A", "text": "Giving priorities to processes and ordering the wait queues by priority"}, {"label": "B", "text": "Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all"}, {"label": "C", "text": "Numbering the resources and requiring that processes request resources in order of increasing number"}, {"label": "D", "text": "Having processes time out and restart after a random interval of waiting"}], "answerKey": "A", "model_answer": "SOLUTION: Deadlock occurs when a process is waiting for one or more resources and those resources are being used by other processes. In order to deal effectively with the problem of deadlock, any solution that prevents processes from waiting for unavailable resources will help.\nGiving priorities to processes and ordering the wait queues by priority might help, but it is not a complete solution. A high-priority process that requests a resource it does not need may still cause a deadlock.\nHaving a process request all its required resources when it first begins and restarting if it cannot obtain them all might help, but it is not a complete solution. This approach might help to avoid deadlocks, but it is not guaranteed to do so.\nNumbering the resources and requiring that processes request resources in order of increasing number might help, but it is not a complete solution. This approach might help to avoid deadlocks, but it is not guaranteed to do so.\nHaving processes time out and restart after a random interval of waiting may help to avoid deadlocks, but it is not a complete solution. This approach might help to avoid deadlocks, but it is not guaranteed to do so."}
{"question": "\"Magic memory\"' has two operations: Read and Clear. Both are indivisible and mutually exclusive. Clear sets the magic memory to zero. Read returns a value that represents the number of Read operations since the last Clear operation. Which of the following is (are) true of \"Magic memory\"?\nI. It can provide the functionality of an atomic Test-and-Set.\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nIII. It is only useful on a multiprocessor.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "SOLUTION: A magic memory is a type of synchronization mechanism that can be used to coordinate processes running on a shared-memory multiprocessor. It has two operations: Read and Clear. Both operations are indivisible and mutually exclusive. The Read operation returns a value that represents the number of Read operations since the last Clear operation.\nA magic memory is only useful on a multiprocessor. It can provide the functionality of an atomic Test-and-Set. It is only useful on a multiprocessor."}
{"question": "Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?", "choices": [{"label": "A", "text": "Abstract Syntax Tree (AST)"}, {"label": "B", "text": "Attribute Grammar"}, {"label": "C", "text": "Symbol Table"}, {"label": "D", "text": "Semantic Stack"}], "answerKey": "C", "model_answer": "LECTURE: A symbol table is a data structure in a compiler that is responsible for managing information about variables and their attributes. It is used by the compiler to keep track of the variables that have been introduced by the user and to manage information about them, such as their types.\nWhen a variable is introduced, the compiler adds an entry to the symbol table for that variable. The entry in the symbol table includes the variable's name and its type. When the compiler parses a expression, it uses the symbol table to determine the type of an expression.\nAn abstract syntax tree (AST) is a data structure that is used to represent the syntactic structure of a program. It is constructed by a parser as it builds a parse tree. The AST is used by the compiler to determine the meaning of a program.\nAn attribute grammar is a set of production rules that describe the attributes of a programming language. An attribute grammar is used by a compiler to specify the semantic rules for a language.\nA semantic stack is a data structure that is used in a compiler to keep track of the current scope of variables. It is used to determine the meaning of a variable."}
{"question": "Which of the following algorithms has running time \u0398(n^2) in the worst case but \u0398(n log n) on average?", "choices": [{"label": "A", "text": "Bubblesort"}, {"label": "B", "text": "Mergesort"}, {"label": "C", "text": "Heapsort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "D", "model_answer": "LECTURE: An algorithm's running time is a measure of the algorithm's efficiency. The running time of an algorithm is determined by the number of steps the algorithm takes to complete.\nBig O notation is a way to describe an algorithm's running time. It tells you how the running time of an algorithm scales.\nFor example, if an algorithm has a running time of O(n), that means that the algorithm's running time increases as the input size increases.\nSOLUTION: Bubblesort has a running time of O(n^2). In the worst case, Bubblesort compares every pair of items in the list. So, its running time is \u0398(n^2).\nMergesort has a running time of O(n log n). In the average case, Mergesort compares n log n - 1 pairs of items. So, its running time is \u0398(n log n).\nHeapsort has a running time of O(n log n). In the worst case, Heapsort must compare every item in the list. So, its running time is \u0398(n log n).\nQuicksort has a running time of O(n log n). In the average case, Quicksort compares n log n - 1 pairs of items. So, its running time is \u0398(n log n)."}
{"question": "Languages with a structure that implements abstract data types (e.g., a C++ class) can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation). Which of the following statements about comparisons between direct and indirect representations is (are) true?\nI. Indirect representation noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following is NOT a property of bitmap graphics?", "choices": [{"label": "A", "text": "Fast hardware exists to move blocks of pixels efficiently."}, {"label": "B", "text": "Realistic lighting and shading can be done."}, {"label": "C", "text": "All line segments can be displayed as straight."}, {"label": "D", "text": "Polygons can be filled with solid colors and textures."}], "answerKey": "C", "model_answer": "LECTURE: A bitmap is a simple graphical image that is made up of a grid of pixels. Some of the properties of bitmap graphics include:\nFast hardware exists to move blocks of pixels efficiently.\nRealistic lighting and shading can be done.\nAll line segments can be displayed as straight.\nPolygons can be filled with solid colors and textures.\nSome types of graphics are not bitmap graphics. For example, a fractal is a type of graphical image that is not made up of a grid of pixels. Fractals can be displayed in realistic 3D settings with lighting and shading.\nSOLUTION: Look at the properties of bitmap graphics.\nFast hardware exists to move blocks of pixels efficiently.\nPolygons can be filled with solid colors and textures.\nAll line segments can be displayed as straight.\nRealistic lighting and shading can be done."}
{"question": "Which of the following is true of interrupts?", "choices": [{"label": "A", "text": "They are generated when memory cycles are \"stolen\"."}, {"label": "B", "text": "They are used in place of data channels."}, {"label": "C", "text": "They can indicate completion of an I/O operation."}, {"label": "D", "text": "They cannot be generated by arithmetic operations."}], "answerKey": "C", "model_answer": ""}
{"question": "In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. Which of the following are true of such a tree?\nI. Worst-case search time is logarithmic in the number of nodes.\nII. Average-case search time is logarithmic in the number of nodes.\nIII. Best-case search time is proportional to the height of the tree.\nIV. The height of the tree is logarithmic in the number of nodes.", "choices": [{"label": "A", "text": "I and III only"}, {"label": "B", "text": "II and III only"}, {"label": "C", "text": "II and IV only"}, {"label": "D", "text": "I, II, and IV"}], "answerKey": "D", "model_answer": "SOLUTION: The height of a node in a height-balanced binary search tree is logarithmic in the number of nodes. This means that the height of the tree is logarithmic in the number of nodes.\nA height-balanced binary search tree has the property that the heights of the left and right descendents of any node differ by at most 1. This means that the height of the tree is at most double the height of the longest path from the root to a leaf node. In a tree with n nodes, the longest path from the root to a leaf node has length no more than log2 n. So, the height of the tree is at most 2 \u00d7 log2 n, which is logarithmic in n.\nWorst-case search time is logarithmic in the number of nodes. This means that the worst-case search time is proportional to the height of the tree. But the height of the tree is logarithmic in the number of nodes, so worst-case search time is logarithmic in the number of nodes.\nAverage-case search time is logarithmic in the number of nodes. This means that the average-case search time is proportional to the height of the tree. But the height of the tree is logarithmic in the number of nodes, so average-case search time is logarithmic in the number of nodes.\nBest-case search time is proportional to the height of the tree. This means that the best-case search time is logarithmic in the number of nodes."}
{"question": "Bob writes down a number between 1 and 1,000. Mary must identify that number by asking \"yes/no\" questions of Bob. Mary knows that Bob always tells the truth. If Mary uses an optimal strategy, then she will determine the answer at the end of exactly how many questions in the worst case?", "choices": [{"label": "A", "text": "1,000"}, {"label": "B", "text": "999"}, {"label": "C", "text": "500"}, {"label": "D", "text": "10"}], "answerKey": "D", "model_answer": "SOLUTION: Mary can use a binary search to find the answer. This is a well-known optimal strategy for finding a needle in a haystack.\nBob writes a number between 1 and 1,000. Mary can ask yes/no questions to find out if the number is even or odd.\nIf the number is odd, Mary can ask whether the last digit is 1, 3, 5, 7, or 9.\nIf the number is even, Mary can ask whether the last digit is 0, 2, 4, 6, or 8.\nAfter one question, Mary can eliminate all the numbers that are not possible.\nFor example, if the number is odd and the last digit is not 1, 3, 5, 7, or 9, then the number is 1.\nIf the number is even and the last digit is not 0, 2, 4, 6, or 8, then the number is 999.\nSo, Mary can identify the number in one question."}
{"question": "Which of the following is (are) true about virtual memory systems that use pages?\nI. The virtual address space can be larger than the amount of physical memory.\nII. Programs must be resident in main memory throughout their execution.\nIII. Pages correspond to semantic characteristics of the program.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "SOLUTION: A page is a unit of data that is used in virtual memory systems. It is a mapping of a virtual memory address to a particular location in secondary memory.\nThe virtual address space is the range of addresses that a program can use to access memory. It is larger than the amount of physical memory.\nPrograms do not have to be resident in main memory throughout their execution. This is because virtual memory allows the program to use an address in the virtual address space to access a page in secondary memory.\nPages correspond to semantic characteristics of the program. This means that pages can be used to optimize memory usage and access times. For example, a page of memory used by a game might be swapped out of main memory while the program is running, and then swapped back in when the game needs that memory again."}
{"question": "Which of the following is usually NOT represented in a subroutine's activation record frame for a stack-based programming language?", "choices": [{"label": "A", "text": "Values of local variables"}, {"label": "B", "text": "A heap area"}, {"label": "C", "text": "The return address"}, {"label": "D", "text": "Stack pointer for the calling activation record"}], "answerKey": "B", "model_answer": "LECTURE: A subroutine is a sequence of instructions that performs a specific task. Subroutines can be designed to take arguments, or inputs.\nWhen a subroutine is called, an activation record is created. An activation record contains information about the call, such as the values of the arguments passed to the subroutine. This information is stored in the activation record frame.\nThe activation record frame for a stack-based programming language typically includes the following fields:\n1. The values of the arguments passed to the subroutine.\n2. The return address, which is the address of the instruction that the subroutine should return to after it finishes executing.\n3. A stack pointer for the calling activation record.\n4. A heap area.\nA heap area is a region of memory that is used to dynamically allocate memory at runtime. So, a heap area is not usually represented in a subroutine's activation record frame."}
{"question": "Which of the following statements about a remote procedure call is true?", "choices": [{"label": "A", "text": "It is used to call procedures with addresses that are farther than 2^16 bytes away."}, {"label": "B", "text": "It cannot return a value."}, {"label": "C", "text": "It cannot pass parameters by reference."}, {"label": "D", "text": "It cannot call procedures implemented in a different language."}], "answerKey": "C", "model_answer": "SOLUTION: A remote procedure call (RPC) is a type of procedure call that is used to call procedures that are implemented in a different address space. An address space is a region of memory.\nProcedures that are farther than 2^16 bytes away cannot be called by a direct procedure call. But they can be called by an RPC. An RPC can call procedures with addresses that are farther than 2^16 bytes away.\nAn RPC can pass parameters by reference. When you pass a parameter by reference, you pass the parameter's memory address. The procedure can change the value of the parameter by using the memory address.\nAn RPC can return a value. An RPC can return a value by using a stack. A stack is a region of memory that is used for storing temporary data.\nAn RPC can call procedures implemented in a different language. Many programming languages are implemented in a way that makes it possible to use them in different environments. For example, the Java language is implemented in a way that makes it possible to run Java programs in many different environments. An RPC can call procedures that are implemented in a different language by using a language interpreter."}
{"question": "Of the following sorting algorithms, which has a running time that is LEAST dependent on the initial ordering of the input?", "choices": [{"label": "A", "text": "Insertion sort"}, {"label": "B", "text": "Quicksort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Selection sort"}], "answerKey": "C", "model_answer": "SOLUTION: Selection sort has a running time that is least dependent on the initial ordering of the input.\nSelection sort first finds the minimum element in the array and places it at the beginning of the array. It then finds the minimum of the remaining elements and inserts it in the second position. This process is repeated until the end of the array is reached.\nSince selection sort only looks at each element in the array once, its running time is not dependent on the initial ordering of the input."}
{"question": "A particular parallel program computation requires 100 seconds when executed on a single processor. If 40 percent of this computation is \"inherently sequential\" (i.e., will not benefit from additional processors), then the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are", "choices": [{"label": "A", "text": "20 and 10 seconds"}, {"label": "B", "text": "30 and 15 seconds"}, {"label": "C", "text": "50 and 25 seconds"}, {"label": "D", "text": "70 and 55 seconds"}], "answerKey": "D", "model_answer": "LECTURE: The amount of time a program takes to execute on a single processor is called the \"elapsed time.\"\nYou can use the following formula to calculate the elapsed time for a program:\nelapsed time = (time complexity) / (processor speed)\nA program's time complexity tells you how long the program will take to execute. A program's time complexity may include the following terms:\n1. O(1) complexity: This term represents a constant amount of time.\n2. O(n) complexity: This term represents a linear amount of time. For example, searching an unsorted list of size n takes O(n) time.\n3. O(n^2) complexity: This term represents a quadratic amount of time. For example, sorting a list of size n takes O(n^2) time.\n4. O(log n) complexity: This term represents a logarithmic amount of time. For example, binary search takes O(log n) time.\n\nSOLUTION: To execute a program on multiple processors, you can break the program into pieces that can be executed in parallel. The program's time complexity will include terms for each of the pieces.\nThe goal is to find the smallest possible elapsed time. This will happen when the program's time complexity has the following terms:\n1. O(1) complexity: This term represents a constant amount of time.\n2. O(log n) complexity: This term represents a logarithmic amount of time.\n3. O(n) complexity: This term represents a linear amount of time.\n\nThe theoretically best possible elapsed times for the program running with 2 and 4 processors are given by the following formulas:\nWith 2 processors, the program's time complexity is:\n2(O(1) + O(log n) + O(n)) = 2(1 + log n + n)\nSo, the theoretically best possible elapsed time with 2 processors is:\n2(1 + log n + n) / (2 * processor speed) = 1 + log n + n / processor speed\nWith 4 processors, the program's time complexity is:\n4(O(1) + O(log n) + O(n)) = 4(1 + log n + n)\nSo, the theoretically best possible elapsed time with 4 processors is:\n4(1 + log n + n) / (4 * processor speed) = 1 + log n + n / processor speed\nThe first thing you need to determine is the value of n. This can be done by looking at the number of cores available for parallel processing. The program can be executed in parallel on up to 4 cores. So, n is 4.\nThen, you need to calculate the value of log n. The base of the logarithm is 10. So, log 4 is 2.\nSo, the theoretically best possible elapsed times for the program running with 2 and 4 processors are:\n20 and 10 seconds: This answer choice is incorrect.\n30 and 15 seconds: This answer choice is incorrect.\n50 and 25 seconds: This answer choice is incorrect.\n70 and 55 seconds: This answer choice is incorrect."}
{"question": "Consider the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude. In which representation is there overflow from the addition of the integers 011000 and 011000?", "choices": [{"label": "A", "text": "Two's complement only"}, {"label": "B", "text": "Sign and magnitude and one's complement only"}, {"label": "C", "text": "Two's complement and one's complement only"}, {"label": "D", "text": "All three representations"}], "answerKey": "D", "model_answer": "LECTURE: A six-bit number can be represented in three ways: in sign-and-magnitude form, in one's complement form, or in two's complement form.\nThese three representations are equivalent. This means that any number that can be represented in one of these ways can also be represented in any of the other ways.\nSOLUTION: To determine which representations overflow, consider which bits are affected by adding 011000 and 011000.\nThe ones complement of 011000 is 100011. The sum of 011000 and 100011 is 111000. The bits that are set to 1 in 111000 are the same bits that are set to 1 in 011000. So, there is overflow in the sign-and-magnitude and one's complement representations, but not in the two's complement representation."}
{"question": "Of the following, which best characterizes computers that use memory-mapped I/O?", "choices": [{"label": "A", "text": "The computer provides special instructions for manipulating I/O ports."}, {"label": "B", "text": "I/O ports are placed at addresses on the bus and are accessed just like other memory locations."}, {"label": "C", "text": "To perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}, {"label": "D", "text": "Ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}], "answerKey": "B", "model_answer": ""}
{"question": "Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that", "choices": [{"label": "A", "text": "integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs"}, {"label": "B", "text": "P = NP"}, {"label": "C", "text": "even if P = NP, integer factorization is still likely not to be polynomial-time computable"}, {"label": "D", "text": "testing primality is computationally intractable"}], "answerKey": "A", "model_answer": "SOLUTION: Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that integer factorization is a hard problem, meaning that it is a problem whose solution requires a lot of computational effort.\nWhy is integer factorization a hard problem?\nThere are two main reasons why integer factorization is a hard problem.\nThe first reason is that integer factorization is a computationally intensive task. In order to factor large numbers, you need to perform a lot of calculations. As a result, it can take a long time to factor large numbers.\nThe second reason is that integer factorization is a search problem. There are many ways to factor a large number. You can try different approaches, and eventually, you will find a way to factor the number. But there are so many possible ways to factor a number that it is difficult to find a specific method."}
{"question": "Which of the following sets of bit strings CANNOT be described with a regular expression?", "choices": [{"label": "A", "text": "All bit strings whose number of zeros is a multiple of five"}, {"label": "B", "text": "All bit strings starting with a zero and ending with a one"}, {"label": "C", "text": "All bit strings with an even number of zeros"}, {"label": "D", "text": "All bit strings with more ones than zeros"}], "answerKey": "D", "model_answer": "LECTURE: Regular expressions are a powerful tool for describing patterns in text. They can describe patterns in bit strings (strings of 0s and 1s) as well.\nA regular expression describes a pattern that may contain wildcards. So, a regular expression can describe a set of bit strings.\nFor example, the regular expression 0\\*1 describes all bit strings that have a zero followed by zero or more 1s. This describes the set of all bit strings whose number of 1s is greater than their number of 0s.\n\nSOLUTION: To describe a set of bit strings, a regular expression may contain wildcards. But the set of all bit strings with an even number of zeros does not contain any wildcards. So, it can be described with a regular expression.\nAll bit strings with an even number of zeros has an even number of 0s. So, it can be described with the regular expression 0\\.\nThe set of all bit strings whose number of zeros is a multiple of five does not contain an even number of zeros. So, it cannot be described with a regular expression that matches even numbers of zeros.\nAll bit strings starting with a zero and ending with a one starts and ends with a 1. So, it can be described with the regular expression 0\\.\nAll bit strings with more ones than zeros has more 1s than 0s. So, it can be described with the regular expression 1\\."}
{"question": "Which of the following conditions can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac)?\nI. At least three of p_1, p_2, p_3, p_4 are true.\nII. Exactly three of p_1, p_2, p_3, p_4 are true.\nIII. An even number of p_1, p_2, p_3, p_4 are true.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "SOLUTION: I. The formula for I is p_1 \u2227 p_2 \u2227 p_3 \u2227 p_4. This formula can be made with the connectives \u2227, \u2228, and \u00ac.\nII. The formula for II is (p_1 \u2227 p_2) \u2227 (p_3 \u2227 p_4). This formula can be made with the connectives \u2227, \u2228, and \u00ac.\nIII. The formula for III is (p_1 \u2227 p_2 \u2227 p_3) \u2227 (p_4 \u2227 \u00acp_1 \u2227 \u00acp_2 \u2227 \u00acp_3). This formula can be made with the connectives \u2227, \u2228, and \u00ac."}
{"question": "Two alternatives for interconnecting a set of processors with bidirectional links are (1) the fully interconnected network, in which each processor is directly connected to every other processor, and (2) the ring network, in which each processor is connected to two other processors. The worst-case path length for a network is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes. For each type of interconnection of n processors, a figure of merit can be formed as the product of the number of links required for the network times the worst-case path length connecting any two processors. The ratio of this figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is", "choices": [{"label": "A", "text": "1/(n^2)"}, {"label": "B", "text": "1/(n(n-1))"}, {"label": "C", "text": "1/n"}, {"label": "D", "text": "(n-1)/n"}], "answerKey": "D", "model_answer": "LECTURE: A network is a set of nodes connected by links. In a network, the nodes represent the processors, and the links represent the connections between them. The worst-case path length is a measure of the maximum distance between two processors.\nFor the fully interconnected network and the ring network, the numbers of links and the worst-case path length between any two processors are both equal to n^2 and n, respectively. So, for even n > 2, the figure of merit for the fully interconnected network is 1/n, and the figure of merit for the ring network is (n-1)/n.\nSo, for even n > 2, the ratio of the figure of merit for the fully interconnected network compared to that of the ring network is:\n1/n / ((n-1)/n) = 1/n \\* n/(n-1) = 1/(n(n-1))."}
{"question": "For a connected, undirected graph G = (V, E), which of the following must be true?\nI. \u03a3_{v\u2208V} degree(v) is even.\nII. |E| \u2265 |V| \u2212 1\nIII. G has at least one vertex with degree 1.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of vertices and edges. A connected graph is a graph that remains connected when any pair of vertices are removed. An undirected graph is a graph in which each edge is connected to exactly two vertices.\nThe degrees of a graph's vertices tell you how many edges connect to each vertex. The degree of a vertex is even if it is connected to an even number of edges, and the degree of a vertex is odd if it is connected to an odd number of edges.\nSOLUTION: A graph is connected and undirected. So, by definition, the sum of the degrees of all of the graph's vertices is even.\nThe number of edges in a graph is equal to the number of vertices plus the number of edges. So, |E| is equal to |V| + |E| - |V|. This means that |E| is at least |V|.\nA graph has at least one vertex with degree 1 if and only if there is a vertex in the graph with exactly one edge connected to it. Such a vertex must be part of an edge. So, by definition, |E| is greater than or equal to |V| - 1.\nI. is correct.\nII. is incorrect.\nThe fact that |E| is at least |V| does not mean that |E| is exactly |V| - 1. So, II is not correct.\nIII. is incorrect.\nA graph has at least one vertex with degree 1 if and only if there is a vertex in the graph with exactly one edge connected to it. Such a vertex must be part of an edge. So, by definition, |E| is greater than or equal to |V| - 1.\nThe fact that |E| is greater than or equal to |V| - 1 does not mean that |E| is exactly equal to |V| - 1. So, III is not correct."}
{"question": "In multiprogrammed systems it is advantageous if some programs such as editors and compilers can be shared by several users. Which of the following must be true of multiprogrammed systems in order that a single copy of a program can be shared by several users?\nI. The program is a macro.\nII. The program is recursive.\nIII. The program is reentrant.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "C", "model_answer": "LECTURE: A program is reentrant if it can be called from within itself. A program is recursive if it calls itself.\nMultiprogrammed systems can use one of two methods to share programs:\n1. Fork: One user is assigned a copy of the program. The program is executed in a separate memory space, and the user's input is read and stored separately.\n2. Join: Several users are assigned parts of the same copy of the program. The program is executed in a shared memory space, and the users' inputs are read and stored in the shared memory.\nIn order for a program to be shareable, it must not use any shared variables that are not part of the program's memory space. This means that the program must not use any global variables.\nThe compiler can determine whether a program is reentrant. If the compiler determines that a program is reentrant, it can be shared.\nA macro is a set of instructions that are replaced by a single instruction. Macros are not reentrant. Macros can be shared, but they can also cause problems in a multiprogrammed system."}
{"question": "Which of the following decimal numbers has an exact representation in binary notation?", "choices": [{"label": "A", "text": "0.1"}, {"label": "B", "text": "0.2"}, {"label": "C", "text": "0.3"}, {"label": "D", "text": "0.5"}], "answerKey": "D", "model_answer": "LECTURE: A binary number is a representation of a decimal number in base 2. That is, a binary number is a string of the digits 0 and 1.\nTo write a decimal number in binary notation, you can use the following algorithm:\n1. Write down the decimal number.\n2. Count the number of digits in the decimal number.\n3. Write down 0's as necessary so that the total number of digits in the binary number is equal to the count from step 2.\n4. Write down 1's as the remaining digits in the binary number.\nThe binary notation of a decimal number can be stored in a variable. For example:\nvar binary = '110101';\n// The binary notation of the decimal number 30 is 110101.\nIf you want to convert a binary number to a decimal number, you can use the following algorithm:\n1. Interpret the binary number as a string of 0's and 1's.\n2. Add up the value of the 0's.\nThe value of each 0 is 0.\nThe value of each 1 is 1.\n3. Divide the sum from step 2 by 2.\nThis will give you the original decimal number.\nFor example:\nvar binary = '110101';\nvar decimal = 2 + 1 + 0 + 1 = 4;\n// The binary notation of the decimal number 4 is 110101."}
{"question": "Function signatures describe the types of the arguments to a function as well as the return value of the function. For instance, the addition function on reals has a signature of\nadd : real x real -> real\nsince it takes two real numbers and returns a real number. But, for a language that allows functions as return values, addition could be considered to have the signature\nadd : real -> (real -> real)\nwhich means that add takes a single real (the first operand) and returns a new function that itself takes a single real (the second operand) and returns a real (the result). This process of reducing a function with multiple arguments to a function with fewer arguments is called currying. Which of the following is correct?", "choices": [{"label": "A", "text": "Currying can be applied to any function to the point where it has exactly one input argument."}, {"label": "B", "text": "Currying cannot be applied to functions of more than two arguments."}, {"label": "C", "text": "Currying cannot be applied to functions that return functions as arguments."}, {"label": "D", "text": "Currying cannot be applied w functions that haw arguments that are functions."}], "answerKey": "A", "model_answer": ""}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-back policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2000"}], "answerKey": "A", "model_answer": ""}
{"question": "In which of the following representations of numbers by 8-bit words is the addition of the integers 109 and -42 within range?\nI. One's complement\nII. Two's complement\nIII. Sign and magnitude", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": ""}
{"question": "If a malicious process is granted temporary administrator-level access to a system", "choices": [{"label": "A", "text": "the threat is over as soon as the process is killed"}, {"label": "B", "text": "the threat is over after the operating system is rebooted"}, {"label": "C", "text": "the thread is over after rebooting the machine and replacing files that show a virus infection"}, {"label": "D", "text": "the threat is often permanent until the entire disk is wiped clean"}], "answerKey": "D", "model_answer": "LECTURE: A process is a program that is running. A thread is a individual path of execution within a process.\nWhen a process is granted temporary administrator-level access to a system, it can do many things that it could not do before, including modifying the system's files and settings.\nIf the process is a virus, it may be able to use this access to spread to other machines.\nIf the process is a Trojan, it may be able to use this access to modify the system's files or settings in harmful ways.\nIf the process is a worm, it may be able to use this access to spread to other machines.\nIf the process is a rootkit, it may be able to use this access to hide its files and settings from the system's owner.\nIf a process is granted temporary administrator-level access to a system, the threat is over after the operating system is rebooted.\nRebooting the machine will end all processes and threads. This includes the malicious process that was granted temporary administrator-level access."}
{"question": "Which of the following statements about horizontal versus vertical microarchitecture is (are) true?\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nII. Horizontal microinstructions are unencoded.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: The fundamental difference between horizontal and vertical microarchitecture is that a horizontal microinstruction sets up a stream of data to be processed, while a vertical microinstruction processes a stream of data. This difference is reflected in the way fetch addresses are calculated.\nFor a horizontal microinstruction, the next address is calculated based on the current address and the number of words to be processed. For a vertical microinstruction, the next address is calculated based on the current address and the length of the instruction.\nBecause a horizontal microinstruction sets up a stream of data to be processed, the program for a horizontal architecture requires more time steps than a program for a vertical architecture.\nHorizontal microinstructions are unencoded. This means that each microinstruction is stored at a unique memory address.\nHorizontal microinstructions usually have a single opcode and multiple operand specifiers. This is in contrast to vertical microinstructions, which usually have multiple opcodes and a single operand specifier.\nThe opcode is the part of an instruction that tells the processor what operation to perform. Vertical microinstructions have multiple opcodes, which means that each vertical microinstruction can perform multiple operations. In contrast, horizontal microinstructions have a single opcode, which means that each horizontal microinstruction can perform only one operation.\nTo perform a operation on data, a horizontal microinstruction specifies the location of the data. This is done with the operand specifiers.\nSOLUTION: II. Unencoded instructions do not need to be translated. They can be fetched and executed as is. So, horizontal microinstructions require fewer time steps than vertical microinstructions."}
{"question": "A \"strictly binary tree\" is a binary tree in which every node that is not a leaf has two children. Suppose that for a class of strictly binary trees there exists c > 0 such that, for any tree in the class, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. Which of the following best characterizes the height h of any tree in this class, where N is the number of nodes in the tree and N > 1 ?", "choices": [{"label": "A", "text": "h <= log2(N)"}, {"label": "B", "text": "h = 1/c * log2(N)"}, {"label": "C", "text": "h < c log2(N)"}, {"label": "D", "text": "h > c log2(N)"}], "answerKey": "C", "model_answer": "SOLUTION: The ratio of the lengths of any two root-to-leaf paths is bounded above by c, which means that the height of the tree is bounded above by c log2(N).\nSo, h < c log2(N)."}
{"question": "Which of the following sorting algorithms has average-case and worst-case running times of O(n log n)?", "choices": [{"label": "A", "text": "Bubble sort"}, {"label": "B", "text": "Insertion sort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "C", "model_answer": "SOLUTION: All of the sorting algorithms have worst-case running times of O(n log n)."}
{"question": "Consider the following equations concerning a stack module that has the operations Push, Pop, Top, and IsEmpty. Which of the equations does NOT represent the conventional semantics of a stack?", "choices": [{"label": "A", "text": "IsEmpty(Push(Stack,Elem)) = true"}, {"label": "B", "text": "Pop(Push(Stack,Elem)) = Stack"}, {"label": "C", "text": "Top(Push(Stack,Elem)) = Elem"}, {"label": "D", "text": "IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false"}], "answerKey": "A", "model_answer": "LECTURE: Equations are expressions that define mathematical concepts. They can contain one or more operations and variables.\nConventions are standards or rules. Conventionally, equal signs mean \"is equal to.\" So, for any variables x, x=y means that x has the value y.\nSOLUTION: The purpose of a stack is to keep track of elements in a particular order. The conventional way that a stack does this is by using the Top, Pop, and IsEmpty operations.\nThe Top operation returns the element that was added to the stack most recently. The Pop operation removes the element that was added to the stack most recently. The IsEmpty operation checks whether the stack is empty.\nThe equations do the following:\nIsEmpty(Push(Stack,Elem)) = true: This equation defines IsEmpty in terms of Push. It says that the stack is empty if and only if the Push operation has not added any elements to the stack.\nPop(Push(Stack,Elem)) = Stack: This equation defines Pop in terms of Push. It says that the element that was added to the stack most recently is on the top of the stack.\nTop(Push(Stack,Elem)) = Elem: This equation defines Top in terms of Push. It says that the element that was added to the stack most recently is the top of the stack.\nIsEmpty(Push(Push(Stack,Elem1),Elem2)) = false: This equation defines IsEmpty in terms of Push. It says that the stack is not empty if and only if the Push operation has added at least one element to the stack."}
{"question": "Assume that any assignment statement can be executed in unit time. If as many identical processors as needed are used, what is the minimum number of time units needed to execute the assignments\nA := B + C\nB := A - B\nC := A * E\nD := A/F\nE := B - C\nF := A + B\nwith the same result as if the assignments were executed in the order shown?", "choices": [{"label": "A", "text": "1"}, {"label": "B", "text": "2"}, {"label": "C", "text": "3"}, {"label": "D", "text": "4"}], "answerKey": "C", "model_answer": ""}
{"question": "Two expressions E and F are said to be unifiable if there are substitutions for the variables of E and F that make the expressions lexically identical. In the following three expressions, only w, x, y, and z are variables.\nI. f(w,w)\nII. f(x,1)\nIII. f(y,g(z))\nWhich pairs of these expressions is (are) pairs of unifiable expressions?", "choices": [{"label": "A", "text": "(I, II) only"}, {"label": "B", "text": "(I, III) only"}, {"label": "C", "text": "(II, III) only"}, {"label": "D", "text": "(I, II) and (I, III) only"}], "answerKey": "D", "model_answer": "LECTURE: Here are some examples of unifiable expressions.\nf(x,y) and g(x,y) are unifiable.\nf(a,b) and g(a,c) are not unifiable.\nh(x) and k(y) are not unifiable.\nIf two expressions are unifiable, then they have the same type. A type is a set of expressions that are unifiable.\nThe type of an expression contains all the expressions that are of the same type as the expression.\nSOLUTION: Each of the three expressions has a different type. There are not enough types to make all three expressions unifiable.\nSo, the only pairs that are pairs of unifiable expressions are (I, II) and (I, III)."}
{"question": "Which of the following instruction-set features is NOT generally considered an obstacle to aggressive pipelining of an integer unit?", "choices": [{"label": "A", "text": "Condition codes set by every instruction"}, {"label": "B", "text": "Variable-length encoding of instructions"}, {"label": "C", "text": "Instructions requiring widely varying numbers of cycles to execute"}, {"label": "D", "text": "Several different classes (sets) of registers"}], "answerKey": "D", "model_answer": "LECTURE: Pipelining is a technique that is widely used in processors to increase performance. It is based on the idea of breaking a program into a series of steps, or stages, and executing each step in a separate pipeline.\nPipelining allows a processor to begin executing a new instruction before it has finished executing the previous instruction. This is possible because each stage of the pipeline is responsible for a different step in the overall execution process. For example, the first stage might fetch the next instruction, the second stage might decode it, and the third stage might execute it.\nOne potential obstacle to pipelining is the need to set condition codes. Condition codes are used to indicate the outcome of a comparison, an operation that has no result, or an operation that has a result that is difficult to represent. Many instructions set condition codes. As a result, the processor must ensure that condition codes are set correctly. This can be a challenge in a pipelined processor, because condition codes may need to be set by instructions that are in different stages of the pipeline.\nAnother potential obstacle to pipelining is the need to use a different set of registers for each instruction. Instructions that require different registers may need to be in different stages of the pipeline. This can increase the complexity of the processor.\nInstructions that require widely varying numbers of cycles to execute can also be a challenge for pipelining. If an instruction takes a large number of cycles to execute, it may block the pipeline. The pipeline can become blocked if each stage of the pipeline is responsible for a different instruction, and each instruction takes a different number of cycles to execute.\nFinally, variable-length encoding of instructions may also be a challenge for pipelining. Variably encoded instructions may take different amounts of time to decode. This can make it difficult to schedule these instructions in the pipeline.\nSOLUTION: To increase the performance of an integer unit, it is important to avoid the obstacles to aggressive pipelining described above.\nCondition codes set by every instruction and instructions requiring widely varying numbers of cycles to execute are both obstacles to aggressive pipelining. So, these features are not generally considered obstacles to aggressive pipelining of an integer unit.\nHaving several different classes (sets) of registers is not a significant obstacle to aggressive pipelining of an integer unit.\nVariable-length encoding of instructions is a potential obstacle to aggressive pipelining. Instructions with variable-length encoding may take different amounts of time to decode. This can make it difficult to schedule these instructions in the pipeline."}
{"question": "Let k >= 2. Let L be the set of strings in {0, 1}^* such that x \\in L if and only if the number of 0's in x is divisible by k and the number of 1's in x is odd. The minimum number of states in a deterministic finite automaton (DFA) that recognizes L is", "choices": [{"label": "A", "text": "k + 2"}, {"label": "B", "text": "2k"}, {"label": "C", "text": "k log k"}, {"label": "D", "text": "k^2"}], "answerKey": "B", "model_answer": "LECTURE: A deterministic finite automaton (DFA) is a machine that receives input and produces output. The input is a string of symbols from a finite set, and the output is a decision that the input is accepted or rejected.\nA DFA has a set of states and a transition function. The transition function tells you the set of states to which the DFA can move on each symbol of the input. The start state is represented by an arrow pointing to it from the \"start\" symbol, and the accept state is represented by an arrow pointing to it from the \"stop\" symbol.\nThe minimum number of states in a DFA that recognizes a language L is a measure of the size of the smallest DFA that recognizes L. This minimum number of states is an example of a computational problem that is at least as hard as the problem of determining the language itself. Therefore, it is a very difficult problem to solve.\nHowever, for some types of languages, the minimum number of states in a DFA that recognizes the language can be given by a function that is simpler and easier to calculate than the general definition above. For example, the minimum number of states in a DFA that recognizes a language L is k if L is a language of length k, and the minimum number of states in a DFA that recognizes a language L is 2^k if L is a language of size 2^k.\nThese function definitions are the basis for the following rules of thumb for deciding how many states a DFA needs:\nIf the language is short, then the DFA needs only a few states.\nIf the language is long, then the DFA needs many states.\nIf the language is all 0's or all 1's, then the DFA needs only one state.\nIf the language is the opposite of a language that is all 0's or all 1's, then the DFA needs many states.\n\nSOLUTION: To determine whether a DFA with k + 2 states recognizes L, consider whether the DFA can move from its start state to an accept state after reading the first k and then the last 2 symbols. For example, the DFA can move from its start state to the accept state by reading the first 2 symbols: \"00\" and then the last 2 symbols: \"00\". The number of 0's in the string is divisible by k, and the number of 1's in the string is odd. So, the DFA can recognize this string.\nThe DFA can also move from its start state to an accept state by reading the first k - 2 and then the last 2 symbols: \"01\" and then the last 2 symbols: \"00\". The number of 0's in the string is divisible by k, and the number of 1's in the string is odd. So, the DFA can recognize this string.\nIn general, the DFA can recognize a string if it can move from its start state to an accept state by reading the first k and then the last m symbols, where 2 \u2264 m \u2264 k.\nSo, a DFA with k + 2 states can recognize L.\nTo determine whether a DFA with 2k states recognizes L, consider whether the DFA can move from its start state to an accept state after reading the first k symbols. For example, the DFA can move from its start state to the accept state by reading the first k symbols: \"0\". The number of 0's in the string is divisible by k, and the number of 1's in the string is odd. So, the DFA can recognize this string.\nThe DFA can also move from its start state to an accept state by reading the first k - 1 symbols: \"01\". The number of 0's in the string is divisible by k, and the number of 1's in the string is odd. So, the DFA can recognize this string.\nIn general, the DFA can recognize a string if it can move from its start state to an accept state by reading the first k symbols.\nSo, a DFA with 2k states can recognize L.\nTo determine whether a DFA with k log k states recognizes L, consider whether the DFA can move from its start state to an accept state after reading the first k symbols. For example, the DFA can move from its start state to the accept state by reading the first k symbols: \"0\". The number of 0's in the string is divisible by k, and the number of 1's in the string is odd. So, the DFA can recognize this string.\nThe DFA can also"}
{"question": "Let G = (V, E) be a finite directed acyclic graph with |E| > 0. Which of the following must be true?\nI. G has a vertex with no incoming edge.\nII. G has a vertex with no outgoing edge.\nIII. G has an isolated vertex, that is, one with neither an incoming edge nor an outgoing edge.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a set of vertices or nodes connected by edges. A directed graph is a graph in which each edge is associated with a direction. A directed acyclic graph (DAG) is a directed graph that has no directed cycles.\nA finite graph has a fixed number of vertices. A directed acyclic graph with a finite number of vertices has a fixed number of edges.\nVertices in a graph may have incoming edges and outgoing edges. An incoming edge points from a different vertex to a vertex in the graph. An outgoing edge points from a vertex to a different vertex.\nA vertex with no incoming edges is a predecessor vertex. A vertex with no outgoing edges is a successor vertex.\nA graph has an isolated vertex if and only if it has a predecessor vertex and a successor vertex.\nSOLUTION: Vertices in a directed acyclic graph with a finite number of vertices have a fixed number of incoming and outgoing edges. So, if a vertex has no outgoing edges, it must have no incoming edges. And, if a vertex has no incoming edges, it must have no outgoing edges.\nSo, G has an isolated vertex if and only if G has a vertex with no incoming edge and a vertex with no outgoing edge.\nThis isolated vertex must have no edges. So, G has a vertex with no incoming edge and a vertex with no outgoing edge."}
{"question": "Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v. Let (u, v) be an edge in G that is not in T, such that pre(u) < pre(v). Which of the following statements about u and v must be true?\nI. post(u) < post(v)\nII. u is an ancestor of v in T.\nIII. If w is the lowest common ancestor of u and v in T, then w = u.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "SOLUTION: Let w be the lowest common ancestor of u and v in T. By the definition of a lowest common ancestor, pre(w) = pre(u) = pre(v). Also, w is the farthest ancestor such that no child of w is an ancestor of both u and v. So, post(w) = post(u) = post(v).\nSince pre(u) < pre(v), u and v are not in the same connected component of G. Therefore, w is in a path between u and v in G.\nBy the definition of preorder traversal, u is visited before w in a preorder traversal of T. So, post(u) = pre(u) + 1.\nBy the definition of postorder traversal, w is visited before v in a postorder traversal of T. So, post(v) = pre(v) + 1.\nSince w is the farthest ancestor such that no child of w is an ancestor of both u and v, w is in a path between u and v in T. So, u is an ancestor of v in T.\nThere are two cases for why u is an ancestor of v in T:\nu is on the path from the root of T to v. In this case, post(u) = pre(u) + 1 = post(v) + 1.\nu is not on the path from the root of T to v, but u has a descendant that is on the path from the root of T to v. In this case, post(u) = pre(u) + 1 = post(v).\nIn either case, post(u) < post(v)."}
{"question": "In systems with support for automatic memory management, a garbage collector typically has the responsibility for reclaiming allocated memory objects whose contents cannot affect any future legal computation. Such objects are identified by determining that they cannot be reached from a root set. Which of the following is NOT part of the root set in a typical garbage collector?", "choices": [{"label": "A", "text": "Actual parameters of the active procedures"}, {"label": "B", "text": "Dynamically allocated objects on the heap"}, {"label": "C", "text": "Global variables of the program"}, {"label": "D", "text": "Local variables on the call stack"}], "answerKey": "B", "model_answer": "LECTURE: In order to answer this question, you need to understand how garbage collectors work. A garbage collector is a program that reclaims memory that is no longer being used by your program.\nWhen a garbage collector runs, it needs to find all the memory that is allocated but not being used. To do this, the garbage collector needs to follow all the references, or paths, to each object. References to objects can include both active references and inactive references.\nAn active reference is an path to an object that is currently in use. An inactive reference is a path to an object that is not in use. When the garbage collector follows a reference to an object, it determines whether the object is in use. If the object is in use, the garbage collector records the reference to the object. When the garbage collector has followed all the references to an object, it can reclaim the memory that the object occupies.\nThe root set is the set of objects that the garbage collector needs to consider when determining which objects are not in use. The root set includes all objects that are reachable from the program's entry point. The entry point is the point of entry for your program. It is the first procedure that your program calls when it starts running.\nActual parameters of the active procedures are not part of the root set. Actual parameters are values that are passed to a procedure when the procedure is called. Actual parameters are not part of the data that the procedure uses to do its work. So, actual parameters cannot affect any future legal computation.\nDynamically allocated objects on the heap are objects that are allocated on the heap. The heap is a region of memory that is used to allocate objects. Dynamic allocation on the heap means that the objects are allocated at run time.\nGlobal variables of the program are variables that are defined outside of any procedure. Global variables can be accessed by any procedure in the program.\nLocal variables on the call stack are variables that are defined within a procedure. The call stack is a data structure that keeps track of the procedures that are currently being executed. When a procedure is called, its local variables are pushed onto the call stack. When the procedure returns, its local variables are popped from the call stack."}
{"question": "In the Internet Protocol (IP) suite of protocols, which of the following best describes the purpose of the Address Resolution Protocol?", "choices": [{"label": "A", "text": "To translate Web addresses to host names"}, {"label": "B", "text": "To determine the IP address of a given host name"}, {"label": "C", "text": "To determine the hardware address of a given host name"}, {"label": "D", "text": "To determine the hardware address of a given IP address"}], "answerKey": "D", "model_answer": "SOLUTION: The Address Resolution Protocol (ARP) is responsible for determining the hardware address of a given host name or IP address. When a computer needs to send a packet to another computer, it uses the ARP protocol to determine the hardware address of the destination computer. This allows the sending computer to send the packet to the correct destination computer."}
{"question": "Which of the following language features requires that stack-based storage allocation be used rather than static allocation?", "choices": [{"label": "A", "text": "Recursive procedures"}, {"label": "B", "text": "Arbitrary goto's"}, {"label": "C", "text": "Two-dimensional arrays"}, {"label": "D", "text": "Integer-valued functions"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following is not a sentence that is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z?", "choices": [{"label": "A", "text": "xyz"}, {"label": "B", "text": "xy"}, {"label": "C", "text": "xxzy"}, {"label": "D", "text": "xxxxy"}], "answerKey": "A", "model_answer": "LECTURE: A grammar consists of a set of production rules.\nA grammar can generate a sentence if the sentence can be generated by the production rules in the grammar.\nSOLUTION: Use the grammar to generate each word in the sentence.\nThe only way to generate the sentence is to use the production rule C -> B|D, D -> y|Ey, E -> z. This produces the sentence yz."}
{"question": "Let T (n) be defined by T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1. Which of the following represents the order of growth of T(n) as a function of n?", "choices": [{"label": "A", "text": "\u0398(n)"}, {"label": "B", "text": "\u0398(n log n)"}, {"label": "C", "text": "\u0398(n^2)"}, {"label": "D", "text": "\u0398(n^2 log n)"}], "answerKey": "C", "model_answer": "LECTURE: The order of growth of a function is a measure of its magnitude. The order of growth represents the rate at which the function grows as its argument increases.\nSome common orders of growth are:\no O(1) represents a constant function.\no O(log n) represents a function that grows at a logarithmic rate.\no O(n) represents a function that grows at a linear rate.\no O(n log n) represents a function that grows at a linear rate, but the base of the logarithm is n.\no O(n^2) represents a function that grows at a quadratic rate.\no O(n^2 log n) represents a function that grows at a quadratic rate, but the base of the logarithm is n.\n\nSOLUTION: To describe the order of growth of T(n) as a function of n, consider the definition of T(n).\nT(n) is defined to be 3n + T(n-1), so T(n) is a function of T(n-1).\nBy the definition of T(n), T(n) is O(n).\nImagine an integer-valued function f(n) such that f(n) = T(n) for all integers n.\nThen, f(n) is O(n)."}
{"question": "Which of the following problems is (are) decidable?\nI. Given a (finite) string w, is w a prefix of the decimal expansion of \u03c0?\nII. Given a program and an input, is the program\u2019s output the decimal expansion of \u03c0?\nIII. Given a program that takes as input a prefix of the decimal expansion of \u03c0, is the program\u2019s output always the same for every prefix?", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A string is a finite sequence of characters. A programming language is a set of rules for writing programs. A program is a set of instructions that can be followed by a computer.\nA problem is a question that can be solved. Some problems can be solved by writing a program. The act of writing a program to solve a problem is called programming.\nA decidable problem is a problem for which there is a way to determine if a solution exists.\nThere are many different types of problems. Some problems are decidable, and others are not.\nFor example, the following problem is decidable: Given a string, is the string a palindrome? A palindrome is a string that is the same forwards and backwards.\nThere are many ways to solve this problem. One way is to use a stack. Push all the characters of the string onto the stack. While the stack is not empty, compare the top two characters. If they are the same, pop the stack until it is empty. If the last character popped from the stack is the same as the current character, the string is a palindrome.\nThe following problem is not decidable: Given a string, is the string a random string? There is no way to determine if a string is a random string.\nAnother way to say this is that there are many different programs that can determine if a string is a palindrome. There is no way to determine if a string is a random string.\nThere are many other examples of decidable and undecidable problems.\nSOLUTION: A string is a prefix of the decimal expansion of \u03c0 if the decimal expansion of \u03c0 begins with the string.\nThere are many ways to determine if a string is a prefix of the decimal expansion of \u03c0. One way is to compare the string to the decimal expansion of \u03c0.\nIf the string is a prefix of the decimal expansion of \u03c0, then the string is the decimal expansion of \u03c0. So, the problem is decidable.\nA program is a set of instructions that can be followed by a computer.\nA prefix of the decimal expansion of \u03c0 can be given as input to a program.\nThe program can output the decimal expansion of \u03c0. So, the problem is decidable.\nA program that takes as input a prefix of the decimal expansion of \u03c0 can always output the same thing for every prefix.\nThis means that the program has a deterministic algorithm. A deterministic algorithm is an algorithm that, for a given input, produces the same output every time it is run.\nSo, the problem is decidable."}
{"question": "Which of the following statements about circuits is (are) true?\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nIII. Both sequential and combinational circuits must be controlled by an external clock.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: Feedback is a mechanism for a circuit to communicate with itself.\nA feedback mechanism allows a circuit to use its own output to influence its input.\nA combinational circuit may use feedback to change its output based on its current output.\nA sequential circuit may use feedback to change its output based on its current input.\nThe \"memoryless\" property of a combinational circuit implies that the output depends only on the current state of the inputs, not on the circuit's history.\nBoth sequential and combinational circuits may have feedback.\nAn external clock is a signal that recurrently triggers the same sequence of events.\nBoth sequential and combinational circuits may be controlled by an external clock.\nHowever, an external clock is not required to define the behavior of a combinational circuit.\nA combinational circuit must be designed to perform a specific function. It does not have a generic, recurring sequence of activities that are triggered by an external clock."}
{"question": "Two single-user workstations are attached to the same local area network. On one of these workstations, file pages are accessed over the network from a file server; the average access time per page is 0.1 second. On the other of these workstations, file pages are accessed from a local disk; the average access time per page is 0.05 second. A particular compilation requires 30 seconds of computation and 200 file page accesses. What is the ratio of the total time required by this compilation if run on the diskless (file server) workstation to the total time required if run on the workstation with the local disk, if it is assumed that computation is not overlapped with file access?", "choices": [{"label": "A", "text": "1/1"}, {"label": "B", "text": "5/4"}, {"label": "C", "text": "5/3"}, {"label": "D", "text": "10/5"}], "answerKey": "B", "model_answer": "LECTURE: The average access time for a file from a local disk is faster than the average access time for a file from a file server. This is because a file from a local disk can be accessed simultaneously with other operations, while a file from a file server can only be accessed one at a time.\nWhen a file is accessed from a local disk, the computer can spend the waiting time performing other operations. This is called overlapping of file access and computation. Overlapping can speed up the overall operation.\nWhen a file is accessed from a file server, the computer has to wait for the file to be accessed one at a time. This waiting time is wasted. It does not get overlapped with other operations.\nSo, the total time required by a compilation with n file accesses and m seconds of computation will be faster when the compilation is run on the workstation with the local disk than when it is run on the diskless workstation.\nThis difference can be described with the following ratio:\ntotal time on diskless workstation / total time on workstation with local disk = (fast access time + slow access time) / slow access time\n= (0.05 + 0.1) / 0.1\n= 5 / 3"}
{"question": "Assume that a debugger places a breakpoint at a load instruction at virtual address 0x77E81234 (hexadecimal notation) in a debugged process P. If the text segment of P begins at 0x77E80000 in P\u2019s virtual address space and if the debugger has mapped this same text segment at 0x01000000 in its virtual address space, which of the following is the virtual address used by the debugger in its WRITE operation, along with a description of how the debugger has mapped the virtual memory page containing this address?", "choices": [{"label": "A", "text": "0x01001234; page mapped with READ/WRITE access"}, {"label": "B", "text": "0x01001234; page mapped with COPY-ON-WRITE access"}, {"label": "C", "text": "0x76E81234; page mapped with READ/WRITE access"}, {"label": "D", "text": "0x76E81234; page mapped with COPY-ON-WRITE access"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following considerations applies (apply) to choosing the page size in a paging system?\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "SOLUTION: When choosing page sizes, there are several factors to consider. Here, four considerations are presented. The main question is about what factors apply to choosing the page size in a paging system.\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.\nIV. A larger page size leads to an increase in the amount of memory needed to manage the paging system.\nV. A smaller page size can increase the overhead of swapping pages between main memory and disk.\nThe correct answer is I and III only.\nThe advantage of larger pages is that they lead to smaller page tables. This could lead to a decrease in the overhead of managing the paging system.\nThe dominant factor in disk access time is the distance of the disk head from the disk's center of rotation. This distance is called the disk access time, and it is not affected by the length of the page. So, longer pages can be used advantageously."}
{"question": "Two processors, M-5 and M-7, implement the same instruction set. Processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. Processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds. Which of the following is (are) true?\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline.\nII. The latency of a single instruction is shorter on M-7\u2019s pipeline than on M-5\u2019s pipeline.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III"}, {"label": "D", "text": "II and III"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following pairs of 8-bit, two's-complement numbers will result in overflow when the members of the pairs are added?", "choices": [{"label": "A", "text": "11111111, 00000001"}, {"label": "B", "text": "00000001, 10000000"}, {"label": "C", "text": "11111111, 10000001"}, {"label": "D", "text": "10000001, 10101010"}], "answerKey": "D", "model_answer": ""}
{"question": "Two computers communicate with each other by sending data packets across a local area network. The size of these packets is 1,000 bytes. The network has the capacity to carry 1,000 packets per second. The CPU time required to execute the network protocol to send one packet is 10 milliseconds. The maximum rate at which one computer can send data to another is approximately", "choices": [{"label": "A", "text": "10,000 bytes/second"}, {"label": "B", "text": "25,000 bytes/ second"}, {"label": "C", "text": "100,000 bytes/ second"}, {"label": "D", "text": "500,000 bytes/ second"}], "answerKey": "C", "model_answer": "SOLUTION: The maximum rate at which one computer can send data to another is approximately 1,000 packets per second, or 1,000 bytes per packet, which is 1,000,000 bytes per second.\nThe CPU time required to execute the network protocol to send one packet is 10 milliseconds.\nTo find the maximum rate at which data can be sent across the network, divide the network's capacity by the time it takes to send one packet:\n1,000,000 bytes/second \u00f7 10 milliseconds/byte = 100,000 bytes/second."}
{"question": "Consider the following grammar.\nS \u2192 ( S )\nS \u2192 x\nWhich of the following statements is (are) true?\nI. The grammar is ambiguous.\nII. The grammar is suitable for top-down parsing.\nIII. The grammar is suitable for bottom-up parsing.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "SOLUTION: This grammar is ambiguous.\nWhen the non-terminal S has two children, the grammar does not specify which production to use. This can result in multiple parse trees for a single input string. For example, the input string xxx can be parsed as follows:\nS \u2192 (S)\nS \u2192 S\nS \u2192 x\nS \u2192 x x x\nSOLUTION: To determine which parse trees are produced by this grammar, apply the grammar to xxx.\nThe first production that applies to the empty string is S \u2192 S. So, S is the root of the parse tree.\nThe second production that applies to the empty string is S \u2192 x. So, x is the root of the parse tree.\nBoth of these parse trees have a single production for S. So, this grammar is not suitable for bottom-up parsing."}
{"question": "Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT:", "choices": [{"label": "A", "text": "Counting distinct values: Given a set of n keys, determine the number of distinct key values."}, {"label": "B", "text": "Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary."}, {"label": "C", "text": "Range search: Given values a and b, find all the records whose key value is in the range a, b."}, {"label": "D", "text": "Symbol table lookup: Given a program identifier, find its type and address."}], "answerKey": "C", "model_answer": ""}
{"question": "Let A be a finite set with m elements, and let B be a finite set with n elements. The number of distinct functions mapping A into B is", "choices": [{"label": "A", "text": "n^m"}, {"label": "B", "text": "n!/(n - m)!"}, {"label": "C", "text": "n!"}, {"label": "D", "text": "n!/(m!(n - m)!)"}], "answerKey": "A", "model_answer": "LECTURE: Functions are a different kind of mappings from sets to sets. The set A is called the domain of a function, and the set B is called the codomain of the function.\nIf f is a function with domain A and codomain B, then each element of B is the value of f for some element of A.\nThe number of functions from A to B is a measure of the size of the set of all functions from A to B. This number is written as |A|^B, and is called the Bornologous Power of A.\nThe exponent on n in n^m is m. The exponent on n in n!/(n - m)! is m. So, n^m and n!/(n - m)! have the same exponent on n.\nBut, n!/(n - m)! has a different exponent on m. So, n^m and n!/(n - m)! are not equal.\nD. is incorrect.\nn! is the product of all positive integers up to n. So, n!/(m!(n - m)!). has the same exponent on n as n!. But, the exponent on m is smaller. So, n!/(m!(n - m)!). and n! are not equal.\nC. is incorrect.\nThe factorial function has the property that n! is equal to 1 if n is equal to 0. For all other positive integers n, n! is equal to n(n - 1)!.\nSo, n! is equal to 1 if n is equal to 0. And, for all other positive integers n, n! is equal to n(n - 1)!.\nIn general, n! is greater than n^m.\nSo, C is incorrect.\nB. is incorrect.\nThe factorial function has the property that n! is equal to 1 if n is equal to 0. For all other positive integers n, n! is equal to n(n - 1)!.\nSo, n! is equal to 1 if n is equal to 0. And, for all other positive integers n, n! is equal to n(n - 1)!.\nIn general, n! is greater than n^m.\nSo, B. is incorrect.\nA. is incorrect.\nThe number of functions from a set to a set is a measure of the size of the set of all functions from the set to the set. This size is written as |A|^B.\nSo, |A|^B is equal to n^m."}
{"question": "To compute the matrix product M_1M_2, where M_1 has p rows and q columns and where M_2 has q rows and r columns, takes time proportional to pqr, and the result is a matrix of p rows and r columns. Consider the product of three matrices N_1N_2N_3 that have, respectively, w rows and x columns, x rows and y columns, and y rows and z columns. Under what condition will it take less time to compute the product as (N_1N_2)N_3 (i.e., multiply the first two matrices first) than to compute it as N_1(N_2 N_3)?", "choices": [{"label": "A", "text": "There is no such condition; i.e., they will always take the same time."}, {"label": "B", "text": "1/x + 1/z < 1/w + 1/y"}, {"label": "C", "text": "x > y"}, {"label": "D", "text": "1/w + 1/x < 1/y + 1/z"}], "answerKey": "B", "model_answer": ""}
{"question": "The hit ratio of a cache memory is the percentage of accesses (reads and writes) for which data are found in the cache. Write-through is a policy whereby every write operation updates main memory. Write-back is a policy whereby a write operation to a line found in the cache does not affect main memory until the line is evicted from the cache. Write-allocation is a policy whereby a cache line is allocated and loaded on a write-miss. If it is assumed that write-allocation is always used, which of the following is true?", "choices": [{"label": "A", "text": "Write-back usually results in a better hit ratio than write-through."}, {"label": "B", "text": "Write-through usually results in a better hit ratio than write-back."}, {"label": "C", "text": "The percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through."}, {"label": "D", "text": "The percentage of write operations resulting in a main memory operation will never be larger for writethrough than for write-back."}], "answerKey": "C", "model_answer": ""}
{"question": "A particular disk unit uses a bit string to record the occupancy or vacancy of its tracks, with O denoting vacant and 1 denoting occupied. A 32-bit segment of this string has the hexadecimal value D4FE2003. The percentage of occupied tracks for the corresponding part of the disk, to the nearest percent, is", "choices": [{"label": "A", "text": "12%"}, {"label": "B", "text": "25%"}, {"label": "C", "text": "38%"}, {"label": "D", "text": "44%"}], "answerKey": "D", "model_answer": "SOLUTION: The hexadecimal value of the 32-bit string is D4FE2003. This value corresponds to the number 255 in decimal.\nThere are 32 tracks on a disk. To find the percentage of occupied tracks for a given part of the disk, calculate the number of occupied tracks and divide by the total number of tracks.\nSubtract the result from 100%, and express the result to the nearest percent.\nThere are 28 tracks that are occupied. This is 28 out of 32, or 87.5%. So, the percentage of occupied tracks is 87.5%, to the nearest percent."}
{"question": "An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. Which of the following undirected graphs must have an Euler circuit?\nI. A complete graph with 12 vertices\nII. A complete graph with 13 vertices\nIII. A tree with 13 vertices", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "B", "model_answer": ""}
{"question": "Which of the following characteristics of a programming language is best specified using a context-free grammar?", "choices": [{"label": "A", "text": "Identifier length"}, {"label": "B", "text": "Maximum level of nesting"}, {"label": "C", "text": "Operator precedence"}, {"label": "D", "text": "Type compatibility"}], "answerKey": "C", "model_answer": "LECTURE: A programming language is a set of rules that tell you how to write programs. Programming languages have their own syntax and Semantic.\nSyntax tells you the rules for writing programs in a language. Syntax includes such elements as keywords, identifiers, and punctuation.\nSemantics tell you the meaning of the elements in the language. Semantics include such things as the rules for assigning values to variables and the steps that a program can take.\nA context-free grammar is a way of describing the syntax of a language. You can use a context-free grammar to describe the structure of programs written in the language.\nHere are some ways in which a programming language's characteristics may be specified:\nIdentifier length: This is a syntax specification. Identifiers are parts of program names, and their length is governed by the language's syntax.\nMaximum level of nesting: This is a syntax specification. Nesting is a way in which parts of an expression are grouped together. The maximum level of nesting is a syntax rule that specifies the maximum size of a nest.\nOperator precedence: This is a syntax specification. Operator precedence is a way in which the order of operations is determined. The precedence of an operator is a syntax rule that specifies which operations must be performed before others.\nType compatibility: This is a Semantic specification. Type compatibility describes whether values of different types can be assigned to the same variable."}
{"question": "Which of the following statements about datagrams sent by a node in a network using IPv4 protocol is (are) true?\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nIII. Datagrams are reassembled only at the destination.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "SOLUTION: I. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nA datagram's maximum size is called its maximum transmission unit (MTU). In an IPv4 network, the MTU is 65,535 bytes. This means that the largest datagram that a node can send is 65,535 bytes.\nThe size of a datagram affects the path that a datagram takes through the network. A datagram that is larger than the MTU of a link must be broken into smaller fragments. These fragments must be sent on a path that passes through a series of nodes. Each node adds a header to each fragment. The header includes a field that identifies the fragment. When a datagram reaches its destination, the fragments are reassembled.\nII. Datagrams may be fragmented during routing.\nA datagram may be fragmented into smaller pieces while it is being routed through a network. Each fragment is sent on a separate path. The fragments are reassembled at the destination.\nIII. Datagrams are reassembled only at the destination.\nWhen a datagram is sent, it is broken into smaller pieces. Each piece is sent on a separate path. The pieces are reassembled at the destination."}
{"question": "A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. Which of the following job-scheduling policies is starvation-free?", "choices": [{"label": "A", "text": "Round-robin"}, {"label": "B", "text": "Priority queuing"}, {"label": "C", "text": "Shortest job first"}, {"label": "D", "text": "Youngest job first"}], "answerKey": "A", "model_answer": "SOLUTION: A starvation-free job-scheduling policy is one that guarantees that no job waits indefinitely for service.\nIf a job waits for an unbounded amount of time, it may appear to be starved, or neglected. To avoid this, the policy must either assign a finite priority to each job, or assign a non-zero time limit to each job.\nHere are some ways in which a policy can be starvation-free:\n* Assistant: Priority queuing is a starvation-free policy. It guarantees that no job waits indefinitely for service, by assigning a finite priority to each job.\n* Shortest job first is not a starvation-free policy. It can lead to starvation, because a long job may never get to the head of the queue.\n* Round-robin is a starvation-free policy. It assigns a finite priority to each job, and rotates among the jobs.\n* Youngest job first is not a starvation-free policy. It can lead to starvation, because a job that is part-way through its execution may never get to the head of the queue."}
{"question": "Of the following, which gives the best upper bound for the value of f(N) where f is a solution to the recurrence f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0?", "choices": [{"label": "A", "text": "O(log N)"}, {"label": "B", "text": "O(N log N)"}, {"label": "C", "text": "O(log N) + 0(1)"}, {"label": "D", "text": "O((log N)^2)"}], "answerKey": "D", "model_answer": "SOLUTION: The recurrence relation for f is written as f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0.\nTo get the best upper bound for the value of f(N), you need to consider the largest value that f(N) can take on, given that f(2N + 1) and f(2N) are both equal to f(N) + log N.\nFor N = 1, f(N) = 0. For N = 2, log N is the largest value that f(N) can take on, since f(2N + 1) and f(2N) are both equal to f(N) + log N.\nSo, the largest value that f(N) can take on is O(log N)."}
{"question": "Company X shipped 5 computer chips, 1 of which was defective, and Company Y shipped 4 computer chips, 2 of which were defective. One computer chip is to be chosen uniformly at random from the 9 chips shipped by the companies. If the chosen chip is found to be defective, what is the probability that the chip came from Company Y?", "choices": [{"label": "A", "text": "2 / 9"}, {"label": "B", "text": "4 / 9"}, {"label": "C", "text": "1 / 2"}, {"label": "D", "text": "2 / 3"}], "answerKey": "D", "model_answer": "SOLUTION: Each company shipped 5 chips, and 2 of them were defective, so the probability that a chip is defective is 2 / 5.\nThe event that a chip is defective is independent of which company shipped the chip. So, the probability that a chip is defective is the same whether the chip is from Company X or Company Y.\nSo, the probability that the chosen chip is defective is (2 / 5) x (2 / 9) = 4 / 45.\nThis means that the probability that the chosen chip is non-defective is 1 - 4 / 45 = 45 / 45.\nSo, the probability that the chosen chip came from Company Y is (2 / 9) x (1 / 2) = 2 / 9."}
{"question": "Which of the following problems can be solved by a standard greedy algorithm?\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights\nII. Finding a maximum clique in an undirected graph\nIII. Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "SOLUTION: A standard greedy algorithm can solve the following problems:\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights.\nII. Assistant: Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities.\nA standard greedy algorithm can be used to solve these problems because each greedy step simply involves selecting the next edge with the highest weight.\nA standard greedy algorithm cannot solve the following problems:\nIII. Finding a maximum clique in an undirected graph.\nA standard greedy algorithm can be used to solve some types of problems, such as finding a minimum spanning tree or a maximum flow. But finding a maximum clique is not one of these types of problems.\nA clique is a set of nodes in a graph that are all connected to each other. To find a maximum clique, you need to look at every possible combination of nodes in the graph and choose the combination that results in the largest clique."}
{"question": "A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined. Which of the following is (are) correct?\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "SOLUTION: A hash table is a data structure that maps keys to values. In this program, the words in the dictionary are the keys, and the entries in the hash table are the values.\nWhen the program checks the spelling of a word in a document, it applies the hash function to each word in the document. The appropriate entry in the hash table is set to true if the hash function produces a matching key.\nSo, true means the word was in the dictionary.\nFalse means the word was not in the dictionary.\nThe hash table size should increase with the document size. As the number of words in the document increases, it becomes more important to use a larger hash table to avoid an increase in false positives."}
{"question": "One approach to handling fuzzy logic data might be to design a computer using ternary (base-3) logic so that data could be stored as \u201ctrue,\u201d \u201cfalse,\u201d and \u201cunknown.\u201d If each ternary logic element is called a flit, how many flits are required to represent at least 256 different values?", "choices": [{"label": "A", "text": "4"}, {"label": "B", "text": "5"}, {"label": "C", "text": "6"}, {"label": "D", "text": "7"}], "answerKey": "C", "model_answer": "LECTURE: A computer uses logic gates to manipulate binary digits, or bits. A logic gate can have one of two outputs: \"high\" or \"low.\" These outputs are represented by the digits 1 and 0.\nA ternary logic gate can have one of three outputs: \"high,\" \"low,\" or \"unknown.\" These outputs are represented by the digits 1, 0, and 2, respectively. One way to represent ternary logic values is by using a sequence of three binary digits. For example, the ternary logic values \"high,\" \"low,\" and \"unknown\" can be represented by the sequences 100, 010, and 002, respectively.\nTo represent at least 256 different values, you need to use at least 8 bits. The first 3 bits can represent one of 8 different ternary logic values. The last 5 bits can represent one of 32 different values for each of the 8 ternary logic values.\nSo, you need 3 bits for the first part of the representation, and 5 bits for the second part. 3 + 5 = 8."}
{"question": "Local caching of files is common in distributed file systems, but it has the disadvantage that", "choices": [{"label": "A", "text": "Temporary inconsistencies among views of a file by different machines can result"}, {"label": "B", "text": "The file system is likely to be corrupted when a computer crashes"}, {"label": "C", "text": "A much higher amount of network traffic results"}, {"label": "D", "text": "Caching makes file migration impossible"}], "answerKey": "A", "model_answer": "SOLUTION: Local caching of files is common in distributed file systems, but it has the disadvantage that temporary inconsistencies among views of a file by different machines can result."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-through policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2048"}], "answerKey": "C", "model_answer": "SOLUTION: With a write-through policy, when a cache block is written to, the changes are immediately written to the main memory. Since the cache is 2K bytes and the block size is 8 bytes, the number of cache blocks is 256/8 = 32.\nSo, the loop will write 32 cache blocks to memory. Each cache block is 8 bytes, so the loop will write 32 \\* 8 = 256 bytes to memory."}
{"question": "At time 0, five jobs are available for execution on a single processor, with service times of 25, 15, 5, 3, and 2 time units. Which of the following is the minimum value of the average completion time of these jobs?", "choices": [{"label": "A", "text": "50"}, {"label": "B", "text": "208/5"}, {"label": "C", "text": "92/5"}, {"label": "D", "text": "10"}], "answerKey": "C", "model_answer": "SOLUTION: The average completion time is given by the formula:\naverage completion time = sum of service times / number of jobs\n= 25 + 15 + 5 + 3 + 2 / 5\n= 208/5\nThe minimum value of the average completion time is 208/5."}
{"question": "Let G = (V, E) be a connected, undirected graph, and let a and b be two distinct vertices in V. Let P_1 be the problem of finding a shortest simple path between a and b, and let P_2 be the problem of finding a longest simple path between a and b. Which of the following statements about P_1 and P_2 is true?", "choices": [{"label": "A", "text": "Both P_1 and P_2 can be solved in polynomial time."}, {"label": "B", "text": "P_1 can be solved in polynomial time but P_2 is not known to be solvable in polynomial time."}, {"label": "C", "text": "P_1 is not known to be solvable in polynomial time but P_2 can be solved in polynomial time."}, {"label": "D", "text": "It is not known whether either P_1 or P_2 can be solved in polynomial time."}], "answerKey": "B", "model_answer": ""}
{"question": "A major advantage of direct mapping of a cache is its simplicity. The main disadvantage of this organization is that", "choices": [{"label": "A", "text": "it does not allow simultaneous access to the intended data and its tag"}, {"label": "B", "text": "it is more expensive than other types of cache organizations"}, {"label": "C", "text": "the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache"}, {"label": "D", "text": "its access time is greater than that of other cache organizations"}], "answerKey": "C", "model_answer": "SOLUTION: The major advantage of direct mapping is its simplicity. The main disadvantage of this organization is that it does not allow simultaneous access to the intended data and its tag."}
{"question": "Let M be a single-tape, deterministic Turing machine with tape alphabet {blank,0,1}, and let C denote the (possibly infinite) computation of M starting with a blank tape. The input to each problem below is M, together with a positive integer n. Which of the following problems is (are) decidable?\nI. The computation C lasts for at least n steps.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nIII. M scans at least n distinct tape squares during the computation C.", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "D", "model_answer": "SOLUTION: This problem is about deciding what M can do. In other words, it is about recognizing which inputs cause M to behave in certain ways.\nA Turing machine can do many things. Some of the things it can do are:\nprint a string\nhalt\nmove the head\nchange the tape\nDoing these things are M's behaviors. The problem is to decide which inputs cause M to do certain things.\nThis can be done with a finite-state machine that has one state for each possible behavior of M. Each state would have one output symbol on its transition to the next state.\nIf M can do something, then there is a path of transitions from the initial state to a state with an output symbol for that behavior. The output symbol is the one written in the output field.\nThere are two types of paths: those that halt and those that move. Moving paths change the value written in the output field. Halt paths do not.\nThere are two types of input: those that cause a move and those that do not. Inputs that do not cause a move are always followed by the same input on the next step. These inputs are not interesting.\nThe set of inputs that are interesting is the set of inputs that cause a move and are not followed by the same input on the next step. This set is finite.\nThere are two types of behaviors: those that print a string and those that do not. Behaviors that do not print a string are always followed by the same input on the next step. These behaviors are not interesting.\nThe set of inputs that are interesting is the set of inputs that cause a move and are not followed by the same input on the next step, and that cause M to print a string. This set is also finite.\nSo, the problem is to decide which inputs are in this finite set. This can be done by writing down the finite number of cases. Each case represents a possible input. The cases describe each behavior that M can do."}
{"question": "A 3-way, set-associative cache is", "choices": [{"label": "A", "text": "one in which each main memory word can be stored at any of 3 cache locations"}, {"label": "B", "text": "effective only if 3 or fewer processes are running alternately on the processor"}, {"label": "C", "text": "possible only with write-back"}, {"label": "D", "text": "faster to access than a direct-mapped cache"}], "answerKey": "A", "model_answer": "SOLUTION: A 3-way set-associative cache is one in which each main memory word can be stored at any of 3 cache locations. This type of cache is called set-associative because each cache location is associated with a set of main memory addresses. All of the main memory words that are stored in a given cache location are part of the same set.\nA 3-way set-associative cache is effective only if 3 or fewer processes are running alternately on the processor. This is because each cache location is associated with a set of main memory addresses. If more than 3 processes are running, some of the main memory addresses in the sets associated with the cache locations will not match any of the addresses in the cache.\nA set-associative cache is possible only with write-back. This is because a set-associative cache uses a set of main memory addresses to determine which cache location a new data word should be stored in. This set of addresses must be maintained, which requires writes to main memory. With write-back, the main memory is updated when a new data word is written to the cache. This allows the set of main memory addresses to be updated as needed.\nA direct-mapped cache is faster to access than a set-associative cache. This is because a direct-mapped cache uses a single cache location for each main memory address. This means that each main memory address can be accessed by a single cache location. In a set-associative cache, each main memory address may be stored in any of multiple cache locations. This can make it slower to access a given main memory address in a set-associative cache than in a direct-mapped cache."}
{"question": "Consider an object-oriented language in which all entities are objects. Two relationships arise: (1) the instance relationship, between an object and the class of which that object is a member, and (2) the subclass relationship, between a class and the superclass from which that class inherits properties. In such a language, when a message is sent to an object requesting execution of one of its methods (procedures), the method is located by following", "choices": [{"label": "A", "text": "one instance link and then zero or more subclass links"}, {"label": "B", "text": "one or more instance links and then one or more subclass links"}, {"label": "C", "text": "one or more instance links"}, {"label": "D", "text": "one subclass link and then one or more instance links"}], "answerKey": "A", "model_answer": "SOLUTION: When a message is sent to an object requesting execution of one of its methods, the method is located by following instance links from the object to the object's class, and then following subclass links from the class to the class's superclass.\nAn object has one instance link. An object's class has one or more instance links to its class. A class has one or more subclass links to its superclass.\nSo, the order of links is: one instance link and then zero or more subclass links."}
{"question": "In a pipelined RISC computer where all arithmetic instructions have the same CPI (cycles per instruction), which of the following actions would improve the execution time of a typical program?\nI. Increasing the clock cycle rate\nII. Disallowing any forwarding in the pipeline\nIII. Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "D", "model_answer": ""}
{"question": "A microcomputer used for data acquisition and control is required to digitize and process four analog input signals and to output their average continually; i.e., in real time. The time for an external analog-to-digital converter (which is triggered by a CPU instruction) to digitize one input is 12 microseconds, and only one digitization occurs at a time. Five CPU instructions, including the triggering instruction, must be executed for each signal digitized. Ten CPU instructions are executed in order to average each set of four samples and output this value. The time to convert the output from digital to analog form is to be ignored. If it is assumed that suitable data buffering is employed, then the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates, is", "choices": [{"label": "A", "text": "0.8 microseconds"}, {"label": "B", "text": "1.2 microseconds"}, {"label": "C", "text": "1.6 microseconds"}, {"label": "D", "text": "2.4 microseconds"}], "answerKey": "C", "model_answer": "SOLUTION: The maximum average instruction execution time is given by the equation:\nMaximum average instruction execution time = Instructions per signal + Instructions to average + Instructions per output\n= 5 instructions/signal + 10 instructions/average + 5 instructions/signal\n= 10 instructions/signal\n= 1.667 instructions/signal\n= 1.6 microseconds/instruction\nThe minimum instruction execution time is given by the equation:\nMinimum instruction execution time = Time per instruction / Number of instructions per signal\n= 12 microseconds / 5 instructions\n= 2.4 microseconds/instruction\nTo keep up with the input-output data rates, the maximum average instruction execution time must be less than or equal to the minimum instruction execution time:\n1.6 microseconds/instruction 2.4 microseconds/instruction\n1.6 microseconds/instruction 1.25"}
{"question": "Suppose that a certain software product has a mean time between failures of 10,000 hours and has a mean time to repair of 20 hours. If the product is used by 100 customers, what is its availability?", "choices": [{"label": "A", "text": "80%"}, {"label": "B", "text": "90%"}, {"label": "C", "text": "98%"}, {"label": "D", "text": "99.80%"}], "answerKey": "D", "model_answer": "LECTURE: The mean time between failures is a measure of the average time between failures.\nThe mean time to repair is a measure of the average time to fix a failure.\nThe availability of a software product is a measure of the percentage of time that the product is expected to be operational and capable of completing its intended functions.\nAvailability = (Mean time between failures) / (Mean time between failures + Mean time to repair)\nAvailability = (10,000 hours) / (10,000 hours + 20 hours)\nAvailability = 99.88%"}
