{"question": "The access matrix approach to protection has the difficulty that", "choices": [{"label": "A", "text": "the matrix, if stored directly, is large and can be clumsy to manage"}, {"label": "B", "text": "it is not capable of expressing complex protection requirements"}, {"label": "C", "text": "deciding whether a process has access to a resource is undecidable"}, {"label": "D", "text": "there is no way to express who has rights to change the access matrix itself"}], "answerKey": "A", "model_answer": ""}
{"question": "An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y. Which of the following sets of integers could possibly be the set of all common divisors of two integers?", "choices": [{"label": "A", "text": "{-6,-2, -1, 1, 2, 6}"}, {"label": "B", "text": "{-6, -2, -1, 0, 1, 2, 6}"}, {"label": "C", "text": "{-6, -3, -2, -1, 1, 2, 3, 6}"}, {"label": "D", "text": "{-6, -3, -2, -1, 0, 1, 2, 3, 6}"}], "answerKey": "C", "model_answer": ""}
{"question": "In the NoNicks operating system, the time required by a single file-read operation has four nonoverlapping components:\ndisk seek time-25 msec\ndisk latency time-8 msec\ndisk transfer time- 1 msec per 1,000 bytes\noperating system overhead-1 msec per 1,000 bytes + 10 msec\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes. The ratio of-the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately", "choices": [{"label": "A", "text": "1:4"}, {"label": "B", "text": "1:3.5"}, {"label": "C", "text": "1:1"}, {"label": "D", "text": "1.1:1"}], "answerKey": "B", "model_answer": ""}
{"question": "You want to cluster 7 points into 3 clusters using the k-Means Clustering algorithm. Suppose after the first iteration, clusters C1, C2 and C3 contain the following two-dimensional points: C1 contains the 2 points: {(0,6), (6,0)} C2 contains the 3 points: {(2,2), (4,4), (6,6)} C3 contains the 2 points: {(5,5), (7,7)} What are the cluster centers computed for these 3 clusters?", "choices": [{"label": "A", "text": "C1: (3,3), C2: (4,4), C3: (6,6)"}, {"label": "B", "text": "C1: (3,3), C2: (6,6), C3: (12,12)"}, {"label": "C", "text": "C1: (6,6), C2: (12,12), C3: (12,12)"}, {"label": "D", "text": "C1: (0,0), C2: (48,48), C3: (35,35)"}], "answerKey": "A", "model_answer": ""}
{"question": "Any set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. Which of the following is NOT complete?", "choices": [{"label": "A", "text": "{AND, NOT}"}, {"label": "B", "text": "{NOT, OR}"}, {"label": "C", "text": "{AND, OR}"}, {"label": "D", "text": "{NAND}"}], "answerKey": "C", "model_answer": "LECTURE: A set of Boolean operators is complete if it is sufficient to represent all Boolean expressions.\nA set of Boolean operators is sufficient if it is capable of expressing all Boolean expressions.\nSOLUTION: The set {AND, OR} is complete. It is capable of expressing any Boolean expression.\nThe set {NOT, OR} is sufficient, but it is not complete. It is capable of expressing all Boolean expressions except for those that can be formed using the NOT and OR operators.\nThe set {AND, NOT} is insufficient. It is capable of expressing some Boolean expressions, but not all of them. For example, the expression NOT(AND(a, b)) cannot be formed using the {AND, NOT} set of operators.\nThe set {NAND, NOR} is similar to the set {AND, NOT}. They are equivalent in that they can be used to express any Boolean expression."}
{"question": "Consider the collection of all undirected graphs with 10 nodes and 6 edges. Let M and m, respectively, be the maximum and minimum number of connected components in any graph in the collection. If a graph has no selfloops and there is at most one edge between any pair of nodes, which of the following is true?", "choices": [{"label": "A", "text": "M = 10, m = 10"}, {"label": "B", "text": "M = 10, m = 1"}, {"label": "C", "text": "M = 7, m = 4"}, {"label": "D", "text": "M = 6, m = 4"}], "answerKey": "C", "model_answer": ""}
{"question": "Resolution theorem proving for showing that a formula of propositional logic is not satisfiable has which of the following properties?\nI. It is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nII. It is a complete proof system in the sense that there is a proof of unsatisfiability for every unsa tisfiable formula of propositional logic.\nIII. It is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "C", "model_answer": "LECTURE: A proof system is a collection of rules and techniques for proving propositions. When a proof system is used to prove a proposition, the result is a proof.\nA sound proof system is a proof system for which there is no counterexample to the following proposition: Every proof in the proof system is valid. In other words, if a formula is provable by the proof system, it is true.\nA complete proof system is a proof system for which every true formula has a proof in the proof system. In other words, if a formula is true, it is provable by the proof system.\nA succinct proof system is a proof system for which every provable formula has a short proof. More precisely, a proof system is succinct if and only if every formula with at most n variables has a proof of length at most O(n^2).\nSOLUTION: This proof system is both sound and complete. It is sound because there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic. It is complete because there is a proof of unsatisfiability for every unsa tifiable formula of propositional logic.\nThis proof system is also succinct. When an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F."}
{"question": "Which of the following statements describe(s) properties of a purely segmented memory system?\nI. It divides memory into units of equal size.\nII. It permits implementation of virtual memory.\nIII. It suffers from internal fragmentation.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "B", "model_answer": "LECTURE: In a purely segmented memory system, memory is divided into segments of fixed size. Each process has its own memory space, which is a fixed-size segment. Each segment is assigned to a process when that process creates its memory space.\nThe operating system can permits processes to use a virtual memory system. Virtual memory allows a process to use more memory than is physically available. This is possible because the operating system can use a hard disk to create additional memory space. But creating virtual memory space takes time, and using virtual memory space slows down the process.\nA purely segmented memory system suffers from internal fragmentation. In an internal fragmented memory system, the memory requirements of a process are larger than the process's available memory space. As a result, the process must allocate memory from other processes' memory spaces. The other processes then have internal fragmentation.\nA mixed memory system is a combination of a purely segmented memory system and a segmented memory system. In a segmented memory system, memory is divided into segments of equal size. Each process is assigned its own memory segment.\nA mixed memory system does not suffer from internal fragmentation. But a mixed memory system requires more memory to be reserved for memory management than a purely segmented memory system."}
{"question": "Which of the following statements about floating-point arithmetic is NOT true?", "choices": [{"label": "A", "text": "It is inherently nonassociative because some numbers have no exact representation."}, {"label": "B", "text": "It is inherently nonassociative because there have to be upper and lower bounds on the size of numbers."}, {"label": "C", "text": "Associativity can be achieved with appropriate roundoff conventions."}, {"label": "D", "text": "Some rational numbers have no exact representation."}], "answerKey": "C", "model_answer": "LECTURE: Floating-point arithmetic is used in computers to perform arithmetic operations on numbers with decimal parts. Many operations on such numbers cannot be performed exactly. That is, the results of these operations are approximate.\nWhen two numbers are rounded to the same decimal place, they are considered equal. For example, 0.5 and 0.5000000000000000 are equal.\nIf the decimal places of two numbers are different, the numbers are not equal. For example, 0.5 and 0.9999999999999999 are not equal.\nSOLUTION: The statement that some rational numbers have no exact representation is not true. It is possible to have an infinite number of 0s after the decimal place. For example, 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000."}
{"question": "Suppose sharing of tiles in a multilevel directory structure is achieved with directory entries that are links pointing to a node containing information about a shared file. Information in this node includes (1) the owner of the file, (2) a count of the number of links to the tile, and (3) the disk block numbers of the file. What is a primary drawback to this approach to sharing?", "choices": [{"label": "A", "text": "If the owner modifies the file, another user who does not share will see the changes."}, {"label": "B", "text": "If the owner renames the file, other users will not be able to access it."}, {"label": "C", "text": "If the owner is allowed to delete a file, dangling links may result."}, {"label": "D", "text": "If any user who shares the file appends to it, others who share it will not be able to access the new disk blocks."}], "answerKey": "C", "model_answer": ""}
{"question": "Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves. Which of the following data structures will allow mergesort to work in O(n log n) time?\nI. A singly linked list\nII. A doubly linked list\nIII. An array", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": ""}
{"question": "If p(x) is the minimal-degree interpolating polynomial for the real-valued function f(x) at the n + 1 distinct real numbers x0, .... xn what is the maximum possible degree of p(x)?", "choices": [{"label": "A", "text": "n"}, {"label": "B", "text": "n + 1"}, {"label": "C", "text": "n + 2"}, {"label": "D", "text": "2n"}], "answerKey": "A", "model_answer": "LECTURE: A polynomial is a function of the form f(x) = a0 + a1x + a2x2 + ... + anxn, where a0, a1, a2, ..., an are complex numbers and x is a complex number.\nThe degree of a polynomial is the largest absolute value of its coefficients. If a polynomial is zero, then its degree is infinity.\nThe minimal-degree interpolating polynomial for the real-valued function f(x) at the real numbers x0, x1, ..., xn is the polynomial of least degree that passes through the points (x0, f(x0)), (x1, f(x1)), ..., (xn, f(xn)).\nThe maximum possible degree of this polynomial is n + 1."}
{"question": "An internal hash table has 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is", "choices": [{"label": "A", "text": "3"}, {"label": "B", "text": "8"}, {"label": "C", "text": "10"}, {"label": "D", "text": "13"}], "answerKey": "A", "model_answer": ""}
{"question": "TCP protocol is responsible (among other things) for", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "C", "model_answer": ""}
{"question": "Let A and B be two sets of words (strings) from \u03a3*, for some alphabet of symbols \u03a3. Suppose that B is a subset of A. Which of the following statements must always be true of A and B ?\nI. If A is finite, then B is finite.\nII. If A is regular, then B is regular.\nIII. If A is context-free, then B is context-free.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A set is infinite if it has more than a finite number of elements.\nA set is finite if it has a finite number of elements.\nThe set of all positive integers is finite. The set of all odd positive integers is finite. The set of all integers is infinite. The set of all even integers is infinite.\nA set is regular if each word in the set is derived from one or more smaller words by moving the string of symbols to the left.\nThe set of all palindromes is a set of regular words. A palindrome is a word that is made up of the same symbols and has the same length.\nThe set of all words with an even number of symbols is a set of regular words.\nA set is context-free if it does not have a string that is derived from a smaller string by moving the string of symbols to the left.\nThe set of all palindromes is a set of context-free words.\nThe set of all words with an even number of symbols is a set of context-free words.\nSOLUTION: B.\nIf A is regular, then B is regular.\nIf a set is a subset of another set, and that set is regular, then the smaller set is also regular."}
{"question": "For all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings. Which of the following is true?", "choices": [{"label": "A", "text": "a^M = a"}, {"label": "B", "text": "(ax)^M = (xa)^M"}, {"label": "C", "text": "(xy)^M = y^Mx^M"}, {"label": "D", "text": "None of the above"}], "answerKey": "D", "model_answer": "LECTURE: A recursive function is a function that defines values for other functions. A recursive function can be defined using a recurrence, which is a formula that defines the function in terms of smaller instances of itself.\nFor example, the factorial function, n!, can be defined recursively by the formulas:\nn! = 1, when n = 0.\nn! = n \u00d7 (n - 1)!, when n \u2265 1.\nThe recursive definition of n! can be shown with a recurrence table and a graph.\nThe table shows n! for some values of n. The values are calculated by iterating the recursive formula until the right-hand side does not change:\nn! = 1.\nn! = 2.\n3! = 2 \u00d7 1 = 2.\n4! = 4 \u00d7 3 = 12.\nThe graph of the recursive function shows a fractal shape. The graph is made up of many smaller copies of the function.\nSOLUTION: Use the recurrence to define the function x^M.\nIf w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nSo, (ax)^M = (xa)^M."}
{"question": "Which of the following is NOT a reasonable justification for choosing to busy-wait on an asynchronous event?", "choices": [{"label": "A", "text": "The wait is expected to be short."}, {"label": "B", "text": "A busy-wait loop is easier to code than an interrupt handler."}, {"label": "C", "text": "There is no other work for the processor to do."}, {"label": "D", "text": "The program executes on a time-sharing system."}], "answerKey": "D", "model_answer": "LECTURE: Asynchronous events are actions that do not require the processor to be present. They can be considered \"background\" tasks.\nWhen an asynchronous event occurs, the processor is not tied up doing that task. Instead, the task is placed in a queue, and a handler is invoked later to handle the task. This allows the processor to continue working on other tasks.\nA busy-wait loop is a loop that waits for an asynchronous event by constantly checking if the event has occurred. This is a simple way to handle an asynchronous event, but it wastes CPU time.\nA better way to handle asynchronous events is to use interrupts. When the event occurs, the processor is interrupted, and a special piece of code called an interrupt handler is run to handle the event. The processor can then return to the previous task, which is resumed where it left off.\nSOLUTION: A busy-wait loop is easier to code than an interrupt handler.\nThis is not a reasonable justification for choosing to busy-wait on an asynchronous event.\nThere is no other work for the processor to do.\nThis is a reasonable justification for choosing to busy-wait on an asynchronous event.\nThe program executes on a time-sharing system.\nA time-sharing system is a system that allows many programs to share a single processor. The processor switches rapidly between each program.\nIn a time-sharing system, it is usually better to use interrupts instead of busy-waits. This is because busy-waits can cause the processor to miss its turn."}
{"question": "The language {ww | w in (0 + 1)*} is", "choices": [{"label": "A", "text": "not accepted by any Turing machine"}, {"label": "B", "text": "accepted by some Turing machine, but by no pushdown automaton"}, {"label": "C", "text": "accepted by some pushdown automaton, but not context-free"}, {"label": "D", "text": "context-free, but not regular"}], "answerKey": "B", "model_answer": "LECTURE: A programming language is a formal language, a set of symbols and rules that can be used to build programs. A Turing machine is a theoretical machine that can simulate any computer or algorithm. A pushdown automaton is a simpler type of Turing machine.\nA language is said to be accepted by a Turing machine if there exists a Turing machine that will accept any input and halt. A language is said to be recognized by a pushdown automaton if there exists a pushdown automaton that will accept any input and halt.\nThe types of Turing machines and pushdown automata are described below.\nType | Description\nTuring machine | A Turing machine is a theoretical machine that can simulate any computer or algorithm. A Turing machine has an infinite tape that it uses to simulate the memory of the computer. A Turing machine can modify its behavior based on the content of the tape.\nPushdown automaton | A pushdown automaton is a simpler type of Turing machine. It is a theoretical machine that can also simulate an algorithm. A pushdown automaton has a finite tape and a stack of memory. Pushdown automata define regular languages.\nThe types of languages that can be recognized by Turing machines and pushdown automata are described below.\nType | Description\nRegular | A regular language is a language that can be defined by a regular expression. Regular languages are defined by a set of rules that describe the language's structure.\nContext-free | A context-free language is a language that can be defined by a context-free grammar. Context-free languages are defined by a set of rules that describe the language's structure.\nContext-sensitive | A context-sensitive language is a language that can be defined by a context-sensitive grammar. Context-sensitive languages are defined by a set of rules that describe the language's structure.\nNon-deterministic | A non-deterministic language is a language that can be defined by a non-deterministic automaton. A non-deterministic automaton is a type of Turing machine that has an extra element, called a non-deterministic choice, that allows the machine to guess what happens next."}
{"question": "Which of the following statements about Ethernets is typically FALSE?", "choices": [{"label": "A", "text": "Ethernets use circuit switching to send messages."}, {"label": "B", "text": "Ethernets use buses with multiple masters."}, {"label": "C", "text": "Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly."}, {"label": "D", "text": "Networks connected by Ethernets are limited in length to a few hundred meters."}], "answerKey": "A", "model_answer": "LECTURE: In a network, a protocol is a set of rules that devices use to communicate with each other. Ethernet is a protocol, and Ethernet protocols define how devices can use the Ethernet network. One part of the Ethernet protocol is the method that devices use to transmit messages. There are two ways that messages can be transmitted:\nCircuit switching: One sender and one receiver are assigned a dedicated circuit. The sender can transmit the message over this circuit, and the receiver can receive the message.\nMessage switching: Many senders can transmit messages to many receivers. The messages may take different paths through the network.\nEthernet protocols use a message-switching method. This means that many senders can transmit messages to many receivers. The messages may take different paths through the network.\nAn Ethernet network can have multiple communication paths. This makes Ethernet networks relatively immune to clogs. If one communication path is clogged, messages can still be transmitted over the other communication paths.\nSOLUTION: The third statement is typically false. Ethernet protocols do use a collision-detection method to ensure that messages are transmitted properly. When two or more devices want to transmit a message, a collision occurs. The devices can detect that a collision has occurred, and each device will wait for a random amount of time. The devices will then try to transmit the message again."}
{"question": "Let P be a procedure that for some inputs calls itself (i.e., is recursive). If P is guaranteed to terminate, which of the following statements must be true?\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: Procedures may have access to local variables, parameters, or global variables.\nLocal variables are used to store data that is needed by a procedure. Local variables are not shared with other procedures, and their values are not saved when the procedure is called.\nParameters are passed into a procedure. A procedure may have an arbitrary number of parameters.\nGlobal variables are used to store data that is shared by all procedures.\nThe following statements describe procedures that have access to some variables, but not necessarily to all types of variables:\nProcedure P has a local variable.\nProcedure P does not have a parameter.\nProcedure P does not call itself.\nProcedure P does not use a global variable."}
{"question": "Which of the following comes closest to being a perfectly secure encryption scheme?", "choices": [{"label": "A", "text": "The Caesar Cipher, a substitution cipher"}, {"label": "B", "text": "DES (Data Encryption Standard), a symmetric-key algorithm"}, {"label": "C", "text": "Enigma, a transposition cipher"}, {"label": "D", "text": "One-time pad"}], "answerKey": "D", "model_answer": "LECTURE: Encryption is the process of transforming plaintext (unencrypted text) into ciphertext (encrypted text) to protect it from adversaries. An encryption scheme is a method for encrypting and decrypting messages.\nA perfectly secure encryption scheme is an encryption scheme that cannot be broken by any adversary. This means that the scheme is both unbreakable and secure.\nThe One-time pad is a perfectly secure encryption scheme. It is a method for encrypting messages by converting them into random-looking ciphertext using a random key. The key is used only once, and the encryption process ensures that the ciphertext does not reveal any information about the plaintext.\nThe other encryption schemes are not perfectly secure.\nThe Caesar Cipher is a substitution cipher. It is a method for encrypting messages by replacing each letter with a different letter a certain number of positions down the alphabet. For example, the Caesar Cipher with a shift of 3 replaces each letter with the letter that is 3 positions down the alphabet.\nThe Caesar Cipher is not perfectly secure. An adversary can use frequency analysis to break the cipher.\nFrequency analysis is a method for encrypting and decrypting messages by analyzing the frequency of letters in the ciphertext. The most frequently occurring letter is the most likely to be the most frequently occurring letter in the plaintext.\nDES is a symmetric-key algorithm. It is a method for encrypting messages using the same key for both encryption and decryption.\nDES was once a popular encryption scheme, but it has been broken by modern computers.\nEnigma is a transposition cipher. It is a method for encrypting messages by rearranging them without changing the letters. For example, the Enigma cipher may reorder letters or swap the order of pairs of letters.\nEnigma was used by the Germans during World War II. It was broken by the Allies, who were able to read German messages.\nSOLUTION: The One-time pad is the only perfect encryption scheme. The other schemes are not perfect."}
{"question": "Of the following problems concerning a given undirected graph G, which is currently known to be solvable in polynomial time?", "choices": [{"label": "A", "text": "Finding a longest simple cycle in G"}, {"label": "B", "text": "Finding a shortest cycle in G"}, {"label": "C", "text": "Finding ALL spanning trees of G"}, {"label": "D", "text": "Finding a largest clique in G"}], "answerKey": "B", "model_answer": ""}
{"question": "The IP protocol is primarily concerned with", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "A", "model_answer": ""}
{"question": "Of the following, which best approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N?", "choices": [{"label": "A", "text": "1/K"}, {"label": "B", "text": "K-1/K"}, {"label": "C", "text": "log_10 (1/N)"}, {"label": "D", "text": "N-1/m"}], "answerKey": "A", "model_answer": "LECTURE: In a complete K-ary tree, the number of nodes is K times the number of children of the root.\nFor example, in a complete 3-ary tree, the number of nodes is 3 times the number of children of the root.\nIf the root has 2 children, then the number of nodes is 3.\nIf the root has 4 children, then the number of nodes is 9.\nSOLUTION: In a complete K-ary tree, the number of nodes is K times the number of children of the root.\nSo, the number of nonterminal nodes is K times the number of terminal nodes.\nThere are N terminal nodes in a complete K-ary tree of depth N.\nSo, the ratio of the number of nonterminal nodes to the total number of nodes is K:1."}
{"question": "Consider a computer system in which processes can request and release one or more resources. Once a process has been granted a resource, the process has exclusive use of that resource until it is released. If a process requests a resource that is already in use, the process enters a queue for that resource, waiting until the resource is available. Which of the following will NOT deal effectively with the problem of deadlock?", "choices": [{"label": "A", "text": "Giving priorities to processes and ordering the wait queues by priority"}, {"label": "B", "text": "Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all"}, {"label": "C", "text": "Numbering the resources and requiring that processes request resources in order of increasing number"}, {"label": "D", "text": "Having processes time out and restart after a random interval of waiting"}], "answerKey": "A", "model_answer": ""}
{"question": "\"Magic memory\"' has two operations: Read and Clear. Both are indivisible and mutually exclusive. Clear sets the magic memory to zero. Read returns a value that represents the number of Read operations since the last Clear operation. Which of the following is (are) true of \"Magic memory\"?\nI. It can provide the functionality of an atomic Test-and-Set.\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nIII. It is only useful on a multiprocessor.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: Atomic operations allow processes to coordinate and synchronize their activities. Atomicity is important for avoiding race conditions and other problems that can occur when multiple processes access shared data without coordination.\nAn operation is indivisible if it cannot be interrupted by another process. Indivisible operations ensure that a process can complete the operation without interference from other processes.\nAn operation is mutually exclusive if it and another operation cannot be executed at the same time. Mutually exclusive operations ensure that a process can execute an operation without being interrupted by another process.\n\"Magic memory\" has two operations: Read and Clear. Both operations are indivisible and mutually exclusive. So, \"Magic memory\" is a magic number.\nA magic number returns a value that is fixed and known at compile time. Magic numbers are not objects.\nA magic number is only useful on a multiprocessor.\nThe Write operation is not indivisible or mutually exclusive.\nThe Read operation returns a value that represents the number of Read operations since the last Clear operation. This behavior is similar to a magic number.\nA magic number can provide the functionality of an atomic Test-and-Set.\nA magic number can be used to coordinate processes running on a shared-memory multiprocessor."}
{"question": "Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?", "choices": [{"label": "A", "text": "Abstract Syntax Tree (AST)"}, {"label": "B", "text": "Attribute Grammar"}, {"label": "C", "text": "Symbol Table"}, {"label": "D", "text": "Semantic Stack"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following algorithms has running time \u0398(n^2) in the worst case but \u0398(n log n) on average?", "choices": [{"label": "A", "text": "Bubblesort"}, {"label": "B", "text": "Mergesort"}, {"label": "C", "text": "Heapsort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "D", "model_answer": "LECTURE: In the worst case, Heapsort has running time \u0398(n^2), but in the average case, it has running time \u0398(n log n).\nMergesort has running time \u0398(n log n) in the worst case and in the average case.\nBubblesort has running time \u0398(n^2) in the worst case.\nQuicksort has running time \u0398(n log n) in the average case and \u0398(n^2) in the worst case."}
{"question": "Languages with a structure that implements abstract data types (e.g., a C++ class) can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation). Which of the following statements about comparisons between direct and indirect representations is (are) true?\nI. Indirect representation noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: A structure is a composite type that groups related data components. A structure type acts like a reference type for its components. You can use a structure type as the type of a variable, and you can access the components of a structure variable using the dot operator.\nSome structures, known as abstract data types, cannot be directly accessed as components. The components of an abstract data type are hidden, and you can only access them using the operations of the abstract data type.\nA class is an abstract data type. A class is a structure with a few additional features:\nIt can have a default constructor.\nIt can have a destructor.\nIt can have a copy constructor.\nIt can have a assignment operator.\nIt can have a subscript operator.\nThe Class.cs class, provided in the .NET Framework, is an example of a class.\nThe following diagram shows the structure of a class:\nA class can have any number of members. A member is a variable or a method.\nA class can have a default constructor, a destructor, a copy constructor, and a assignment operator. These components are called the class's members.\nA class can also have a subscript operator. The subscript operator is used to access elements of a class.\nFor example, the following C# code shows how to define a class and use it:\nclass Point\n{\npublic int x;\npublic int y;\npublic Point(int x, int y)\n{\nthis.x = x;\nthis.y = y;\n}\n}\n```\n// Use the Point class.\nPoint p1 = new Point(10, 20);\nint x = p1.x;\nint y = p1.y;\n```\n}"}
{"question": "Which of the following is NOT a property of bitmap graphics?", "choices": [{"label": "A", "text": "Fast hardware exists to move blocks of pixels efficiently."}, {"label": "B", "text": "Realistic lighting and shading can be done."}, {"label": "C", "text": "All line segments can be displayed as straight."}, {"label": "D", "text": "Polygons can be filled with solid colors and textures."}], "answerKey": "C", "model_answer": "LECTURE: Bitmap graphics are made up of a grid of pixels, or points of color. Graphics made up of pixels are called raster graphics.\nA property of a graphic is a feature of the graphic. For bitmap graphics, some properties include:\nFast hardware exists to move blocks of pixels efficiently.\nRealistic lighting and shading can be done.\nAll line segments can be displayed as straight.\nPolygons can be filled with solid colors and textures.\nSOLUTION: One of the properties of bitmap graphics is that all line segments can be displayed as straight. However, this property is not strictly true. For example, the two line segments that form the base of a triangle may not be straight."}
{"question": "Which of the following is true of interrupts?", "choices": [{"label": "A", "text": "They are generated when memory cycles are \"stolen\"."}, {"label": "B", "text": "They are used in place of data channels."}, {"label": "C", "text": "They can indicate completion of an I/O operation."}, {"label": "D", "text": "They cannot be generated by arithmetic operations."}], "answerKey": "C", "model_answer": "LECTURE: Interrupts are a way for a computer's processor to be notified that something important has happened. When an interrupt occurs, the processor will stop executing the current task and start executing the task associated with the interrupt.\nInterrupts are generated by hardware, but they can be triggered by software. For example, a keyboard controller can interrupt the processor to let it know that new data is available.\nInterrupts cannot be generated by arithmetic operations, but they can be generated by other hardware events. For example, a timer controller can interrupt the processor to let it know that a specified amount of time has expired.\nSOLUTION: The correct answer is C.\nWhen an I/O operation is completed, the I/O device can generate an interrupt. The processor can then begin executing the appropriate task."}
{"question": "In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. Which of the following are true of such a tree?\nI. Worst-case search time is logarithmic in the number of nodes.\nII. Average-case search time is logarithmic in the number of nodes.\nIII. Best-case search time is proportional to the height of the tree.\nIV. The height of the tree is logarithmic in the number of nodes.", "choices": [{"label": "A", "text": "I and III only"}, {"label": "B", "text": "II and III only"}, {"label": "C", "text": "II and IV only"}, {"label": "D", "text": "I, II, and IV"}], "answerKey": "D", "model_answer": "LECTURE: In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. This means that, for any node in the tree, the height of the left descendant is equal to the height of the node, and the height of the right descendant is equal to the height of the node plus 1.\nFor example, consider a height-balanced binary search tree. The height of each node is indicated by its height in the drawing.\nThe height of a node is equal to the height of its left descendant.\nThe height of a node is equal to the height of its right descendant.\nA height-balanced binary search tree must have a height of at most log2(n) + 1, where n is the number of nodes in the tree.\nTo see why, consider the height of the tree. The height of the tree is equal to the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 2 + the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 2 + 2 + the height of the leftmost node. And the height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 2 + 2 + 2 + the height of the leftmost node. And the height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 2 + 2 + 2 + 2 + the height of the leftmost node. Continuing this process, the height of the tree is equal to log2(n) + the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to log2(n) + log2(n) + the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 2 log2(n) + the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 2 log2(n) + 2 log2(n) + the height of the leftmost node. And the height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 3 log2(n) + the height of the leftmost node. Continuing in this way, the height of the tree is equal to log2(n) + log2(n) + log2(n) + the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to log2(n) + 2 log2(n) + log2(n) + the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to log2(n) + 2 log2(n) + 2 log2(n) + the height of the leftmost node. And the height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 3 log2(n) + the height of the leftmost node. Continuing in this way, the height of the tree is equal to log2(n) + log2(n) + log2(n) + log2(n) + the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to log2(n) + 2 log2(n) + 2 log2(n) + log2(n) + the height of the leftmost node. The height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to log2(n) + 2 log2(n) + 2 log2(n) + 2 log2(n) + the height of the leftmost node. And the height of the leftmost node is equal to the height of its left descendant. So, the height of the tree is equal to 3 log2(n) + log2(n) +"}
{"question": "Bob writes down a number between 1 and 1,000. Mary must identify that number by asking \"yes/no\" questions of Bob. Mary knows that Bob always tells the truth. If Mary uses an optimal strategy, then she will determine the answer at the end of exactly how many questions in the worst case?", "choices": [{"label": "A", "text": "1,000"}, {"label": "B", "text": "999"}, {"label": "C", "text": "500"}, {"label": "D", "text": "10"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following is (are) true about virtual memory systems that use pages?\nI. The virtual address space can be larger than the amount of physical memory.\nII. Programs must be resident in main memory throughout their execution.\nIII. Pages correspond to semantic characteristics of the program.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "LECTURE: In a virtual memory system, the amount of physical memory is divided into pages. The operating system can use these pages to store portions of a program or data that are not currently in main memory. If a program tries to access a page that is not in main memory, the operating system must transfer the page from disk storage to main memory.\nThis transfer process is known as paging.\nSOLUTION: The second and third choices are incorrect.\nA virtual address space can be larger than the amount of physical memory because the operating system can use pages to map a virtual address to a physical address. When a program tries to access a virtual address that is not currently in main memory, the operating system maps the virtual address to a physical address that is in main memory. This process is called paging.\nPrograms do not have to be resident in main memory throughout their execution. Instead, programs can use a process called paging to run in main memory. Paging is a way for the operating system to move portions of a program or data between main memory and disk storage as needed."}
{"question": "Which of the following is usually NOT represented in a subroutine's activation record frame for a stack-based programming language?", "choices": [{"label": "A", "text": "Values of local variables"}, {"label": "B", "text": "A heap area"}, {"label": "C", "text": "The return address"}, {"label": "D", "text": "Stack pointer for the calling activation record"}], "answerKey": "B", "model_answer": "LECTURE: A subroutine is a sequence of statements that performs a specific task. When a subroutine is called, the activation record for the subroutine is stored on the stack. The activation record includes information about the call, such as the return address and the values of local variables.\nThe activation record for a subroutine has the following parts:\n1. Caller's stack pointer: The value of the stack pointer for the calling activation record. This part of the record tells the subroutine where to find its callers stack.\n2. Subroutine's stack pointer: The value of the stack pointer for the called activation record. This part of the record tells the subroutine where to find its own stack.\n3. Return address: The address to which control is transferred when the subroutine returns. This part of the record contains the address of the instruction that follows the subroutine.\nWhen a subroutine is called, the activation record for the subroutine is stored on the stack. The stack pointer for the calling activation record is pushed onto the stack, followed by the return address and the values of any parameters. When the subroutine returns, the return address is popped from the stack and used to transfer control back to the point where the subroutine was called.\nThe activation record for a subroutine is usually represented in a stack-based programming language.\nSOLUTION: A heap area is not part of a subroutine's activation record frame.\nWhen a subroutine is called, the activation record for the subroutine is stored on the stack. The stack pointer for the calling activation record is pushed onto the stack, followed by the return address and the values of any parameters. When the subroutine returns, the return address is popped from the stack and used to transfer control back to the point where the subroutine was called.\nThe activation record for a subroutine does not use a heap area."}
{"question": "Which of the following statements about a remote procedure call is true?", "choices": [{"label": "A", "text": "It is used to call procedures with addresses that are farther than 2^16 bytes away."}, {"label": "B", "text": "It cannot return a value."}, {"label": "C", "text": "It cannot pass parameters by reference."}, {"label": "D", "text": "It cannot call procedures implemented in a different language."}], "answerKey": "C", "model_answer": "LECTURE: Procedures and functions are two ways to split up code into smaller, more manageable pieces.\nA procedure is a named block of code that performs a task.\nA function is a named block of code that performs a specific task and returns a value.\nYou can think of a function as a procedure that also returns a value. Many times, a function will return a value that is used by the code that calls the function.\nSOLUTION: The correct answer is A.\nA remote procedure call is a way for a program to call a procedure that is implemented in a different program or in a different process on the same computer.\nA remote procedure call is made when a program needs to use a procedure that is located in a different place. This is called a \"remote\" procedure call because the procedure is not \"local\" to the calling program.\nA remote procedure call is different from a local procedure call in that a remote procedure call uses a network to call a procedure in a different location."}
{"question": "Of the following sorting algorithms, which has a running time that is LEAST dependent on the initial ordering of the input?", "choices": [{"label": "A", "text": "Insertion sort"}, {"label": "B", "text": "Quicksort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Selection sort"}], "answerKey": "C", "model_answer": "LECTURE: In an insertion sort, the input is sorted by inserting each element into its proper place in a sorted portion of the array. This process is repeated until the entire array is sorted.\nInsertion sort has a running time of O(n^2) for an array of n elements. It is unstable, which means that it can change the order of already-sorted elements. However, it is simple to implement and has a small constant factor, which makes it efficient for small arrays.\nIn a selection sort, the smallest element in the unsorted part of the array is chosen and placed at the beginning of the sorted portion of the array. This process is repeated until the entire array is sorted.\nSelection sort has a running time of O(n^2) for an array of n elements. It is stable, which means that it does not change the order of already-sorted elements.\nIn a bubble sort, the elements in the unsorted part of the array are compared with each other and swapped if they are in the wrong order. This process is repeated until the entire array is sorted.\nBubble sort has a running time of O(n^2) for an array of n elements. It is stable, which means that it does not change the order of already-sorted elements.\nIn a merge sort, the array is divided into two parts, and each part is sorted separately. Then, the two sorted parts are merged into one sorted array.\nMerge sort has a running time of O(n log n) for an array of n elements. It is a stable sort.\nIn a quicksort, the smallest element in the unsorted part of the array is chosen and placed at the beginning of the sorted portion of the array. This process is repeated until the entire array is sorted.\nQuicksort has a running time of O(n log n) for an array of n elements. It can be unstable, which means that it can change the order of already-sorted elements."}
{"question": "A particular parallel program computation requires 100 seconds when executed on a single processor. If 40 percent of this computation is \"inherently sequential\" (i.e., will not benefit from additional processors), then the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are", "choices": [{"label": "A", "text": "20 and 10 seconds"}, {"label": "B", "text": "30 and 15 seconds"}, {"label": "C", "text": "50 and 25 seconds"}, {"label": "D", "text": "70 and 55 seconds"}], "answerKey": "D", "model_answer": "LECTURE: To find the theoretically best possible elapsed time for a program running with 2 or 4 processors, you can use the following formula:\nElapsed time = (1 / (number of processors + 1)) \\* (single processor time)\nSOLUTION: The theoretically best possible elapsed time for a program running with 2 processors is 30 seconds. To find this, use the formula above with number of processors = 2 + 1 = 3:\nElapsed time = (1 / (3 + 1)) \\* 100 seconds = 33.3 seconds.\nRounding down, the elapsed time is 30 seconds.\nThe theoretically best possible elapsed time for a program running with 4 processors is 15 seconds. To find this, use the formula above with number of processors = 4 + 1 = 5:\nElapsed time = (1 / (5 + 1)) \\* 100 seconds = 20 seconds."}
{"question": "Consider the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude. In which representation is there overflow from the addition of the integers 011000 and 011000?", "choices": [{"label": "A", "text": "Two's complement only"}, {"label": "B", "text": "Sign and magnitude and one's complement only"}, {"label": "C", "text": "Two's complement and one's complement only"}, {"label": "D", "text": "All three representations"}], "answerKey": "D", "model_answer": "LECTURE: Numbers in computers are represented in a binary (base-2) form. An integer is represented by a set of bits, and each bit has a value of 0 or 1. The value of a binary number is determined by its bits.\nFor example, the binary number 1011 has a value of 13, because the bits are 1, 0, 1, 1. This is the decimal representation of the number.\nThe binary number 011 has a value of 1, because the bits are 0, 1, 1. This is the decimal representation of the number.\nTo represent a number in binary form, you can use the ones place, the tens place, and the hundreds place to hold the bits. For example, the binary number 1011 can be represented in these places:\n123 047 023\nIn general, a binary number is represented by its bits in a variable called a binary variable.\nSOLUTION: In the binary representation of a number, each bit is represented by a 0 or a 1.\nIf a bit is a 1, the result of the operation is equal to the sum of the two bits.\nIf a bit is a 0, the result of the operation is zero.\nFor example, in the binary representation 11, the bits are 1, 1. The first bit is 1, and the second bit is also 1. So, the result of the operation is 1 + 1 = 2.\nIn the binary representation 00, the bits are 0, 0. Both bits are 0, so the result of the operation is 0.\nIn the binary representation 10, the bits are 1, 0. The first bit is 1, and the second bit is 0. So, the result of the operation is 1 + 0 = 1.\nTo add the integers 011000 and 011000, the bits are added bit by bit:\n011000 011000\n101101 101101\nThe result of the addition is 101101. This is the binary representation of the sum.\nTo determine if there is overflow from the addition, look at the largest bit of the binary representation of each number.\nThe largest bit of the binary representation 011000 is 1.\nThe largest bit of the binary representation 011000 is 1.\nThere are two 1s in the binary representation of the sum. Since there are more than two 1s, there is overflow from the addition."}
{"question": "Of the following, which best characterizes computers that use memory-mapped I/O?", "choices": [{"label": "A", "text": "The computer provides special instructions for manipulating I/O ports."}, {"label": "B", "text": "I/O ports are placed at addresses on the bus and are accessed just like other memory locations."}, {"label": "C", "text": "To perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}, {"label": "D", "text": "Ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}], "answerKey": "B", "model_answer": "LECTURE: I/O stands for input/output. When a computer is used to communicate with the outside world, it needs to send and receive data. To do this, the computer's processor uses instructions to communicate with devices that are outside of the computer's main body.\nI/O devices are sometimes connected to the computer through ports. A port is a hardware component that can send and receive data to and from a device. A port is usually connected to a specific memory address. The memory address tells the processor where to find the port.\nMemory-mapped I/O is a method of connecting I/O devices to a computer. In memory-mapped I/O, I/O ports are placed at addresses on the computer's bus. The computer's processor can access the I/O ports like it would access memory. This method of connecting I/O devices to a computer was first used in the IBM PC.\nOf the following, which best characterizes computers that use memory-mapped I/O?\nThe computer provides special instructions for manipulating I/O ports.\nI/O ports are placed at addresses on the bus and are accessed just like other memory locations.\nTo perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation.\nPorts are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}
{"question": "Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that", "choices": [{"label": "A", "text": "integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs"}, {"label": "B", "text": "P = NP"}, {"label": "C", "text": "even if P = NP, integer factorization is still likely not to be polynomial-time computable"}, {"label": "D", "text": "testing primality is computationally intractable"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following sets of bit strings CANNOT be described with a regular expression?", "choices": [{"label": "A", "text": "All bit strings whose number of zeros is a multiple of five"}, {"label": "B", "text": "All bit strings starting with a zero and ending with a one"}, {"label": "C", "text": "All bit strings with an even number of zeros"}, {"label": "D", "text": "All bit strings with more ones than zeros"}], "answerKey": "D", "model_answer": "LECTURE: A regular expression is a pattern that describes a set of strings. Regular expressions are used to search for, or to describe, a set of strings.\nA regular expression consists of a set of characters that are combined to form a pattern. Some of the characters in a regular expression are:\n. and ^. These characters are called metacharacters.\nThe . character matches any single character. For example, the regular expression .A matches any string that has at least one A in it.\nThe ^ character matches the beginning of a string. For example, the regular expression ^A matches any string that starts with an A.\nThe $ character matches the end of a string. For example, the regular expression $A matches any string that ends with an A.\nParentheses can be used to capture a pattern. For example, the regular expression (A|B) matches either A or B.\nSOLUTION: The sets of bit strings can be described with a regular expression as follows:\nAll bit strings whose number of zeros is a multiple of five: this set of bit strings can be described by the regular expression 0^5.\nAll bit strings starting with a zero and ending with a one: this set of bit strings can be described by the regular expression 01\\^.\nAll bit strings with an even number of zeros: this set of bit strings can be described by the regular expression 0(0|2)\\^.\nAll bit strings with more ones than zeros: this set of bit strings can be described by the regular expression 0\\1*."}
{"question": "Which of the following conditions can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac)?\nI. At least three of p_1, p_2, p_3, p_4 are true.\nII. Exactly three of p_1, p_2, p_3, p_4 are true.\nIII. An even number of p_1, p_2, p_3, p_4 are true.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": ""}
{"question": "Two alternatives for interconnecting a set of processors with bidirectional links are (1) the fully interconnected network, in which each processor is directly connected to every other processor, and (2) the ring network, in which each processor is connected to two other processors. The worst-case path length for a network is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes. For each type of interconnection of n processors, a figure of merit can be formed as the product of the number of links required for the network times the worst-case path length connecting any two processors. The ratio of this figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is", "choices": [{"label": "A", "text": "1/(n^2)"}, {"label": "B", "text": "1/(n(n-1))"}, {"label": "C", "text": "1/n"}, {"label": "D", "text": "(n-1)/n"}], "answerKey": "D", "model_answer": ""}
{"question": "For a connected, undirected graph G = (V, E), which of the following must be true?\nI. \u03a3_{v\u2208V} degree(v) is even.\nII. |E| \u2265 |V| \u2212 1\nIII. G has at least one vertex with degree 1.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of vertices and edges. A vertex is a point, and an edge is a line that connects two points.\nA connected graph is a graph that is connected to itself.\nAn undirected graph is a graph without directions.\nSOLUTION: A connected graph has at least one edge.\nA undirected graph has a degree of each vertex that is even. This is because each edge connects two vertices, and each vertex is connected to each other vertex by exactly one edge.\nSo, a connected, undirected graph has at least one vertex with degree 1."}
{"question": "In multiprogrammed systems it is advantageous if some programs such as editors and compilers can be shared by several users. Which of the following must be true of multiprogrammed systems in order that a single copy of a program can be shared by several users?\nI. The program is a macro.\nII. The program is recursive.\nIII. The program is reentrant.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "C", "model_answer": "LECTURE: In a multiprogrammed system, it is important to switch between programs efficiently so that many users can use the system simultaneously.\nA program is reentrant if it can be called from within itself. A program is recursive if it calls itself from within. A macro is a set of instructions that can be defined to replace a older set of instructions."}
{"question": "Which of the following decimal numbers has an exact representation in binary notation?", "choices": [{"label": "A", "text": "0.1"}, {"label": "B", "text": "0.2"}, {"label": "C", "text": "0.3"}, {"label": "D", "text": "0.5"}], "answerKey": "D", "model_answer": ""}
{"question": "Function signatures describe the types of the arguments to a function as well as the return value of the function. For instance, the addition function on reals has a signature of\nadd : real x real -> real\nsince it takes two real numbers and returns a real number. But, for a language that allows functions as return values, addition could be considered to have the signature\nadd : real -> (real -> real)\nwhich means that add takes a single real (the first operand) and returns a new function that itself takes a single real (the second operand) and returns a real (the result). This process of reducing a function with multiple arguments to a function with fewer arguments is called currying. Which of the following is correct?", "choices": [{"label": "A", "text": "Currying can be applied to any function to the point where it has exactly one input argument."}, {"label": "B", "text": "Currying cannot be applied to functions of more than two arguments."}, {"label": "C", "text": "Currying cannot be applied to functions that return functions as arguments."}, {"label": "D", "text": "Currying cannot be applied w functions that haw arguments that are functions."}], "answerKey": "A", "model_answer": ""}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-back policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2000"}], "answerKey": "A", "model_answer": "LECTURE: In a direct-mapped cache, each memory address is associated with a specific cache line. When a memory request is made, the cache searches for a cache line with a matching address. If a cache line with a matching address is found, the cache returns the contents of that line. If no matching line is found, the cache requests the line from the memory.\nDirect-mapped caches can use a write-back policy, in which case the cache will copy updated data back to the memory when the data is evicted from the cache.\nWith a 2K-byte cache and a 8-byte block size, there are 256 blocks in the cache. This means that each block can store 256/8 = 32 bytes.\nSo, each cache line can store a maximum of 32 bytes. This is the minimum amount of data that can be transferred between the cache and the memory.\nThe sum of 256 elements of 4 bytes each is 256 bytes. This is more than 32 bytes. So, at least one cache line will be filled during the transfer."}
{"question": "In which of the following representations of numbers by 8-bit words is the addition of the integers 109 and -42 within range?\nI. One's complement\nII. Two's complement\nIII. Sign and magnitude", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: To add two 8-bit integers, you need to use the method specified by the representation used to store the integers.\nIf the integers are represented using sign and magnitude, then the addition is performed using the rules:\nIf the signs are the same, the sum is the magnitude of the two integers.\nIf the signs are different, the magnitude of the result is the magnitude of the integer with the larger magnitude. The sign of the result is the same as the sign of the integer with the larger magnitude.\nIf one integer is zero, the result is zero.\nIf the integers are represented using one's complement, then the addition is performed using the rules:\nAn integer and its one's complement have the same magnitude.\nThe sign of the result is the opposite of the sign of the integer with the larger magnitude.\nIf one integer is zero, the result is zero.\nIf the integers are represented using two's complement, then the addition is performed using the rules:\nAn integer and its two's complement have the same magnitude.\nThe sign of the result is the opposite of the sign of the integer.\nIf the integer is zero, the result is zero.\nSOLUTION: The integers 109 and -42 are represented in sign and magnitude form. To add the integers, compare the magnitudes of the integers. The magnitude of 109 is greater than the magnitude of -42. So, -42 + 109 = 109."}
{"question": "If a malicious process is granted temporary administrator-level access to a system", "choices": [{"label": "A", "text": "the threat is over as soon as the process is killed"}, {"label": "B", "text": "the threat is over after the operating system is rebooted"}, {"label": "C", "text": "the thread is over after rebooting the machine and replacing files that show a virus infection"}, {"label": "D", "text": "the threat is often permanent until the entire disk is wiped clean"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following statements about horizontal versus vertical microarchitecture is (are) true?\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nII. Horizontal microinstructions are unencoded.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: Microarchitecture is the architecture of a computer's microprocessor, or central processing unit (CPU). The microarchitecture provides the low-level details about how the processor performs tasks.\nMicroarchitecture includes the following components:\nInstruction set: The type of instructions that the processor can understand and execute.\nPipelining: A method used to increase the processor's performance. Pipelining allows the processor to do multiple tasks at the same time.\nMultiple cores: The processor contains multiple processing units, called cores. Each core can execute its own set of instructions.\nMicroarchitecture can have a horizontal or vertical design.\nHorizontal microarchitecture has a single core with multiple pipelines. This design allows each pipeline to execute a different instruction in a program.\nVertical microarchitecture has a single core with a large number of pipelines. This design allows many instructions in a program to be executed at the same time.\nSOLUTION: The second statement is true. Horizontal microinstructions are unencoded. An encoded instruction tells the processor which instruction to execute. Because each instruction has a unique opcode (operation code), horizontal microinstructions do not need to be encoded.\nThe first statement is false. Programs for horizontal architectures do not require more time steps than those for vertical architectures. A time step is a unit of time in a program.\nThe third statement is true. Horizontal microinstructions usually have a single opcode and multiple operand specifiers. An operand is a value that is input to an instruction. A specifier is a way to identify a particular operand."}
{"question": "A \"strictly binary tree\" is a binary tree in which every node that is not a leaf has two children. Suppose that for a class of strictly binary trees there exists c > 0 such that, for any tree in the class, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. Which of the following best characterizes the height h of any tree in this class, where N is the number of nodes in the tree and N > 1 ?", "choices": [{"label": "A", "text": "h <= log2(N)"}, {"label": "B", "text": "h = 1/c * log2(N)"}, {"label": "C", "text": "h < c log2(N)"}, {"label": "D", "text": "h > c log2(N)"}], "answerKey": "C", "model_answer": "LECTURE: In a binary tree, each node has at most two children. The height of a tree is the number of edges from the root to the closest leaf.\nA tree with two children is called a strict binary tree.\nA tree with three children is called a triangle.\nA tree with four children is called a square.\nThe height of a strict binary tree is either 1 or 2.\nSOLUTION: For any strict binary tree, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. So, for any strict binary tree, the height is less than c log2(N)."}
{"question": "Which of the following sorting algorithms has average-case and worst-case running times of O(n log n)?", "choices": [{"label": "A", "text": "Bubble sort"}, {"label": "B", "text": "Insertion sort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "C", "model_answer": "LECTURE: In big O notation, the dominant constant is the value of the algorithm after the second rightmost parenthesis. For example, in big O notation, 2n is the dominant constant, while n is not.\nSo, the sorting algorithm Bubble sort has a worst-case running time of O(n^2), and a best-case running time of O(n). The average-case running time is between the worst-case and best-case running times. Bubble sort has a worst-case and average-case running time of O(n^2), and a best-case running time of O(n).\nThe sorting algorithm Insertion sort has a worst-case running time of O(n^2), but an average-case running time of O(n). The average-case running time is the dominant constant.\nThe sorting algorithm Merge sort has a worst-case running time of O(n log n), and a best-case running time of O(n log n). Merge sort has a worst-case and best-case running time of O(n log n).\nThe sorting algorithm Quicksort has a worst-case running time of O(n^2), but an average-case running time of O(n log n). The average-case running time is the dominant constant."}
{"question": "Consider the following equations concerning a stack module that has the operations Push, Pop, Top, and IsEmpty. Which of the equations does NOT represent the conventional semantics of a stack?", "choices": [{"label": "A", "text": "IsEmpty(Push(Stack,Elem)) = true"}, {"label": "B", "text": "Pop(Push(Stack,Elem)) = Stack"}, {"label": "C", "text": "Top(Push(Stack,Elem)) = Elem"}, {"label": "D", "text": "IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false"}], "answerKey": "A", "model_answer": "LECTURE: Equations that are not valid represent the conventional semantics of a stack.\nA stack is a collection of elements. The top of the stack is the element that has been most recently added to the stack. The bottom of the stack is the element that has been most recently removed from the stack.\nImagine taking the top book off a stack. The book on the bottom of the stack becomes the new top of the stack."}
{"question": "Assume that any assignment statement can be executed in unit time. If as many identical processors as needed are used, what is the minimum number of time units needed to execute the assignments\nA := B + C\nB := A - B\nC := A * E\nD := A/F\nE := B - C\nF := A + B\nwith the same result as if the assignments were executed in the order shown?", "choices": [{"label": "A", "text": "1"}, {"label": "B", "text": "2"}, {"label": "C", "text": "3"}, {"label": "D", "text": "4"}], "answerKey": "C", "model_answer": "LECTURE: Each processor executes the assignments in the order shown.\nStep 1: A := B + C.\nStep 2: B := A - B.\nStep 3: C := A * E.\nStep 4: D := A/F.\nStep 5: E := B - C.\nStep 6: F := A + B."}
{"question": "Two expressions E and F are said to be unifiable if there are substitutions for the variables of E and F that make the expressions lexically identical. In the following three expressions, only w, x, y, and z are variables.\nI. f(w,w)\nII. f(x,1)\nIII. f(y,g(z))\nWhich pairs of these expressions is (are) pairs of unifiable expressions?", "choices": [{"label": "A", "text": "(I, II) only"}, {"label": "B", "text": "(I, III) only"}, {"label": "C", "text": "(II, III) only"}, {"label": "D", "text": "(I, II) and (I, III) only"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following instruction-set features is NOT generally considered an obstacle to aggressive pipelining of an integer unit?", "choices": [{"label": "A", "text": "Condition codes set by every instruction"}, {"label": "B", "text": "Variable-length encoding of instructions"}, {"label": "C", "text": "Instructions requiring widely varying numbers of cycles to execute"}, {"label": "D", "text": "Several different classes (sets) of registers"}], "answerKey": "D", "model_answer": ""}
{"question": "Let k >= 2. Let L be the set of strings in {0, 1}^* such that x \\in L if and only if the number of 0's in x is divisible by k and the number of 1's in x is odd. The minimum number of states in a deterministic finite automaton (DFA) that recognizes L is", "choices": [{"label": "A", "text": "k + 2"}, {"label": "B", "text": "2k"}, {"label": "C", "text": "k log k"}, {"label": "D", "text": "k^2"}], "answerKey": "B", "model_answer": "LECTURE: The minimum number of states in a deterministic finite automaton (DFA) that recognizes a language L is equal to the minimum of the number of states in any DFA that recognizes L.\nSOLUTION: To see why this is true, consider that any DFA that recognizes L has at least as many states as any other DFA that recognizes L. Then, to find the minimum number of states in a DFA that recognizes L, consider a DFA with the fewest possible states that recognizes L.\nFor example, if L is the set of all strings in {0, 1}^* that have an even number of 0's, then a DFA with 2k states can recognize L. The DFA has k states that process 0's and k states that process 1's.\nIf L is the set of all strings in {0, 1}^* that have a odd number of 1's, then a DFA with k states can recognize L. The DFA has k states, each of which processes 1's.\nSo, the minimum number of states in a DFA that recognizes L is 2k."}
{"question": "Let G = (V, E) be a finite directed acyclic graph with |E| > 0. Which of the following must be true?\nI. G has a vertex with no incoming edge.\nII. G has a vertex with no outgoing edge.\nIII. G has an isolated vertex, that is, one with neither an incoming edge nor an outgoing edge.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of vertices and edges.\nA vertex is a point where edges start or end.\nAn edge is a connection between two vertices.\nAn acyclic graph is one that has no edges.\nA directed graph is a graph where each edge has a direction. The direction of an edge tells you which vertex it starts and ends at.\nGiven a directed graph G = (V, E) with |E| > 0, the following are true.\nThere is at least one vertex with an incoming edge. Otherwise, there would be no edges with an incoming edge, and so no edges in the graph.\nThere is at least one vertex with an outgoing edge. Otherwise, there would be no edges with an outgoing edge, and so no edges in the graph.\nThere is a vertex with no incoming or outgoing edge. This vertex has both an incoming and an outgoing edge.\nSOLUTION: G has at least one edge, so G has a vertex with an outgoing edge. Every vertex with an outgoing edge is also a vertex with an incoming edge. So, G has a vertex with no incoming edge."}
{"question": "Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v. Let (u, v) be an edge in G that is not in T, such that pre(u) < pre(v). Which of the following statements about u and v must be true?\nI. post(u) < post(v)\nII. u is an ancestor of v in T.\nIII. If w is the lowest common ancestor of u and v in T, then w = u.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of nodes, or vertices, connected by edges. A depth-first search tree of a connected graph is a tree that results from a depth-first search of the graph.\nThe lowest common ancestor of two vertices in a depth-first search tree is a vertex that is a common ancestor of the two vertices.\nSOLUTION: Let w be the lowest common ancestor of u and v in T. Then, w is a vertex of T that is an ancestor of both u and v, and no child of w is an ancestor of both u and v.\nPre(w) \u2265 pre(u) = pre(v) is a necessary condition for w to be the lowest common ancestor of u and v in T. So, pre(w) \u2265 pre(u).\nIf pre(u) < pre(v), then pre(w) < pre(v). So, post(w) > post(v).\nSince w is a vertex of T that is an ancestor of both u and v, and post(w) > post(v), w is not equal to v. So, II is true.\nSince w is a vertex of T that is an ancestor of both u and v, and no child of w is an ancestor of both u and v, u is an ancestor of v in T. So, II and III are true."}
{"question": "In systems with support for automatic memory management, a garbage collector typically has the responsibility for reclaiming allocated memory objects whose contents cannot affect any future legal computation. Such objects are identified by determining that they cannot be reached from a root set. Which of the following is NOT part of the root set in a typical garbage collector?", "choices": [{"label": "A", "text": "Actual parameters of the active procedures"}, {"label": "B", "text": "Dynamically allocated objects on the heap"}, {"label": "C", "text": "Global variables of the program"}, {"label": "D", "text": "Local variables on the call stack"}], "answerKey": "B", "model_answer": "LECTURE: A garbage collector is a program that reclaims memory that is no longer being used by a program. When a program frees memory that was previously requested by a program, the garbage collector can make that memory available for later use.\nIn a typical garbage collector, the root set is a set of objects that must be reached from the entry point of the program. The garbage collector identifies the root set as the set of objects that must be kept in memory. The garbage collector then identifies all objects that cannot be reached from the root set as candidates for collection.\nThe root set includes the following objects:\nActual parameters of the active procedures: These objects are listed after the procedure name in a call to a procedure.\nDynamic structures contained in the root set: These objects are also part of the root set.\nGlobal variables of the program: These objects are listed outside all procedures.\nThe call stack: This is a last-in, first-out (LIFO) data structure that stores the procedure calls that have not yet returned. The stack is grown when a procedure is called and shrunk when a procedure returns. The call stack is not part of the root set.\nThe correct answer is D."}
{"question": "In the Internet Protocol (IP) suite of protocols, which of the following best describes the purpose of the Address Resolution Protocol?", "choices": [{"label": "A", "text": "To translate Web addresses to host names"}, {"label": "B", "text": "To determine the IP address of a given host name"}, {"label": "C", "text": "To determine the hardware address of a given host name"}, {"label": "D", "text": "To determine the hardware address of a given IP address"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following language features requires that stack-based storage allocation be used rather than static allocation?", "choices": [{"label": "A", "text": "Recursive procedures"}, {"label": "B", "text": "Arbitrary goto's"}, {"label": "C", "text": "Two-dimensional arrays"}, {"label": "D", "text": "Integer-valued functions"}], "answerKey": "A", "model_answer": "LECTURE: In most programming languages, dynamic storage allocation is the default. This means that you do not need to specify how storage will be allocated before you use it.\nSome programming languages provide an alternative way to allocate storage: static allocation. With static allocation, you must specify how much storage is needed when you declare a variable or array.\nBoth stack-based storage allocation and static allocation have different characteristics:\nStack-based allocation starts at a low address and grows upward. It is used for data that is pushed onto the stack, such as function call stacks and local variables.\nStatic allocation starts at a high address and grows downward. It is used for data that is assigned a constant address, such as global variables and arrays.\nLanguage features that require stack-based storage allocation include:\nRecursive procedures: The call stack is used to manage the procedure calls.\nArbitrary goto's: The call stack is used to keep track of the next address to jump to.\nTwo-dimensional arrays: The elements of a two-dimensional array are stored row by row, with each row stored in a different area of memory.\nInteger-valued functions: Each function that is passed an integer argument has its own copy of the argument."}
{"question": "Which of the following is not a sentence that is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z?", "choices": [{"label": "A", "text": "xyz"}, {"label": "B", "text": "xy"}, {"label": "C", "text": "xxzy"}, {"label": "D", "text": "xxxxy"}], "answerKey": "A", "model_answer": "LECTURE: A grammar is a set of rules that describes the structure of a language.\nA grammar for a language consists of:\n* A set of terminals. A terminal is a string of symbols that has no substrings.\n* A set of nonterminals. A nonterminal is a string of symbols that has at least one substring.\n* A set of production rules. A production rule is a pair of nonterminals that produces a single nonterminal or terminal.\nThe grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z defines these:\nTerminals: B, E, y.\nNonterminals: A, C, x.\nProduction rules: A -> BC, C -> B|D, D -> y|Ey, E -> z."}
{"question": "Let T (n) be defined by T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1. Which of the following represents the order of growth of T(n) as a function of n?", "choices": [{"label": "A", "text": "\u0398(n)"}, {"label": "B", "text": "\u0398(n log n)"}, {"label": "C", "text": "\u0398(n^2)"}, {"label": "D", "text": "\u0398(n^2 log n)"}], "answerKey": "C", "model_answer": "LECTURE: As a function grows, its value gets bigger and bigger. The order of a function tells you how quickly the function grows.\nAn order of a function is a way to describe how the function grows. If one function is growing faster than another function, then the faster function has a lower order.\nIf one function is an order of magnitude slower than another function, then the slower function has a higher order.\nAn order of magnitude is a ratio of two values, where one value is much smaller than the other. For example, 0.001 is an order of magnitude smaller than 1.\nSo, if one value is 10 times larger than another value, then the two values are an order of magnitude apart.\nIf one function is 10 times smaller than another function, then the smaller function has a higher order.\nFor example, 6.02 x 10^23 is a higher order than 6.02 x 10^9.\nThe order of a function does not depend on the numbers chosen for the function. Instead, the order of a function depends on the way the function is written.\nFor example, the functions T(n) = 5n and T(n) = 4n have the same order."}
{"question": "Which of the following problems is (are) decidable?\nI. Given a (finite) string w, is w a prefix of the decimal expansion of \u03c0?\nII. Given a program and an input, is the program\u2019s output the decimal expansion of \u03c0?\nIII. Given a program that takes as input a prefix of the decimal expansion of \u03c0, is the program\u2019s output always the same for every prefix?", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: In computer science, a problem is decidable if it can be solved by a computer. That is, a problem is decidable if we can write a program to solve the problem.\nA problem is undecidable if it can't be solved by a computer.\nSome problems are undecidable because they ask too much. For example, the halting problem is undecidable. The halting problem asks whether a program will ever stop running. Will it ever stop? We can't answer that question with certainty.\nSome problems are undecidable because the answer is unknown. For example, the Robinson problem is undecidable. The Robinson problem asks whether the sum of the positive integers is odd or even. The answer to this question is unknown.\nA problem is solvable if it can be solved by a computer.\nA problem is unsolvable if it can't be solved by a computer.\nSome problems are unsolvable because they ask too little. For example, the problem of determining whether two numbers are both odd is unsolvable. The problem asks whether there are two numbers that are both odd. The answer is yes.\nSome problems are unsolvable because the answer is unknown. For example, the problem of determining whether the sum of the positive integers is odd or even is unsolvable. The answer to this question is unknown.\nSOLUTION: I. This problem is decidable. We can write a program to check if a string is a prefix of the decimal expansion of \u03c0.\nII. This problem is decidable. We can write a program to check if a program's output is the decimal expansion of \u03c0.\nIII. This problem is decidable. We can write a program to check if a program's output is always the same for every prefix of the decimal expansion of \u03c0."}
{"question": "Which of the following statements about circuits is (are) true?\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nIII. Both sequential and combinational circuits must be controlled by an external clock.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: A circuit is a set of components connected by wires. An electric circuit is a closed loop of wire that has a return path for the electric current.\nThere are two types of circuits: combinational and sequential.\nA combinational circuit has a simple set of rules that determine its output. The output depends on the current input.\nA sequential circuit has a set of output stages that are triggered by the input. The output stages are \"enabled\" by the input.\nSOLUTION: The statement \"Combinational circuits may have feedback; sequential circuits do not\" is true.\nA combinational circuit may have signals that loop back and influence the input. This is called feedback.\nA sequential circuit may not have feedback. The output of a sequential circuit is determined by the current input.\nThe statement \"Combinational circuits have a \"memoryless\" property; sequential circuits do not\" is true.\nA combinational circuit has a memoryless property. This means that the output of a combinational circuit is not dependent on its previous state.\nA sequential circuit has a memory. This means that the output of a sequential circuit is dependent on its previous state.\nThe statement \"Both sequential and combinational circuits must be controlled by an external clock\" is false.\nSome combinational circuits are controlled by an external clock. But some combinational circuits do not have to be.\nSome sequential circuits are controlled by an external clock. But some sequential circuits do not have to be."}
{"question": "Two single-user workstations are attached to the same local area network. On one of these workstations, file pages are accessed over the network from a file server; the average access time per page is 0.1 second. On the other of these workstations, file pages are accessed from a local disk; the average access time per page is 0.05 second. A particular compilation requires 30 seconds of computation and 200 file page accesses. What is the ratio of the total time required by this compilation if run on the diskless (file server) workstation to the total time required if run on the workstation with the local disk, if it is assumed that computation is not overlapped with file access?", "choices": [{"label": "A", "text": "1/1"}, {"label": "B", "text": "5/4"}, {"label": "C", "text": "5/3"}, {"label": "D", "text": "10/5"}], "answerKey": "B", "model_answer": ""}
{"question": "Assume that a debugger places a breakpoint at a load instruction at virtual address 0x77E81234 (hexadecimal notation) in a debugged process P. If the text segment of P begins at 0x77E80000 in P\u2019s virtual address space and if the debugger has mapped this same text segment at 0x01000000 in its virtual address space, which of the following is the virtual address used by the debugger in its WRITE operation, along with a description of how the debugger has mapped the virtual memory page containing this address?", "choices": [{"label": "A", "text": "0x01001234; page mapped with READ/WRITE access"}, {"label": "B", "text": "0x01001234; page mapped with COPY-ON-WRITE access"}, {"label": "C", "text": "0x76E81234; page mapped with READ/WRITE access"}, {"label": "D", "text": "0x76E81234; page mapped with COPY-ON-WRITE access"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following considerations applies (apply) to choosing the page size in a paging system?\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: In a paging system, the operating system uses a page table to map virtual addresses to physical addresses. The page table has one entry for each page, and each entry specifies a framesize and a physical address.\nWhen a process is running, it uses virtual addresses. The virtual address is made up of a page number and an offset. The page number identifies the page that the data is located on, and the offset is the actual location of the data within the page.\nThe framesize is the size of the memory blocks that the system uses to service the page. Each frame holds a single page of memory. The physical address is the location of the frame that holds the page.\nIf a process uses a virtual address that is not mapped in the page table, the process is said to have a page fault. When a page fault occurs, the operating system performs the following actions:\n1. Find the page table entry that is associated with the virtual address.\n2. If the framesize is too large, split the page table entry into two entries.\n3. Add the entry for the new page to the page table.\n4. Associate the new page with the virtual address.\n5. Service the page fault by using the new page table entry to get the physical address of the data.\nSOLUTION: The dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.\nThis consideration applies to choosing the page size.\nAn advantage of larger pages is that they lead to smaller page tables.\nThis consideration does not apply to choosing the page size.\nAn advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nThis consideration applies to choosing the page size."}
{"question": "Two processors, M-5 and M-7, implement the same instruction set. Processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. Processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds. Which of the following is (are) true?\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline.\nII. The latency of a single instruction is shorter on M-7\u2019s pipeline than on M-5\u2019s pipeline.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III"}, {"label": "D", "text": "II and III"}], "answerKey": "A", "model_answer": "LECTURE: Pipelining is a technique that allows multiple instructions to be processed simultaneously. A processor with pipelining has multiple execution units, each of which is designed to handle one step in the processing of an instruction. For example, a processor with pipelining might have one execution unit for fetching instructions, one for decoding them, one for executing them, and one for writing the results.\nWhen a processor is processing an instruction, it will typically have to fetch the next instruction before it can start executing the current instruction. Pipelining helps to overcome this limitation by allowing the processor to start executing the current instruction before the next instruction has been fetched.\nIf the processor encounters a delay (such as a memory access or an I/O operation) while processing an instruction, the other execution units in the pipeline can continue to work on the next instructions in the pipeline. This means that instructions that are waiting for a delay can complete more quickly than they would if they were processed in a linear fashion.\nSOLUTION: M-7's pipeline has a shorter pipeline and a shorter clock cycle than M-5's pipeline. So, M-7's pipeline has a better maximum throughput than M-5's pipeline.\nThe latency of a single instruction is shorter on M-7's pipeline than on M-5's pipeline. This is because M-7's pipeline has one stage less than M-5's pipeline.\nPrograms executing on M-7 will always run faster than programs executing on M-5. This is because M-7's pipeline can process instructions in less time than M-5's pipeline."}
{"question": "Which of the following pairs of 8-bit, two's-complement numbers will result in overflow when the members of the pairs are added?", "choices": [{"label": "A", "text": "11111111, 00000001"}, {"label": "B", "text": "00000001, 10000000"}, {"label": "C", "text": "11111111, 10000001"}, {"label": "D", "text": "10000001, 10101010"}], "answerKey": "D", "model_answer": ""}
{"question": "Two computers communicate with each other by sending data packets across a local area network. The size of these packets is 1,000 bytes. The network has the capacity to carry 1,000 packets per second. The CPU time required to execute the network protocol to send one packet is 10 milliseconds. The maximum rate at which one computer can send data to another is approximately", "choices": [{"label": "A", "text": "10,000 bytes/second"}, {"label": "B", "text": "25,000 bytes/ second"}, {"label": "C", "text": "100,000 bytes/ second"}, {"label": "D", "text": "500,000 bytes/ second"}], "answerKey": "C", "model_answer": ""}
{"question": "Consider the following grammar.\nS \u2192 ( S )\nS \u2192 x\nWhich of the following statements is (are) true?\nI. The grammar is ambiguous.\nII. The grammar is suitable for top-down parsing.\nIII. The grammar is suitable for bottom-up parsing.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: Grammar is a set of rules that describe how to use a language. A grammar can describe a language in terms of the sounds (phones and phonemes), words (lexicon), and phrases (syntax) that make up that language.\nA grammar for a language consists of two parts: a set of rules and a set of definitions. Rules relate specific phrases to other phrases. Definitions explain the meaning of words.\nThe rules and definitions in a grammar specify which phrases are grammatical and which are ungrammatical. A grammar can also specify which phrases are possible and which are impossible.\nA grammar is a set of rules and definitions that describe the language. It is not a set of instructions for speaking and writing.\nSOLUTION: The grammar is suitable for top-down parsing.\nTop-down parsing involves starting with the overall sentence and working down to the individual words.\nThe grammar is suitable for top-down parsing because the nonterminal S has two productions:\nS \u2192 ( S )\nS \u2192 x.\nThese productions are precedence constraints. They indicate that a nonterminal S can derive an S, or it can derive an x.\nAn algorithm that uses top-down parsing to analyze a sentence will match the input against the productions of the nonterminal."}
{"question": "Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT:", "choices": [{"label": "A", "text": "Counting distinct values: Given a set of n keys, determine the number of distinct key values."}, {"label": "B", "text": "Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary."}, {"label": "C", "text": "Range search: Given values a and b, find all the records whose key value is in the range a, b."}, {"label": "D", "text": "Symbol table lookup: Given a program identifier, find its type and address."}], "answerKey": "C", "model_answer": "LECTURE: A hash table is a data structure that uses a hash function to map data to a specific table.\nA hash function is a function that takes a data item as input and returns a value. The value returned by a hash function is called a hash code.\nA hash table uses a hash function to determine the specific table where a piece of data should be stored. To find the location of a data item in a hash table, the hash function is applied to the data item. This returns the specific table where the data item should be stored.\nSOLUTION: A hash table can contribute to an efficient average-case solution for counting distinct values. To do this, use the hash function to map each key to a specific table. Then, count the number of tables. This allows you to count the number of distinct key values.\nA hash table cannot support insert, delete, and search operations. To insert a record into a hash table, the hash function must determine the specific table where the record should be stored. But the hash function is not aware of the other records that are already in the table. So, the record may be inserted into an already occupied table.\nTo delete a record from a hash table, you must search for the record's key in the table. This is difficult to do efficiently because a hash function is used to map keys to tables, and a hash function is not reversible. This means that it is not possible to find the key that is mapped to a specific table.\nA range search can be performed using a hash table. To find the records whose key value is in the range a, b, use the hash function to map a and b to specific tables. Then, search each table for the records with key values in the range.\nA symbol table lookup is a lookup operation that uses a symbol table to find the type and address of a program identifier. A symbol table is a data structure that maps symbol names to their values. A symbol is a name that is used in a program.\nA hash table cannot do a symbol table lookup. A hash table uses a hash function to map data to a specific table. A symbol table maps symbol names to their values. These are two different operations."}
{"question": "Let A be a finite set with m elements, and let B be a finite set with n elements. The number of distinct functions mapping A into B is", "choices": [{"label": "A", "text": "n^m"}, {"label": "B", "text": "n!/(n - m)!"}, {"label": "C", "text": "n!"}, {"label": "D", "text": "n!/(m!(n - m)!)"}], "answerKey": "A", "model_answer": ""}
{"question": "To compute the matrix product M_1M_2, where M_1 has p rows and q columns and where M_2 has q rows and r columns, takes time proportional to pqr, and the result is a matrix of p rows and r columns. Consider the product of three matrices N_1N_2N_3 that have, respectively, w rows and x columns, x rows and y columns, and y rows and z columns. Under what condition will it take less time to compute the product as (N_1N_2)N_3 (i.e., multiply the first two matrices first) than to compute it as N_1(N_2 N_3)?", "choices": [{"label": "A", "text": "There is no such condition; i.e., they will always take the same time."}, {"label": "B", "text": "1/x + 1/z < 1/w + 1/y"}, {"label": "C", "text": "x > y"}, {"label": "D", "text": "1/w + 1/x < 1/y + 1/z"}], "answerKey": "B", "model_answer": ""}
{"question": "The hit ratio of a cache memory is the percentage of accesses (reads and writes) for which data are found in the cache. Write-through is a policy whereby every write operation updates main memory. Write-back is a policy whereby a write operation to a line found in the cache does not affect main memory until the line is evicted from the cache. Write-allocation is a policy whereby a cache line is allocated and loaded on a write-miss. If it is assumed that write-allocation is always used, which of the following is true?", "choices": [{"label": "A", "text": "Write-back usually results in a better hit ratio than write-through."}, {"label": "B", "text": "Write-through usually results in a better hit ratio than write-back."}, {"label": "C", "text": "The percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through."}, {"label": "D", "text": "The percentage of write operations resulting in a main memory operation will never be larger for writethrough than for write-back."}], "answerKey": "C", "model_answer": ""}
{"question": "A particular disk unit uses a bit string to record the occupancy or vacancy of its tracks, with O denoting vacant and 1 denoting occupied. A 32-bit segment of this string has the hexadecimal value D4FE2003. The percentage of occupied tracks for the corresponding part of the disk, to the nearest percent, is", "choices": [{"label": "A", "text": "12%"}, {"label": "B", "text": "25%"}, {"label": "C", "text": "38%"}, {"label": "D", "text": "44%"}], "answerKey": "D", "model_answer": ""}
{"question": "An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. Which of the following undirected graphs must have an Euler circuit?\nI. A complete graph with 12 vertices\nII. A complete graph with 13 vertices\nIII. A tree with 13 vertices", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "B", "model_answer": "LECTURE: A graph is a tree if it is not connected and has no cycle.\nA graph is a complete graph if each vertex is connected to every other vertex.\nSOLUTION: A complete graph with 12 vertices is a tree with 12 vertices. So, it must have an Euler circuit.\nA complete graph with 13 vertices is a complete graph with 13 vertices. So, it must have an Euler circuit.\nA tree with 13 vertices is a tree with 13 vertices. So, it must have an Euler circuit."}
{"question": "Which of the following characteristics of a programming language is best specified using a context-free grammar?", "choices": [{"label": "A", "text": "Identifier length"}, {"label": "B", "text": "Maximum level of nesting"}, {"label": "C", "text": "Operator precedence"}, {"label": "D", "text": "Type compatibility"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following statements about datagrams sent by a node in a network using IPv4 protocol is (are) true?\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nIII. Datagrams are reassembled only at the destination.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "LECTURE: In a network, data is sent from one device to another in datagrams. A datagram is a block of data that is sent over the network.\nImagine that you have a letter that you want to send to a friend. Your letter is too long to send in one email. So, you break the letter up into three smaller emails. Each of these three emails is a datagram.\nThis is what happens on the computer network. Your computer breaks the letter into three datagrams. It sends each datagram in a separate email. Your friend's computer receives the three datagrams in the three emails. It puts the datagrams in order to build the letter.\nThe Internet Protocol (IP) is the set of rules that tells computers how to send datagrams across a network. The IPv4 protocol is one version of the Internet Protocol.\nWhen a datagram is sent from a source to a destination, it may have to pass through several computers. Each computer that a datagram passes through is called a router.\nA router may break a datagram into smaller pieces called fragments. Each fragment is sent in a separate email. This is called fragmentation.\nA router may also put fragments back together to build a datagram. This is called reassembly.\nA datagram that is sent without being broken into fragments is called a non-fragmented datagram. A datagram that is broken into fragments is called a fragmented datagram."}
{"question": "A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. Which of the following job-scheduling policies is starvation-free?", "choices": [{"label": "A", "text": "Round-robin"}, {"label": "B", "text": "Priority queuing"}, {"label": "C", "text": "Shortest job first"}, {"label": "D", "text": "Youngest job first"}], "answerKey": "A", "model_answer": "LECTURE: It is important to choose an appropriate job-scheduling policy when managing access to a shared resource.\nA job-scheduling policy is a set of rules that determines the order in which jobs are executed.\nWhen choosing a job-scheduling policy, consider the following criteria:\n1. Fairness: A job-scheduling policy is fair if it runs jobs in a short amount of time, regardless of when they arrived.\n2. Efficiency: A job-scheduling policy is efficient if it runs jobs in the smallest amount of time possible.\n3. Resource usage: A job-scheduling policy is resource-smart if it maximizes the use of available resources.\nSOLUTION: To determine whether a job-scheduling policy is starvation-free, consider what happens to the smallest jobs.\nIf a job-scheduling policy is fair and efficient, then it is starvation-free.\nA round-robin policy is fair and efficient, so a round-robin policy is starvation-free.\nA priority queuing policy is fair but not efficient. A job with a higher priority will always be executed before a job with a lower priority. So, a priority queuing policy is not starvation-free.\nA shortest job first policy is efficient but not fair. The shortest job is always executed first. So, a shortest job first policy is not starvation-free.\nA youngest job first policy is fair but not efficient. The youngest job is always executed first. So, a youngest job first policy is not starvation-free."}
{"question": "Of the following, which gives the best upper bound for the value of f(N) where f is a solution to the recurrence f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0?", "choices": [{"label": "A", "text": "O(log N)"}, {"label": "B", "text": "O(N log N)"}, {"label": "C", "text": "O(log N) + 0(1)"}, {"label": "D", "text": "O((log N)^2)"}], "answerKey": "D", "model_answer": "LECTURE: A recurrence is a closed-form expression that defines a function in terms of one of its own values. Recurrences with initial conditions can be solved by setting the recurrence to its initial condition and solving for the function.\nf(2N + 1) = f(2N) = f(N) + log N for N \u2265 1, with f(1) = 0.\nThis recurrence can be solved by setting f(2N + 1) = f(2N) and using log N to expand f(2N + 1).\nf(2N) = f(N) + log N\nf(N) = f(N) + log N\nwhich simplifies to f(N) = log N.\nSo, the value of f(N) is log N."}
{"question": "Company X shipped 5 computer chips, 1 of which was defective, and Company Y shipped 4 computer chips, 2 of which were defective. One computer chip is to be chosen uniformly at random from the 9 chips shipped by the companies. If the chosen chip is found to be defective, what is the probability that the chip came from Company Y?", "choices": [{"label": "A", "text": "2 / 9"}, {"label": "B", "text": "4 / 9"}, {"label": "C", "text": "1 / 2"}, {"label": "D", "text": "2 / 3"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following problems can be solved by a standard greedy algorithm?\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights\nII. Finding a maximum clique in an undirected graph\nIII. Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A greedy algorithm is a simple optimization algorithm that is used to solve problems with the following general structure:\nThere are a set of resources and a goal.\nThe resources are finite and have a certain value.\nThe goal can be achieved by using some combination of the resources.\nThe goal has a certain value, which is the maximum value that the resources can achieve.\nTo determine the combination of resources that achieves the goal, you can use a greedy algorithm. A greedy algorithm works by selecting the resource with the highest value at each step. This is called a \"greedy choice.\"\nAt the end of the algorithm, the goal is achieved and the value of the combination of resources is the sum of the values of the resources in the combination.\nFor example, consider the problem of finding a maximum clique in an undirected graph. A clique is a set of nodes in the graph that includes every node.\nThere are a set of nodes and a goal.\nThe resources are the nodes and have a value of 1.\nThe goal is to find a clique that has a value of |clique|.\nA clique of size 3 has a value of 3.\nA clique of size 4 has a value of 4.\nA greedy algorithm can be used to find a maximum clique. At each step, the algorithm selects the node that has not been selected yet and adds it to the clique. This results in a clique of size 5."}
{"question": "A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined. Which of the following is (are) correct?\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: A hash table is a data structure that uses a hash function to map keys to values. A hash function is a simple function that takes a key and returns a value. The hash function's goal is to reduce the key's complexity to a single value.\nA hash table has the following properties:\n1. The hash function maps the keys to values.\n2. The hash function is designed to produce a \"uniform\" distribution of keys. That is, a small change in the key should produce a different value.\n3. The hash function does not need to be unique. That is, multiple keys can produce the same value.\n4. The hash function does not need to be deterministic. That is, the same key can produce a different value when the hash function is called multiple times.\nSOLUTION: This program uses a hash table to check the spelling of words in a document.\nThe hash table has a size equal to the size of the dictionary. The hash table is used to keep track of which words are in the dictionary.\nTo check the spelling of a word in the document, the program applies a hash function to the word. The hash function maps the word to an index in the hash table.\nIf the appropriate entry in the hash table is true, the word was in the dictionary.\nIf the appropriate entry in the hash table is false, the word was not in the dictionary.\nSo, the correct answers are I and II."}
{"question": "One approach to handling fuzzy logic data might be to design a computer using ternary (base-3) logic so that data could be stored as \u201ctrue,\u201d \u201cfalse,\u201d and \u201cunknown.\u201d If each ternary logic element is called a flit, how many flits are required to represent at least 256 different values?", "choices": [{"label": "A", "text": "4"}, {"label": "B", "text": "5"}, {"label": "C", "text": "6"}, {"label": "D", "text": "7"}], "answerKey": "C", "model_answer": "LECTURE: In a ternary logic system, there are three possible values: true, false, and unknown.\nSince there are 2 possible outcomes for a single flit, there are a total of 2 possible values that can be represented by 2 flits.\nSo, there are a total of 2 values that can be represented by 1 flit.\nThere are a total of 2 values that can be represented by 2 flits.\nThere are a total of 2 values that can be represented by 4 flits.\nThere are a total of 2 values that can be represented by 8 flits."}
{"question": "Local caching of files is common in distributed file systems, but it has the disadvantage that", "choices": [{"label": "A", "text": "Temporary inconsistencies among views of a file by different machines can result"}, {"label": "B", "text": "The file system is likely to be corrupted when a computer crashes"}, {"label": "C", "text": "A much higher amount of network traffic results"}, {"label": "D", "text": "Caching makes file migration impossible"}], "answerKey": "A", "model_answer": "LECTURE: In a distributed file system, different machines may have different versions of the same file. When one machine writes a new version of a file, the change may not be immediately visible to other machines. This is because the update may be delayed by network congestion, software bugs, or other factors.\nTo ensure that all machines have the most recent version of a file, distributed file systems use caching. Stale versions of a file are kept on a machine for a short time. If a change is made to a file, the new version is kept on the machine for a short time. If another machine requests the file within this time, the machine can send the new version. Otherwise, the machine sends the stale version."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-through policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2048"}], "answerKey": "C", "model_answer": ""}
{"question": "At time 0, five jobs are available for execution on a single processor, with service times of 25, 15, 5, 3, and 2 time units. Which of the following is the minimum value of the average completion time of these jobs?", "choices": [{"label": "A", "text": "50"}, {"label": "B", "text": "208/5"}, {"label": "C", "text": "92/5"}, {"label": "D", "text": "10"}], "answerKey": "C", "model_answer": "LECTURE: The average completion time of five jobs is 208/5 time units.\nTo find the average completion time, add the completion times of each job and then divide the sum by the number of jobs.\nIf each job takes 25 time units to complete, then the completion time is 25.\nIf the five jobs take 208 time units to complete, then the average completion time is 208/5 time units."}
{"question": "Let G = (V, E) be a connected, undirected graph, and let a and b be two distinct vertices in V. Let P_1 be the problem of finding a shortest simple path between a and b, and let P_2 be the problem of finding a longest simple path between a and b. Which of the following statements about P_1 and P_2 is true?", "choices": [{"label": "A", "text": "Both P_1 and P_2 can be solved in polynomial time."}, {"label": "B", "text": "P_1 can be solved in polynomial time but P_2 is not known to be solvable in polynomial time."}, {"label": "C", "text": "P_1 is not known to be solvable in polynomial time but P_2 can be solved in polynomial time."}, {"label": "D", "text": "It is not known whether either P_1 or P_2 can be solved in polynomial time."}], "answerKey": "B", "model_answer": "LECTURE: Consider two problems:\nProblem 1: A shortest path between two nodes in a network.\nProblem 2: A longest path between two nodes in a network.\nThese two problems are among the hardest optimization problems in computer science. In fact, they are NP-hard, which means that there is no known algorithm that can solve them in polynomial time for all cases.\nHowever, many networks have special properties that make these problems easier to solve. For example, a network may be known to be bipartite, or it may be possible to find a shortest path from one node to another by repeatedly following a single possible path.\nIf a network has a special property that makes a shortest path or a longest path easier to find, then the problem can be solved in polynomial time.\nSOLUTION: To decide whether either problem can be solved in polynomial time, consider whether G has a special property that makes the problems easier to solve.\nG is connected, undirected, and has no isolation nodes. These conditions make it possible to find a shortest path or a longest path between any two nodes in G.\nSo, P_1 can be solved in polynomial time. It is not known whether P_2 can be solved in polynomial time."}
{"question": "A major advantage of direct mapping of a cache is its simplicity. The main disadvantage of this organization is that", "choices": [{"label": "A", "text": "it does not allow simultaneous access to the intended data and its tag"}, {"label": "B", "text": "it is more expensive than other types of cache organizations"}, {"label": "C", "text": "the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache"}, {"label": "D", "text": "its access time is greater than that of other cache organizations"}], "answerKey": "C", "model_answer": ""}
{"question": "Let M be a single-tape, deterministic Turing machine with tape alphabet {blank,0,1}, and let C denote the (possibly infinite) computation of M starting with a blank tape. The input to each problem below is M, together with a positive integer n. Which of the following problems is (are) decidable?\nI. The computation C lasts for at least n steps.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nIII. M scans at least n distinct tape squares during the computation C.", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "D", "model_answer": "LECTURE: A Turing machine is a mathematical model of computation. It consists of a tape of infinitely many cells, a read/write head that can move along the tape, and a control that determines the machine's behavior. The Turing machine uses the tape to represent data and performs operations on the data.\nA Turing machine begins with the tape in a designated initial state. It reads the cell through which the read/write head is pointing. It then moves the read/write head to a neighboring cell and repeats the above steps. This process continues for all time.\nA Turing machine can do many things. It can write symbols on the tape. It can move the read/write head to a specific location. It can change the direction in which the head is moving. It can pause and stay in its current state for a while.\nThe behavior of a Turing machine is defined by a set of rules. These rules describe what the machine does in response to the symbols it reads on the tape.\nA Turing machine can use a blank symbol to represent any undefined or unrecognized symbol. A Turing machine that uses a blank symbol in this way is called a deterministic Turing machine.\nA Turing machine can use an epsilon symbol to represent a symbol that can be replaced by a blank symbol. A Turing machine that uses an epsilon symbol in this way is called a nondeterministic Turing machine.\nSOLUTION: To decide each problem, consider the following steps:\nI. The computation C lasts for at least n steps.\nThis problem can be decided by looking at the last few steps of the computation C. If the computation C lasts for at least n steps, then M prints a 1 at some point after the nth step.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nThis problem can be decided by looking at the last few steps of the computation C. If the computation C lasts for at least n steps, and M prints a 1 at some point after the nth step, then M scans at least n distinct tape squares during the computation C.\nIII. M scans at least n distinct tape squares during the computation C.\nThis problem can be decided by looking at the number of distinct tape squares that M scans during the computation C. If M scans at least n distinct tape squares during the computation C, then the computation C lasts for at least n steps."}
{"question": "A 3-way, set-associative cache is", "choices": [{"label": "A", "text": "one in which each main memory word can be stored at any of 3 cache locations"}, {"label": "B", "text": "effective only if 3 or fewer processes are running alternately on the processor"}, {"label": "C", "text": "possible only with write-back"}, {"label": "D", "text": "faster to access than a direct-mapped cache"}], "answerKey": "A", "model_answer": "LECTURE: In a cache, each block of data has a unique address. When a block is accessed, its address is used to determine which cache location it is stored in.\nA cache is said to be set-associative if each block in main memory can be stored in any set. For example, a cache with 2 sets and 4 ways can store up to 8 blocks of data.\nA cache is said to be direct-mapped if each block in main memory can be stored in only one set. For example, a cache with 2 sets and 4 ways can store up to 4 blocks of data.\nSOLUTION: A 3-way, set-associative cache is one in which each main memory word can be stored at any of 3 cache locations.\nFor example, suppose main memory has 16 words. A 3-way, set-associative cache with 4 ways can store up to 4 x 4 = 16 words in the cache."}
{"question": "Consider an object-oriented language in which all entities are objects. Two relationships arise: (1) the instance relationship, between an object and the class of which that object is a member, and (2) the subclass relationship, between a class and the superclass from which that class inherits properties. In such a language, when a message is sent to an object requesting execution of one of its methods (procedures), the method is located by following", "choices": [{"label": "A", "text": "one instance link and then zero or more subclass links"}, {"label": "B", "text": "one or more instance links and then one or more subclass links"}, {"label": "C", "text": "one or more instance links"}, {"label": "D", "text": "one subclass link and then one or more instance links"}], "answerKey": "A", "model_answer": "LECTURE: In an object-oriented language, objects are made up of two parts: instances and classes.\nAn instance is an object that is created from a class. An instance contains data and functions, called methods.\nA class is a blueprint for creating objects. A class defines the data and methods that an object has.\nWhen a message is sent to an object, the method that handles the message is called. The message is passed to the method.\nThere are two kinds of links between objects: instance links and subclass links.\nAn instance link connects an object to its class. An instance is an instance of a class.\nA subclass link connects a class to a superclass. A subclass is a subclass of a superclass.\nA link can be made up of one or more parts.\nSuppose you have a superclass called Animal and a subclass called Dog. A Dog is an Animal.\nThere are two links from Dog to Animal.\nOne link is an instance link. It connects an object of the Dog class to an object of the Animal class.\nThe other link is a subclass link. It connects the Dog class to the Animal superclass.\nWhen a message is sent to a Dog object, one of the following links is followed to find the method that handles the message:\nOne instance link.\nOne subclass link.\nOne or more instance links.\nOne or more subclass links.\nSOLUTION: To find a method in an object-oriented language, the links from the object to the class are followed.\nAn instance link is followed first. If the end of the instance link is reached, no more links are followed.\nIf an instance link is not followed, the subclass links are followed. The links from the class to its superclasses are followed, one at a time, to the superclass of the original class."}
{"question": "In a pipelined RISC computer where all arithmetic instructions have the same CPI (cycles per instruction), which of the following actions would improve the execution time of a typical program?\nI. Increasing the clock cycle rate\nII. Disallowing any forwarding in the pipeline\nIII. Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "D", "model_answer": "LECTURE: Pipelined computers have multiple stages of execution within a single CPU cycle. For example, an arithmetic instruction may have the following stages:\n1. Fetch the first operand.\n2. Fetch the second operational.\n3. Decode the instruction.\n4. Execute the instruction.\n5. Write the result.\nWhile the instruction is being executed, the next instruction is being fetched. The computer can execute multiple instructions during a single CPU cycle.\nThe following diagram shows a 5-stage pipelined loop. The pipeline has five full stages. Each iteration of the loop takes five CPU cycles.\nThe instruction cache and data cache are separate caches that store copies of the instructions and data being used by the processor. These caches can improve the performance of a pipelined computer.\nCaches have a limit to the number of instructions or data items they can store. When this limit is reached, additional items must be retrieved from main memory. This is called a cache miss.\nCache misses can slow down a computer. They force the processor to wait for data to be fetched from main memory."}
{"question": "A microcomputer used for data acquisition and control is required to digitize and process four analog input signals and to output their average continually; i.e., in real time. The time for an external analog-to-digital converter (which is triggered by a CPU instruction) to digitize one input is 12 microseconds, and only one digitization occurs at a time. Five CPU instructions, including the triggering instruction, must be executed for each signal digitized. Ten CPU instructions are executed in order to average each set of four samples and output this value. The time to convert the output from digital to analog form is to be ignored. If it is assumed that suitable data buffering is employed, then the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates, is", "choices": [{"label": "A", "text": "0.8 microseconds"}, {"label": "B", "text": "1.2 microseconds"}, {"label": "C", "text": "1.6 microseconds"}, {"label": "D", "text": "2.4 microseconds"}], "answerKey": "C", "model_answer": ""}
{"question": "Suppose that a certain software product has a mean time between failures of 10,000 hours and has a mean time to repair of 20 hours. If the product is used by 100 customers, what is its availability?", "choices": [{"label": "A", "text": "80%"}, {"label": "B", "text": "90%"}, {"label": "C", "text": "98%"}, {"label": "D", "text": "99.80%"}], "answerKey": "D", "model_answer": "LECTURE: The availability of a product is a measure of its reliability. It is a measure of the proportion of time that a product is expected to be functioning and available for use.\nAvailability = (Mean time between failures) x (Mean time to repair)\nIf either the mean time between failures or the mean time to repair is zero, then the availability is equal to 1.\nAvailability = (10,000 hours) x (20 hours) = 200,000 hours\nThe product is available for 200,000 hours."}
