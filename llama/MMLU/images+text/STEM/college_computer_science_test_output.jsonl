{"question": "The access matrix approach to protection has the difficulty that", "choices": [{"label": "A", "text": "the matrix, if stored directly, is large and can be clumsy to manage"}, {"label": "B", "text": "it is not capable of expressing complex protection requirements"}, {"label": "C", "text": "deciding whether a process has access to a resource is undecidable"}, {"label": "D", "text": "there is no way to express who has rights to change the access matrix itself"}], "answerKey": "A", "model_answer": ""}
{"question": "An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y. Which of the following sets of integers could possibly be the set of all common divisors of two integers?", "choices": [{"label": "A", "text": "{-6,-2, -1, 1, 2, 6}"}, {"label": "B", "text": "{-6, -2, -1, 0, 1, 2, 6}"}, {"label": "C", "text": "{-6, -3, -2, -1, 1, 2, 3, 6}"}, {"label": "D", "text": "{-6, -3, -2, -1, 0, 1, 2, 3, 6}"}], "answerKey": "C", "model_answer": ""}
{"question": "In the NoNicks operating system, the time required by a single file-read operation has four nonoverlapping components:\ndisk seek time-25 msec\ndisk latency time-8 msec\ndisk transfer time- 1 msec per 1,000 bytes\noperating system overhead-1 msec per 1,000 bytes + 10 msec\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes. The ratio of-the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately", "choices": [{"label": "A", "text": "1:4"}, {"label": "B", "text": "1:3.5"}, {"label": "C", "text": "1:1"}, {"label": "D", "text": "1.1:1"}], "answerKey": "B", "model_answer": ""}
{"question": "You want to cluster 7 points into 3 clusters using the k-Means Clustering algorithm. Suppose after the first iteration, clusters C1, C2 and C3 contain the following two-dimensional points: C1 contains the 2 points: {(0,6), (6,0)} C2 contains the 3 points: {(2,2), (4,4), (6,6)} C3 contains the 2 points: {(5,5), (7,7)} What are the cluster centers computed for these 3 clusters?", "choices": [{"label": "A", "text": "C1: (3,3), C2: (4,4), C3: (6,6)"}, {"label": "B", "text": "C1: (3,3), C2: (6,6), C3: (12,12)"}, {"label": "C", "text": "C1: (6,6), C2: (12,12), C3: (12,12)"}, {"label": "D", "text": "C1: (0,0), C2: (48,48), C3: (35,35)"}], "answerKey": "A", "model_answer": "LECTURE: After the first iteration of the k-Means Clustering algorithm, the cluster centers are the points with the lowest sum of squared distances to the other points in the cluster. So, for each cluster, the cluster center is the point that minimizes the following formula:\nFor a point P, the sum of squared distances to other points in the cluster is given by:\nThis formula is minimized when P is the center of mass of the cluster points.\nThe center of mass is the point where the sum of the distances from each point is equal.\nFor example, if you have the points P1, P2, and P3, the center of mass is (P1 + P2 + P3) / 3.\nSOLUTION: To calculate the cluster centers, follow the procedure described in the previous paragraph.\nFor cluster C1, the points are {(0,6), (6,0)}. The sum of squared distances to these points is:\nThe minimum sum of squared distances is obtained when C1 contains the two points {(0,0), (6,6)}.\nSo, C1: (0,0).\nFor cluster C2, the points are {(2,2), (4,4), (6,6)}. The sum of squared distances to these points is:\nThe minimum sum of squared distances is obtained when C2 contains the two points {(2,2), (4,4)}.\nSo, C2: (4,4).\nFor cluster C3, the points are {(5,5), (7,7)}. The sum of squared distances to these points is:\nThe minimum sum of squared distances is obtained when C3 contains the two points {(5,5), (7,7)}.\nSo, C3: (5,5)."}
{"question": "Any set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. Which of the following is NOT complete?", "choices": [{"label": "A", "text": "{AND, NOT}"}, {"label": "B", "text": "{NOT, OR}"}, {"label": "C", "text": "{AND, OR}"}, {"label": "D", "text": "{NAND}"}], "answerKey": "C", "model_answer": "LECTURE: A Boolean operator is a symbol that indicates a operation on a Boolean expression. The two Boolean operators are AND and OR.\nThe AND operator indicates that all of the circumstances described in the Boolean expression are present.\nThe OR operator indicates that at least one of the circumstances described in the Boolean expression is present.\nA complete set of Boolean operators is a set of Boolean operators that is sufficient to represent all Boolean expressions.\nAny expression that can be formed from AND, OR, and NOT can be formed from just AND and OR.\nA single NOT operator can be used to represent any expression that can be formed from AND and OR.\nSo, the set {AND, OR} is complete.\nThe set {NOT, OR} is complete.\nThe set {AND, OR} is a complete set of Boolean operators.\nThe set {NOT, OR} is a complete set of Boolean operators.\nThe set {NAND, NOR} is a complete set of Boolean operators.\nThe set {NAND, NOR} is not a complete set of Boolean operators.\nThe NAND operator indicates that not all of the circumstances described in the Boolean expression are present.\nThe NOR operator indicates that at least one of the circumstances described in the Boolean expression is not present."}
{"question": "Consider the collection of all undirected graphs with 10 nodes and 6 edges. Let M and m, respectively, be the maximum and minimum number of connected components in any graph in the collection. If a graph has no selfloops and there is at most one edge between any pair of nodes, which of the following is true?", "choices": [{"label": "A", "text": "M = 10, m = 10"}, {"label": "B", "text": "M = 10, m = 1"}, {"label": "C", "text": "M = 7, m = 4"}, {"label": "D", "text": "M = 6, m = 4"}], "answerKey": "C", "model_answer": ""}
{"question": "Resolution theorem proving for showing that a formula of propositional logic is not satisfiable has which of the following properties?\nI. It is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nII. It is a complete proof system in the sense that there is a proof of unsatisfiability for every unsa tisfiable formula of propositional logic.\nIII. It is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "C", "model_answer": "LECTURE: A proof system is sound if it can establish the unsatisfiability of a formula only when the formula is indeed unsatisfiable.\nA proof system is complete if it can establish the unsatisfiability of a formula whenever the formula is unsatisfiable.\nA proof system is succinct if the length of the longest proof in the system is polynomial in the length of the formula.\nA proof system is trivial if it can establish the unsatisfiability of any formula.\nSOLUTION: The resolution proof system for showing that a propositional formula is not satisfiable has the following properties:\nIt is a complete proof system in the sense that there is a proof of unsatisfiability for every unsolvable formula.\nIt is a succinct proof system in the sense that whenever an unsatisfiable formula F has a resolution proof, F also has a proof whose length is polynomial in the length of F.\nSo, the resolution proof system is both complete and succinct. But it is not trivial, because there are unsatisfiable formulas for which no proof of unsatisfiability can be constructed. And it is not sound, because there exists a proof of unsatisfiability for a formula that is indeed satisfiable."}
{"question": "Which of the following statements describe(s) properties of a purely segmented memory system?\nI. It divides memory into units of equal size.\nII. It permits implementation of virtual memory.\nIII. It suffers from internal fragmentation.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "B", "model_answer": "LECTURE: In a purely segmented memory system, memory is divided into units of fixed size. The system manages each unit of memory as a separate segment.\nA segment is a logical unit of memory that may contain both data and instructions. Segments of memory are usually divided into units of equal size.\nThe advantage of a segmented memory is that it supports dynamic memory allocation. That is, the system can assign memory to a process when it is needed. This allocation can happen at any location in memory.\nA disadvantage of a segmented memory is that it may suffer from internal fragmentation. Internal fragmentation occurs when a large segment of memory is not completely filled. As a result, smaller segments of memory are left unused.\nA purely segmented memory system does not support virtual memory. In a virtual memory system, each process has its own virtual memory. The virtual memory is backed by disk storage. This allows a process to have complete control over a portion of memory that is not affected by other processes."}
{"question": "Which of the following statements about floating-point arithmetic is NOT true?", "choices": [{"label": "A", "text": "It is inherently nonassociative because some numbers have no exact representation."}, {"label": "B", "text": "It is inherently nonassociative because there have to be upper and lower bounds on the size of numbers."}, {"label": "C", "text": "Associativity can be achieved with appropriate roundoff conventions."}, {"label": "D", "text": "Some rational numbers have no exact representation."}], "answerKey": "C", "model_answer": ""}
{"question": "Suppose sharing of tiles in a multilevel directory structure is achieved with directory entries that are links pointing to a node containing information about a shared file. Information in this node includes (1) the owner of the file, (2) a count of the number of links to the tile, and (3) the disk block numbers of the file. What is a primary drawback to this approach to sharing?", "choices": [{"label": "A", "text": "If the owner modifies the file, another user who does not share will see the changes."}, {"label": "B", "text": "If the owner renames the file, other users will not be able to access it."}, {"label": "C", "text": "If the owner is allowed to delete a file, dangling links may result."}, {"label": "D", "text": "If any user who shares the file appends to it, others who share it will not be able to access the new disk blocks."}], "answerKey": "C", "model_answer": ""}
{"question": "Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves. Which of the following data structures will allow mergesort to work in O(n log n) time?\nI. A singly linked list\nII. A doubly linked list\nIII. An array", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": ""}
{"question": "If p(x) is the minimal-degree interpolating polynomial for the real-valued function f(x) at the n + 1 distinct real numbers x0, .... xn what is the maximum possible degree of p(x)?", "choices": [{"label": "A", "text": "n"}, {"label": "B", "text": "n + 1"}, {"label": "C", "text": "n + 2"}, {"label": "D", "text": "2n"}], "answerKey": "A", "model_answer": ""}
{"question": "An internal hash table has 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is", "choices": [{"label": "A", "text": "3"}, {"label": "B", "text": "8"}, {"label": "C", "text": "10"}, {"label": "D", "text": "13"}], "answerKey": "A", "model_answer": "LECTURE: Hash tables are data structures that map keys to values. They use a hash function to transform a key into an index in an array. This allows you to access the value associated with a key in constant time, on average.\nWhen you insert a key-value pair into a hash table, the hash function is used to determine the index where the value should be stored. This process is called hashing.\nIf two keys are hashed to the same index, which is called a collision, there are several ways to handle the collision:\nLinear probing: If a bucket is full, try the next bucket. For example, if the bucket at index 5 is full, try the bucket at index 4.\nQuadratic probing: If a bucket is full, try the next bucket twice. For example, if the bucket at index 5 is full, try the bucket at index 9.\nCyclic probing: Repeat the probe sequence until an empty bucket is found. For example, if the buckets at indices 5, 9, and 13 are full, try the bucket at index 5 again.\nEach of these methods has its own advantages and disadvantages. Linear probing is simple and easy to implement. Quadratic probing is less likely to cause collisions to spread, but it is more complex to implement. Cyclic probing is less likely to cause collisions to spread than quadratic probing, and it is simpler to implement than quadratic probing.\nSOLUTION: The hash function h(i) = i mod 5 is used. With linear resolution of collisions, if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5.\nSo, if the bucket at index 5 is filled, the buckets at indices 5, 9, 13, and 17 are tried successively.\nThe key 13 is hashed to index 2. The keys 8 and 24 are hashed to index 1. The key 10 is hashed to index 3. So, the content of the bucket numbered 2 is 3."}
{"question": "TCP protocol is responsible (among other things) for", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "C", "model_answer": ""}
{"question": "Let A and B be two sets of words (strings) from \u03a3*, for some alphabet of symbols \u03a3. Suppose that B is a subset of A. Which of the following statements must always be true of A and B ?\nI. If A is finite, then B is finite.\nII. If A is regular, then B is regular.\nIII. If A is context-free, then B is context-free.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A set is a finite set if it has only a finite number of elements. A set is a regular set if it is the image of a finite set under a computed function. A set is a context-free set if it is the image of a regular set under a computed function.\nSOLUTION: B is a subset of A. So, B is finite if and only if A is finite.\nA is regular if and only if B is regular. To see this, let f: \u03a3\u2020 \u2192 \u03a3 be the function that maps each word in \u03a3\u2020 to itself. Then, f is a computed function that maps A to itself, and B is a subset of A. So, B is regular if and only if A is regular.\nA is context-free if and only if B is context-free. To see this, let g: \u03a3\u2020 \u2192 \u03a3 be the function that maps each word in \u03a3\u2020 to a different word in \u03a3. Then, g is a computed function that maps A to itself, and B is a subset of A. So, B is context-free if and only if A is context-free."}
{"question": "For all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings. Which of the following is true?", "choices": [{"label": "A", "text": "a^M = a"}, {"label": "B", "text": "(ax)^M = (xa)^M"}, {"label": "C", "text": "(xy)^M = y^Mx^M"}, {"label": "D", "text": "None of the above"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following is NOT a reasonable justification for choosing to busy-wait on an asynchronous event?", "choices": [{"label": "A", "text": "The wait is expected to be short."}, {"label": "B", "text": "A busy-wait loop is easier to code than an interrupt handler."}, {"label": "C", "text": "There is no other work for the processor to do."}, {"label": "D", "text": "The program executes on a time-sharing system."}], "answerKey": "D", "model_answer": ""}
{"question": "The language {ww | w in (0 + 1)*} is", "choices": [{"label": "A", "text": "not accepted by any Turing machine"}, {"label": "B", "text": "accepted by some Turing machine, but by no pushdown automaton"}, {"label": "C", "text": "accepted by some pushdown automaton, but not context-free"}, {"label": "D", "text": "context-free, but not regular"}], "answerKey": "B", "model_answer": ""}
{"question": "Which of the following statements about Ethernets is typically FALSE?", "choices": [{"label": "A", "text": "Ethernets use circuit switching to send messages."}, {"label": "B", "text": "Ethernets use buses with multiple masters."}, {"label": "C", "text": "Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly."}, {"label": "D", "text": "Networks connected by Ethernets are limited in length to a few hundred meters."}], "answerKey": "A", "model_answer": ""}
{"question": "Let P be a procedure that for some inputs calls itself (i.e., is recursive). If P is guaranteed to terminate, which of the following statements must be true?\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following comes closest to being a perfectly secure encryption scheme?", "choices": [{"label": "A", "text": "The Caesar Cipher, a substitution cipher"}, {"label": "B", "text": "DES (Data Encryption Standard), a symmetric-key algorithm"}, {"label": "C", "text": "Enigma, a transposition cipher"}, {"label": "D", "text": "One-time pad"}], "answerKey": "D", "model_answer": ""}
{"question": "Of the following problems concerning a given undirected graph G, which is currently known to be solvable in polynomial time?", "choices": [{"label": "A", "text": "Finding a longest simple cycle in G"}, {"label": "B", "text": "Finding a shortest cycle in G"}, {"label": "C", "text": "Finding ALL spanning trees of G"}, {"label": "D", "text": "Finding a largest clique in G"}], "answerKey": "B", "model_answer": ""}
{"question": "The IP protocol is primarily concerned with", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "A", "model_answer": ""}
{"question": "Of the following, which best approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N?", "choices": [{"label": "A", "text": "1/K"}, {"label": "B", "text": "K-1/K"}, {"label": "C", "text": "log_10 (1/N)"}, {"label": "D", "text": "N-1/m"}], "answerKey": "A", "model_answer": "LECTURE: In a complete K-ary tree, the number of nonterminal nodes is equal to K-1. So, the ratio of the number of nonterminal nodes to the total number of nodes is (K-1)/K.\nSOLUTION: Of the given choices, only K-1/K approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N."}
{"question": "Consider a computer system in which processes can request and release one or more resources. Once a process has been granted a resource, the process has exclusive use of that resource until it is released. If a process requests a resource that is already in use, the process enters a queue for that resource, waiting until the resource is available. Which of the following will NOT deal effectively with the problem of deadlock?", "choices": [{"label": "A", "text": "Giving priorities to processes and ordering the wait queues by priority"}, {"label": "B", "text": "Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all"}, {"label": "C", "text": "Numbering the resources and requiring that processes request resources in order of increasing number"}, {"label": "D", "text": "Having processes time out and restart after a random interval of waiting"}], "answerKey": "A", "model_answer": ""}
{"question": "\"Magic memory\"' has two operations: Read and Clear. Both are indivisible and mutually exclusive. Clear sets the magic memory to zero. Read returns a value that represents the number of Read operations since the last Clear operation. Which of the following is (are) true of \"Magic memory\"?\nI. It can provide the functionality of an atomic Test-and-Set.\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nIII. It is only useful on a multiprocessor.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: A memory device has two operations: Write and Read. Both operations are indivisible and mutually exclusive. The Write operation sets the memory to a particular value. The Read operation returns the value that was stored in the memory.\nA counter is a variable that is used to count the number of times a certain event occurs. A counter can be used to keep track of the number of times a process is invoked or the number of times a particular event occurs in a process.\nA test-and-set instruction is an atomic instruction that tests whether a memory location is zero and, if it is, sets it to a chosen value.\nA magic number is a value used in a program as a flag or signal. A magic number is typically used to indicate that a particular event has occurred.\nA mutex is a variable that is used to coordinate the access of multiple processes to a shared resource. A process can use a mutex to determine whether it is safe to access a shared resource.\nA semaphore is a variable that is used to coordinate the access of multiple processes to a shared resource. A semaphore can be used to indicate the availability of a shared resource.\nSOLUTION: The magic memory is only useful on a multiprocessor. It is not useful on a uniprocessor.\nThe magic memory can be used to coordinate processes running on a shared-memory multiprocessor.\nThe magic memory is not an atomic test-and-set. It does not have the properties of an atomic test-and-set."}
{"question": "Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?", "choices": [{"label": "A", "text": "Abstract Syntax Tree (AST)"}, {"label": "B", "text": "Attribute Grammar"}, {"label": "C", "text": "Symbol Table"}, {"label": "D", "text": "Semantic Stack"}], "answerKey": "C", "model_answer": "LECTURE: A symbol table is a data structure in a compiler that is responsible for managing information about variables and their attributes. When a variable is defined, the symbol table is updated with information about that variable, such as its name and its data type. When the variable is used later in the program, the symbol table is consulted to determine the variable's type and other attributes.\nA symbol table contains one entry for each variable defined in the program. Each entry contains the variable's name and its attributes.\nAn abstract syntax tree (AST) is a data structure that shows the structure of a program. The AST is constructed by successively folding (i.e., summarizing) the program's syntax.\nThe AST is used by the compiler to evaluate the program. During this process, the AST is also used to determine the program's type and other attributes.\nAn attribute grammar is a type of grammar that is used to describe the attributes of a programming language. An attribute grammar for a language defines the language's lexical symbols (keys) and the rules that relate those symbols.\nAn attribute grammar is used to define the structure of the symbol table. The symbol table is then used by the compiler to manage information about variables and their attributes.\nA semantic stack is a data structure that is used to keep track of the program's attributes. The semantic stack is pushed with the attributes of each function definition and popped when the definition is completed.\nThe semantic stack is used by the compiler to track the program's attributes. The symbol table is then used to manage information about variables and their attributes."}
{"question": "Which of the following algorithms has running time \u0398(n^2) in the worst case but \u0398(n log n) on average?", "choices": [{"label": "A", "text": "Bubblesort"}, {"label": "B", "text": "Mergesort"}, {"label": "C", "text": "Heapsort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "D", "model_answer": ""}
{"question": "Languages with a structure that implements abstract data types (e.g., a C++ class) can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation). Which of the following statements about comparisons between direct and indirect representations is (are) true?\nI. Indirect representation noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following is NOT a property of bitmap graphics?", "choices": [{"label": "A", "text": "Fast hardware exists to move blocks of pixels efficiently."}, {"label": "B", "text": "Realistic lighting and shading can be done."}, {"label": "C", "text": "All line segments can be displayed as straight."}, {"label": "D", "text": "Polygons can be filled with solid colors and textures."}], "answerKey": "C", "model_answer": "LECTURE: Bitmap graphics are made up of pixels, or small images. Pixels can be set to display colors from a limited range. The number of bits in a bitmap image determines how many colors can be displayed.\nA 1-bit image is made up of pixels that are either on or off. In a 1-bit image, each pixel can display only one color: either black or white.\nA 2-bit image is made up of pixels that can display one of three colors. Two bits of information are required to identify each color. Each pixel in a 2-bit image can display one of the following colors: black, white, or a second color.\nAn 8-bit image is made up of pixels that can display one of 256 colors. An 8-bit image has 8 bits of information.\nA 32-bit image is made up of pixels that can display one of 16,777,216 colors. A 32-bit image has 32 bits of information.\nSOLUTION: Fast hardware exists to move blocks of pixels efficiently.\nMoving pixels is an efficient operation. When a computer needs to display a new image, it can simply move the pixels from the image into the computer's video memory.\nRealistic lighting and shading can be done.\nAn image's pixels can be set to display colors from a limited range. So, it is possible to create images with lighting and shading that looks realistic, because realistic images have pixels that are set to display colors from a limited range.\nAll line segments can be displayed as straight.\nLine segments can be displayed as straight, because straight lines are made up of line segments.\nPolygons can be filled with solid colors and textures.\nA polygon is a shape made up of many line segments. A bitmap graphic is made up of pixels, or small images. Polygons can be filled with solid colors and textures because pixels can be set to display colors from a limited range."}
{"question": "Which of the following is true of interrupts?", "choices": [{"label": "A", "text": "They are generated when memory cycles are \"stolen\"."}, {"label": "B", "text": "They are used in place of data channels."}, {"label": "C", "text": "They can indicate completion of an I/O operation."}, {"label": "D", "text": "They cannot be generated by arithmetic operations."}], "answerKey": "C", "model_answer": ""}
{"question": "In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. Which of the following are true of such a tree?\nI. Worst-case search time is logarithmic in the number of nodes.\nII. Average-case search time is logarithmic in the number of nodes.\nIII. Best-case search time is proportional to the height of the tree.\nIV. The height of the tree is logarithmic in the number of nodes.", "choices": [{"label": "A", "text": "I and III only"}, {"label": "B", "text": "II and III only"}, {"label": "C", "text": "II and IV only"}, {"label": "D", "text": "I, II, and IV"}], "answerKey": "D", "model_answer": "LECTURE: A height-balanced binary search tree is a binary search tree in which the heights of the left and right descendents of any node differ by at most 1.\nA tree is a height-balanced binary search tree if and only if the height of the tree is logarithmic in the number of nodes.\nA tree is a binary search tree if and only if the height of the tree is proportional to the number of nodes.\nSo, a height-balanced binary search tree is a binary search tree.\nThe worst-case search time, worst-case time complexity, is logarithmic in the number of nodes.\nThe average-case search time, average-case time complexity, is logarithmic in the number of nodes.\nThe best-case search time, best-case time complexity, is proportional to the height of the tree.\nThe height of the tree is logarithmic in the number of nodes."}
{"question": "Bob writes down a number between 1 and 1,000. Mary must identify that number by asking \"yes/no\" questions of Bob. Mary knows that Bob always tells the truth. If Mary uses an optimal strategy, then she will determine the answer at the end of exactly how many questions in the worst case?", "choices": [{"label": "A", "text": "1,000"}, {"label": "B", "text": "999"}, {"label": "C", "text": "500"}, {"label": "D", "text": "10"}], "answerKey": "D", "model_answer": "LECTURE: A strategy is optimal if it allows Mary to determine the answer in the fewest number of questions.\nSOLUTION: Mary can use logical deduction to determine the answer with just one question.\nIf the number Bob wrote down is 1, Mary can ask, \"Is the number you wrote down 1?\" If Bob says yes, Mary knows the answer is 1.\nIf the number Bob wrote down is 1,000, Mary can ask, \"Is the number you wrote down 1,000?\" If Bob says yes, Mary knows the answer is 1,000.\nOther numbers between 1 and 1,000 can be ruled out by asking yes/no questions that eliminate the possibility of numbers other than 1 and 1,000.\nFor example, Mary can ask, \"Is the number you wrote down between 1 and 20?\" If Bob says yes, then the number is not 1,000. If Bob says no, then the number is not 1.\nSo, Mary can determine the answer at the end of exactly one question in the worst case."}
{"question": "Which of the following is (are) true about virtual memory systems that use pages?\nI. The virtual address space can be larger than the amount of physical memory.\nII. Programs must be resident in main memory throughout their execution.\nIII. Pages correspond to semantic characteristics of the program.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "LECTURE: A computer's memory is divided into two types: temporary (or virtual) memory, and permanent (or real) memory.\nTemporary memory is used to hold data that is actively being used. The computer's central processor can quickly access temporary memory.\nPermanent memory is used to hold data that is not being used. Data in permanent memory is held even when the computer is turned off.\nBoth types of memory are used by computer programs. A program's logical organization is called its structure. The structure can be simple or complex. The diagram below shows some common ways in which a program's structure can be organized.\nPrograms that have a simple structure can be loaded into temporary memory all at once.\nPrograms that have a complex structure may need to be loaded into temporary memory in parts.\nWhen a program is being used, it is stored in temporary memory. Some of the program's data may be stored in permanent memory.\nIf another program is started while the first program is still running, both programs will be stored in temporary memory.\nThe amount of temporary memory on a computer is limited. If a program needs more temporary memory space than is available, the program will not run properly.\nSOLUTION: A virtual memory system that uses pages will use the main memory for pages that are being used. The pages are stored in main memory in the order that they are needed.\nPages that are not being used are moved to secondary memory. Secondary memory is usually a hard disk.\nWhen a program needs data that is in a page that is stored in secondary memory, the page is transferred back to main memory.\nThe choice that is true is I. The other choices are false."}
{"question": "Which of the following is usually NOT represented in a subroutine's activation record frame for a stack-based programming language?", "choices": [{"label": "A", "text": "Values of local variables"}, {"label": "B", "text": "A heap area"}, {"label": "C", "text": "The return address"}, {"label": "D", "text": "Stack pointer for the calling activation record"}], "answerKey": "B", "model_answer": ""}
{"question": "Which of the following statements about a remote procedure call is true?", "choices": [{"label": "A", "text": "It is used to call procedures with addresses that are farther than 2^16 bytes away."}, {"label": "B", "text": "It cannot return a value."}, {"label": "C", "text": "It cannot pass parameters by reference."}, {"label": "D", "text": "It cannot call procedures implemented in a different language."}], "answerKey": "C", "model_answer": "LECTURE: Procedures and functions are two ways to package up code and have it executed separately from the main program.\nA procedure is a named block of code that can be called from within a program. It can be implemented as a subroutine, which is a stand-alone procedure that is not part of a larger procedure.\nA function is a named block of code that performs a specific task. Functions often return a value, but they can also have side effects, such as modifying a global variable or printing to the console.\nBoth procedures and functions can be implemented in different languages, which is known as cross-language programming.\nA remote procedure call (RPC) is a way for procedures to be called across a computer network. An RPC is used when a procedure is implemented in a different program or in a different process within the same program.\nThe following statement is true about a remote procedure call: It is used to call procedures with addresses that are farther than 2^16 bytes away.\nThe other statements are not necessarily true.\nIt cannot return a value.\nAn RPC can return a value.\nIt cannot pass parameters by reference.\nAn RPC can pass parameters by reference.\nIt cannot call procedures implemented in a different language.\nAn RPC can call procedures implemented in a different language."}
{"question": "Of the following sorting algorithms, which has a running time that is LEAST dependent on the initial ordering of the input?", "choices": [{"label": "A", "text": "Insertion sort"}, {"label": "B", "text": "Quicksort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Selection sort"}], "answerKey": "C", "model_answer": ""}
{"question": "A particular parallel program computation requires 100 seconds when executed on a single processor. If 40 percent of this computation is \"inherently sequential\" (i.e., will not benefit from additional processors), then the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are", "choices": [{"label": "A", "text": "20 and 10 seconds"}, {"label": "B", "text": "30 and 15 seconds"}, {"label": "C", "text": "50 and 25 seconds"}, {"label": "D", "text": "70 and 55 seconds"}], "answerKey": "D", "model_answer": ""}
{"question": "Consider the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude. In which representation is there overflow from the addition of the integers 011000 and 011000?", "choices": [{"label": "A", "text": "Two's complement only"}, {"label": "B", "text": "Sign and magnitude and one's complement only"}, {"label": "C", "text": "Two's complement and one's complement only"}, {"label": "D", "text": "All three representations"}], "answerKey": "D", "model_answer": "LECTURE: In a six-bit number, there are six bits. Each bit can be either 0 or 1.\nConsider the six-bit number 011000.\nThe number 011000 is six bits long. Each bit is shown in the table below.\nThe rightmost bit is 0. This means that the number is less than 128.\nThe other five bits are 0. These bits represent a number less than 64.\nSo, the complete six-bit number is 00001100.\nThis number is less than 64.\nNow, consider the addition of the six-bit numbers 011000 and 011000.\nThe rightmost bits are the same in both numbers. Each bit is shown in the table below.\nBoth bits are 0. So, the result has a value less than 64.\nThe other five bits are the same in both numbers. Each bit is shown in the table below.\nAll five bits are 0. So, the result has a value less than 64.\nSo, the result is 00001100.\nThere is no overflow from the addition of the integers 011000 and 011000.\nThere are three other representations of six-bit numbers.\nTwo's complement. In a six-bit number, the two's complement of 011000 is 100111.\nOne's complement. In a six-bit number, the one's complement of 011000 is 110011.\nSign and magnitude. In a six-bit number, the sign and magnitude of 011000 is 011000."}
{"question": "Of the following, which best characterizes computers that use memory-mapped I/O?", "choices": [{"label": "A", "text": "The computer provides special instructions for manipulating I/O ports."}, {"label": "B", "text": "I/O ports are placed at addresses on the bus and are accessed just like other memory locations."}, {"label": "C", "text": "To perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}, {"label": "D", "text": "Ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}], "answerKey": "B", "model_answer": ""}
{"question": "Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that", "choices": [{"label": "A", "text": "integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs"}, {"label": "B", "text": "P = NP"}, {"label": "C", "text": "even if P = NP, integer factorization is still likely not to be polynomial-time computable"}, {"label": "D", "text": "testing primality is computationally intractable"}], "answerKey": "A", "model_answer": "Integer factorization is difficult for large numbers. This difficulty is the basis for the security of many cryptographic protocols. The question tells you that the reason integer factorization is difficult is that it is believed that its inverse, integer multiplication, is a function whose inverse is equally difficult.\nHowever, even if P = NP, it is not necessarily the case that integer factorization is polynomial-time computable."}
{"question": "Which of the following sets of bit strings CANNOT be described with a regular expression?", "choices": [{"label": "A", "text": "All bit strings whose number of zeros is a multiple of five"}, {"label": "B", "text": "All bit strings starting with a zero and ending with a one"}, {"label": "C", "text": "All bit strings with an even number of zeros"}, {"label": "D", "text": "All bit strings with more ones than zeros"}], "answerKey": "D", "model_answer": "LECTURE: A regular expression is a pattern that describes a set of strings.\nThe sets of strings described by regular expressions are called regular sets.\nA set of strings is a regular set if it can be described by a regular expression.\nAn expression is the pattern that describes a regular set.\nThe pattern may contain variables, which are marked with a question mark.\nThe value of the variable is a string that matches the variable.\nFor example, the pattern /x/ describes the set of all strings that contain the string x.\nThe pattern /xZ/ describes the set of all strings that contain the string x followed by the string Z.\nThe pattern /xZy/ describes the set of all strings that contain the string x followed by the string y.\nSOLUTION: Each of the choices can be described by a regular expression.\nFor example, the regular expression /0+1*/ describes the set of all bit strings whose number of zeros is a multiple of five.\nAnd the regular expression /01+01*/ describes the set of all bit strings starting with a zero and ending with a one.\nBut the set of all bit strings with an even number of zeros cannot be described by a regular expression that uses only the variables 0 and 1.\nSo, the set of all bit strings with an even number of zeros cannot be described by a regular expression."}
{"question": "Which of the following conditions can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac)?\nI. At least three of p_1, p_2, p_3, p_4 are true.\nII. Exactly three of p_1, p_2, p_3, p_4 are true.\nIII. An even number of p_1, p_2, p_3, p_4 are true.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "LECTURE: A Boolean variable is a variable that can have only two values: true or false.\nA Boolean formula is a formula that uses only the Boolean variables and the connectives \u2227, \u2228, and without the negation symbol \u00ac.\nBoolean formulas can be used to express conditions on Boolean variables.\nThe value of a Boolean formula is true or false.\nThe set of values of a Boolean formula is called its satisfaction.\nA Boolean formula in the Boolean variables x1, x2, ..., xn and the connectives \u2227, \u2228, without the negation symbol \u00ac, can express the condition:\nAt most one of the xi is true.\nThis condition can be expressed by the formula:\nx1 \u2227 \u00acx2 \u2227 \u00acx3 \u2227 ... \u2227 \u00acxn.\nThis formula is in the Boolean variables x1, x2, ..., xn and the connectives \u2227, \u2228, without the negation symbol \u00ac.\nA Boolean formula in the Boolean variables x1, x2, ..., xn and the connectives \u2227, \u2228, without the negation symbol \u00ac, can also express the condition:\nAt least one of the xi is true.\nThis condition can be expressed by the formula:\nx1 \u2228 \u00acx2 \u2228 \u00acx3 \u2228 ... \u2228 \u00acxn.\nThis formula is in the Boolean variables x1, x2, ..., xn and the connectives \u2227, \u2228, without the negation symbol \u00ac.\nA Boolean formula in the Boolean variables x1, x2, ..., xn and the connectives \u2227, \u2228, without the negation symbol \u00ac, cannot express the condition:\nThe exact number of xi that are true is not important.\nThis condition cannot be expressed by a Boolean formula in the Boolean variables x1, x2, ..., xn and the connectives \u2227, \u2228, without the negation symbol \u00ac."}
{"question": "Two alternatives for interconnecting a set of processors with bidirectional links are (1) the fully interconnected network, in which each processor is directly connected to every other processor, and (2) the ring network, in which each processor is connected to two other processors. The worst-case path length for a network is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes. For each type of interconnection of n processors, a figure of merit can be formed as the product of the number of links required for the network times the worst-case path length connecting any two processors. The ratio of this figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is", "choices": [{"label": "A", "text": "1/(n^2)"}, {"label": "B", "text": "1/(n(n-1))"}, {"label": "C", "text": "1/n"}, {"label": "D", "text": "(n-1)/n"}], "answerKey": "D", "model_answer": ""}
{"question": "For a connected, undirected graph G = (V, E), which of the following must be true?\nI. \u03a3_{v\u2208V} degree(v) is even.\nII. |E| \u2265 |V| \u2212 1\nIII. G has at least one vertex with degree 1.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of vertices and edges. Vertices are also called nodes; edges connect nodes.\nAn undirected graph is a graph without directed edges.\nA connected graph is a graph that is connected to its vertices.\nThe degree of a vertex is the number of edges that connect to that vertex.\nFor a connected graph, \u03a3\u00b0v\u00b0 is even, where \u00b0v\u00b0 is the degree of vertex v.\nFor a connected graph with n vertices, |E| \u2265 n \u2212 1.\nA graph has a vertex of degree 1 if and only if it is connected to exactly one edge.\nSOLUTION: G has at least one vertex with degree 1.\nSo, G has at least one edge.\nFor a connected graph, |E| \u2265 |V| \u2212 1.\nSo, G has at least one vertex.\nSum of the degrees of all the vertices is even.\nSo, I. is true."}
{"question": "In multiprogrammed systems it is advantageous if some programs such as editors and compilers can be shared by several users. Which of the following must be true of multiprogrammed systems in order that a single copy of a program can be shared by several users?\nI. The program is a macro.\nII. The program is recursive.\nIII. The program is reentrant.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "C", "model_answer": "LECTURE: Programs, or portions of programs, that are used by more than one program are called libraries. Libraries can contain code, data, or both.\nA module is a piece of code or data that can be used by a program. A module may be part of a library or a program.\nA program is reentrant when it is safe to call the same module from multiple threads of execution.\nA program is recursive when it defines a procedure that can call itself.\nA macro is a way to replace a sequence of characters in a program with a single symbol.\nSOLUTION: Each of the three questions below is followed by an answer choice.\nIII. The program is reentrant.\nA program is reentrant when it is safe to call the same module from multiple threads of execution.\nA macro is not reentrant.\nA recursive program is not necessarily reentrant.\nII. The program is recursive.\nA program is recursive when it defines a procedure that can call itself.\nRecursive programs are not necessarily reentrant.\nA macro is not recursive.\nI. The program is a macro.\nA macro is a way to replace a sequence of characters in a program with a single symbol.\nMacros are not modules."}
{"question": "Which of the following decimal numbers has an exact representation in binary notation?", "choices": [{"label": "A", "text": "0.1"}, {"label": "B", "text": "0.2"}, {"label": "C", "text": "0.3"}, {"label": "D", "text": "0.5"}], "answerKey": "D", "model_answer": "LECTURE: Decimal numbers are written with both a whole number part and a fractional part. The whole number part is written first, and the fractional part is written after the whole number part.\nFor example, the decimal number 1.5 is written with the whole number 1 and the fractional part 0.5.\nBinary notation is a numbering system that uses only two symbols: 0 and 1.\nA binary number is a number written with only two digits: 0 and 1.\nTo write a decimal number in binary notation, you can do the following:\nWrite the decimal number as a sum of powers of 2. For example, 1.5 is a sum of the powers 1.5 = 1 + 0.5.\nWrite each power of 2 as 2 raised to an exponent. For example, 0.5 is 2 raised to the exponent -1.\nWrite the exponents as binary numbers.\nStart with the exponent -1. This exponent is written as 1.\nFor each additional power of 2, write the exponent next to the number 2. For example, for the exponent -2, write it as 10.\nThe complete binary notation for 1.5 is 1.01.\nSOLUTION: To determine whether a decimal number has an exact representation in binary notation, try writing the number as a sum of powers of 2. If the number can be written as a sum of powers of 2, then the decimal number has an exact representation in binary notation.\n0.1 is a sum of the powers 0.1 = 1. This sum can be written as 1.0.\n0.2 is a sum of the powers 0.2 = 1. This sum can be written as 1.0.\n0.3 is a sum of the powers 0.3 = 1. This sum can be written as 1.0.\n0.5 is a sum of the powers 0.5 = 1. This sum can be written as 1.0."}
{"question": "Function signatures describe the types of the arguments to a function as well as the return value of the function. For instance, the addition function on reals has a signature of\nadd : real x real -> real\nsince it takes two real numbers and returns a real number. But, for a language that allows functions as return values, addition could be considered to have the signature\nadd : real -> (real -> real)\nwhich means that add takes a single real (the first operand) and returns a new function that itself takes a single real (the second operand) and returns a real (the result). This process of reducing a function with multiple arguments to a function with fewer arguments is called currying. Which of the following is correct?", "choices": [{"label": "A", "text": "Currying can be applied to any function to the point where it has exactly one input argument."}, {"label": "B", "text": "Currying cannot be applied to functions of more than two arguments."}, {"label": "C", "text": "Currying cannot be applied to functions that return functions as arguments."}, {"label": "D", "text": "Currying cannot be applied w functions that haw arguments that are functions."}], "answerKey": "A", "model_answer": ""}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-back policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2000"}], "answerKey": "A", "model_answer": "LECTURE: In a direct-mapped cache, each byte in the cache is assigned a unique physical address. The cache uses tags to keep track of which bytes are in the cache. Each tag is a few bytes of the byte in the array.\nFor example, if we have an array of four bytes, each tag is one of the four bytes.\nIf a byte in the array is cached, its tag is stored in the cache. If a byte is not in the cache, both its tag and its data are missing.\nA direct-mapped cache can hold a number of bytes equal to the size of the cache. In this case, the cache is a 2K-byte cache. This means that the cache can hold 2000 bytes.\nIf the cache has a write-back policy, when a byte is written to memory, the cache must store the entire byte, not just the tag. So, when the loop is executed, all 256 bytes will be written to memory.\nSOLUTION: When the loop is executed, each byte of array A is accessed.\nAll 256 bytes of array A will be accessed before any byte of array B is accessed. So, the first 256 bytes are written to memory.\nThen, the next 256 bytes are accessed. These bytes are in array B. So, the next 256 bytes are written to memory.\nAll 1024 bytes are written to memory."}
{"question": "In which of the following representations of numbers by 8-bit words is the addition of the integers 109 and -42 within range?\nI. One's complement\nII. Two's complement\nIII. Sign and magnitude", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": ""}
{"question": "If a malicious process is granted temporary administrator-level access to a system", "choices": [{"label": "A", "text": "the threat is over as soon as the process is killed"}, {"label": "B", "text": "the threat is over after the operating system is rebooted"}, {"label": "C", "text": "the thread is over after rebooting the machine and replacing files that show a virus infection"}, {"label": "D", "text": "the threat is often permanent until the entire disk is wiped clean"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following statements about horizontal versus vertical microarchitecture is (are) true?\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nII. Horizontal microinstructions are unencoded.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: Microarchitecture is the way the parts of a computer's processor are organized. There are two types of microarchitecture: horizontal and vertical.\nHorizontal microarchitecture is organized in a way that allows multiple operations to be performed on a data item simultaneously. This is called parallelism.\nVertical microarchitecture is organized in a way that performs one operation at a time.\nMicroinstructions are the smallest units of a processor's instructions. They contain the information needed to perform a particular operation.\nHorizontal microinstructions are unencoded. This means that the opcode, or operation code, is the same for all horizontal microinstructions.\nThe opcode is the part of a microinstruction that tells the processor what operation to perform. In horizontal microinstructions, the opcode is the only part of the microinstruction that is different.\nAll other parts of the microinstruction are the same for all horizontal microinstructions. These other parts are called operand specifiers. They tell the processor which data items are involved in the operation.\nHorizontal microarchitecture is particularly well-suited to handle high-throughput applications. This is because of its ability to perform multiple operations on a data item simultaneously.\nVertical microarchitecture is particularly well-suited to handle low-throughput applications. This is because of its ability to perform one operation at a time.\nSOLUTION: II. Horizontal microinstructions are unencoded.\nHorizontal microinstructions are the same for all programs. So, programs for horizontal architectures require the same number of time steps.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.\nThis means that the opcode is the same for all horizontal microinstructions. So, programs for horizontal architectures require the same number of time steps."}
{"question": "A \"strictly binary tree\" is a binary tree in which every node that is not a leaf has two children. Suppose that for a class of strictly binary trees there exists c > 0 such that, for any tree in the class, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. Which of the following best characterizes the height h of any tree in this class, where N is the number of nodes in the tree and N > 1 ?", "choices": [{"label": "A", "text": "h <= log2(N)"}, {"label": "B", "text": "h = 1/c * log2(N)"}, {"label": "C", "text": "h < c log2(N)"}, {"label": "D", "text": "h > c log2(N)"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following sorting algorithms has average-case and worst-case running times of O(n log n)?", "choices": [{"label": "A", "text": "Bubble sort"}, {"label": "B", "text": "Insertion sort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "C", "model_answer": ""}
{"question": "Consider the following equations concerning a stack module that has the operations Push, Pop, Top, and IsEmpty. Which of the equations does NOT represent the conventional semantics of a stack?", "choices": [{"label": "A", "text": "IsEmpty(Push(Stack,Elem)) = true"}, {"label": "B", "text": "Pop(Push(Stack,Elem)) = Stack"}, {"label": "C", "text": "Top(Push(Stack,Elem)) = Elem"}, {"label": "D", "text": "IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false"}], "answerKey": "A", "model_answer": "LECTURE: A stack is a data structure that allows you to add and remove items in a single operation.\nWhen you push an item onto a stack, you add it to the top of the stack. When you pop an item from a stack, you remove the top item from the stack.\nA stack has a single top item.\nThe value of the top item is the value of the stack.\nIsEmpty is a predicate that returns true if the stack is empty and false otherwise.\nAn empty stack can be filled.\nA stack is not multiple items.\nAll items in a stack are equally top.\nThe order of items in a stack is the same as the order in which they were pushed.\nSOLUTION: The correct answer is A.\nIsEmpty(Push(Stack,Elem)) = true defines the conventional semantics of a stack. The stack is empty before and after the push operation.\nPop(Push(Stack,Elem)) = Stack defines the conventional semantics of a stack. The top item is on top of the stack after the push operation.\nTop(Push(Stack,Elem)) = Elem does not represent the conventional semantics of a stack. The top item is on top of the stack after the push operation, but the value of the top item is the value of Elem, not the value of the stack.\nIsEmpty(Push(Push(Stack,Elem1),Elem2)) = false does not represent the conventional semantics of a stack. The stack is not empty after the push operation."}
{"question": "Assume that any assignment statement can be executed in unit time. If as many identical processors as needed are used, what is the minimum number of time units needed to execute the assignments\nA := B + C\nB := A - B\nC := A * E\nD := A/F\nE := B - C\nF := A + B\nwith the same result as if the assignments were executed in the order shown?", "choices": [{"label": "A", "text": "1"}, {"label": "B", "text": "2"}, {"label": "C", "text": "3"}, {"label": "D", "text": "4"}], "answerKey": "C", "model_answer": ""}
{"question": "Two expressions E and F are said to be unifiable if there are substitutions for the variables of E and F that make the expressions lexically identical. In the following three expressions, only w, x, y, and z are variables.\nI. f(w,w)\nII. f(x,1)\nIII. f(y,g(z))\nWhich pairs of these expressions is (are) pairs of unifiable expressions?", "choices": [{"label": "A", "text": "(I, II) only"}, {"label": "B", "text": "(I, III) only"}, {"label": "C", "text": "(II, III) only"}, {"label": "D", "text": "(I, II) and (I, III) only"}], "answerKey": "D", "model_answer": "LECTURE: An expression is a combination of a variable and a function. For example, f(x) is a expression, and x is a variable. The function f is associated with the variable x.\nWhen two expressions are unified, the variables in the expressions are replaced by the same value. If any functions are involved in the expressions, they are also applied to that value.\nFor example, consider the expressions f(x) and g(x). These expressions are unified when the value assigned to x in one expression is the same as the value assigned to x in the other expression.\nSo, f(x) and g(x) are unified when f(x) = g(x).\nAn expression can be unified with itself. For example, f(x) is unified with f(x).\nThe variable w, x, y, and z are different variables. So, the expressions f(w, w), f(x, 1), and f(y, g(z)) are not unified."}
{"question": "Which of the following instruction-set features is NOT generally considered an obstacle to aggressive pipelining of an integer unit?", "choices": [{"label": "A", "text": "Condition codes set by every instruction"}, {"label": "B", "text": "Variable-length encoding of instructions"}, {"label": "C", "text": "Instructions requiring widely varying numbers of cycles to execute"}, {"label": "D", "text": "Several different classes (sets) of registers"}], "answerKey": "D", "model_answer": ""}
{"question": "Let k >= 2. Let L be the set of strings in {0, 1}^* such that x \\in L if and only if the number of 0's in x is divisible by k and the number of 1's in x is odd. The minimum number of states in a deterministic finite automaton (DFA) that recognizes L is", "choices": [{"label": "A", "text": "k + 2"}, {"label": "B", "text": "2k"}, {"label": "C", "text": "k log k"}, {"label": "D", "text": "k^2"}], "answerKey": "B", "model_answer": "LECTURE: A deterministic finite automaton (DFA) is a type of machine that is designed to recognize patterns in strings of symbols. A DFA has a set of states and a transition table that tells you the next state to move to based on the current state and the symbol at the current position of the string.\nTo build a DFA that recognizes a language L, follow these steps:\n1. Represent each symbol in the language L in a table.\nAssistant: LECTURE: A deterministic finite automaton (DFA) is a type of machine that is designed to recognize patterns in strings of symbols. A DFA has a set of states and a transition table that tells you the next state to move to based on the current state and the symbol at the current position of the string.\nTo build a DFA that recognizes a language L, follow these steps:\n1. Represent each symbol in the language L in a table. The table should have one row for each state, and each cell should contain the next state to move to. For example, if the current state is 1 and the symbol is 0, then the next state is 2.\n2. Repeat this process until you have represented all the symbols in the language L.\n3. The final table contains the transition rules for all the symbols in the language L.\nThis table can be used to determine the next state for any string and symbol combination.\nSOLUTION: To build a DFA that recognizes L, represent the conditions that an input string must satisfy in a table. The table will have two columns: one for the current state and one for the next state. For example, if the current state is 0 and the number of 0's in the string is divisible by k, the next state should be 1. If the current state is 0 and the number of 0's in the string is not divisible by k, the next state should be 2.\nThere are k + 2 possible states. The DFA recognizes L when it is in state 1."}
{"question": "Let G = (V, E) be a finite directed acyclic graph with |E| > 0. Which of the following must be true?\nI. G has a vertex with no incoming edge.\nII. G has a vertex with no outgoing edge.\nIII. G has an isolated vertex, that is, one with neither an incoming edge nor an outgoing edge.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "D", "model_answer": ""}
{"question": "Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v. Let (u, v) be an edge in G that is not in T, such that pre(u) < pre(v). Which of the following statements about u and v must be true?\nI. post(u) < post(v)\nII. u is an ancestor of v in T.\nIII. If w is the lowest common ancestor of u and v in T, then w = u.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "LECTURE: A depth-first search tree of a connected graph is a tree that is generated by performing a depth-first search of the graph.\nA depth-first search of a graph G uses a search strategy that explores the graph in a depth-first manner. That is, it visits vertices in depth-first order and does not explore further out of the graph.\nA depth-first search tree is a tree that is generated by performing a depth-first search of a graph. The depth-first search tree of a connected graph is always a tree.\nThe preorder traversal of a tree is a traversal where each vertex is visited before its children are visited. The postorder traversal of a tree is a traversal where each vertex is visited after its children are visited.\nThe lowest common ancestor of two vertices in a tree is the lowest vertex from which both vertices can be reached by a path in the tree.\nAn ancestor of a vertex in a tree is a vertex that is somehow the ancestor of the vertex. A vertex is a descendant of a vertex if the vertex is somehow a descendant of the vertex. A vertex is a sibling of a vertex if the vertices are siblings in the tree.\nThe following statements are true for any depth-first search tree of a connected graph G:\nPreorder traversal: pre(v) \u2264 post(v) for any vertex v in the tree.\nPostorder traversal: post(v) \u2264 pre(v) for any vertex v in the tree.\nThe following statements are true for any two vertices u and v in a tree:\nIf u is an ancestor of v, then pre(u) \u2265 pre(v).\nIf u is a descendant of v, then post(u) \u2265 post(v).\nIf u is a sibling of v, then pre(u) = pre(v) and post(u) = post(v).\nSOLUTION: Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v.\nLet (u, v) be an edge in G that is not in T, such that pre(u) < pre(v).\nThe statements in the question are about the values of preorder and postorder counts for vertices u and v in the tree T. These counts are equal to or greater than the number of nodes visited up to and including the vertices during a preorder or postorder traversal of the tree.\nSo, pre(u) \u2264 pre(v) and post(u) \u2264 post(v).\nSince pre(u) \u2264 pre(v) and post(u) \u2264 post(v), pre(u) = pre(v) and post(u) = post(v).\nSo, u is a sibling of v in T.\nSo, u is not an ancestor of v in T.\nSo, II. is false."}
{"question": "In systems with support for automatic memory management, a garbage collector typically has the responsibility for reclaiming allocated memory objects whose contents cannot affect any future legal computation. Such objects are identified by determining that they cannot be reached from a root set. Which of the following is NOT part of the root set in a typical garbage collector?", "choices": [{"label": "A", "text": "Actual parameters of the active procedures"}, {"label": "B", "text": "Dynamically allocated objects on the heap"}, {"label": "C", "text": "Global variables of the program"}, {"label": "D", "text": "Local variables on the call stack"}], "answerKey": "B", "model_answer": ""}
{"question": "In the Internet Protocol (IP) suite of protocols, which of the following best describes the purpose of the Address Resolution Protocol?", "choices": [{"label": "A", "text": "To translate Web addresses to host names"}, {"label": "B", "text": "To determine the IP address of a given host name"}, {"label": "C", "text": "To determine the hardware address of a given host name"}, {"label": "D", "text": "To determine the hardware address of a given IP address"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following language features requires that stack-based storage allocation be used rather than static allocation?", "choices": [{"label": "A", "text": "Recursive procedures"}, {"label": "B", "text": "Arbitrary goto's"}, {"label": "C", "text": "Two-dimensional arrays"}, {"label": "D", "text": "Integer-valued functions"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following is not a sentence that is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z?", "choices": [{"label": "A", "text": "xyz"}, {"label": "B", "text": "xy"}, {"label": "C", "text": "xxzy"}, {"label": "D", "text": "xxxxy"}], "answerKey": "A", "model_answer": ""}
{"question": "Let T (n) be defined by T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1. Which of the following represents the order of growth of T(n) as a function of n?", "choices": [{"label": "A", "text": "\u0398(n)"}, {"label": "B", "text": "\u0398(n log n)"}, {"label": "C", "text": "\u0398(n^2)"}, {"label": "D", "text": "\u0398(n^2 log n)"}], "answerKey": "C", "model_answer": "LECTURE: The notation \u0398(an) represents the order of growth of a function f(n). It is used to describe how fast the value of f(n) grows as n gets larger. As an example, if f(n) = n, then \u0398(n) represents the order of growth of f(n).\nIf f(n) = n log n, then \u0398(n log n) represents the order of growth of f(n).\nIf f(n) = n^2, then \u0398(n^2) represents the order of growth of f(n).\nIf f(n) = n^2 log n, then \u0398(n^2 log n) represents the order of growth of f(n).\nSOLUTION: T(n) is defined as T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1.\nApplying the recurrence relation, we get:\nT(n) = 3n + T(n\u22121) for n \u2265 2.\nSo, T(n) = 3n for n \u2265 2.\nThus, T(n) grows as 3n.\nSince 3n is not of the form n^2 or n log n, T(n) does not grow as \u0398(n^2) or \u0398(n log n).\nFurther, 3n is not of the form n^2 log n, so T(n) does not grow as \u0398(n^2 log n).\nThus, the order of growth of T(n) as a function of n is \u0398(n)."}
{"question": "Which of the following problems is (are) decidable?\nI. Given a (finite) string w, is w a prefix of the decimal expansion of \u03c0?\nII. Given a program and an input, is the program\u2019s output the decimal expansion of \u03c0?\nIII. Given a program that takes as input a prefix of the decimal expansion of \u03c0, is the program\u2019s output always the same for every prefix?", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following statements about circuits is (are) true?\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nIII. Both sequential and combinational circuits must be controlled by an external clock.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": ""}
{"question": "Two single-user workstations are attached to the same local area network. On one of these workstations, file pages are accessed over the network from a file server; the average access time per page is 0.1 second. On the other of these workstations, file pages are accessed from a local disk; the average access time per page is 0.05 second. A particular compilation requires 30 seconds of computation and 200 file page accesses. What is the ratio of the total time required by this compilation if run on the diskless (file server) workstation to the total time required if run on the workstation with the local disk, if it is assumed that computation is not overlapped with file access?", "choices": [{"label": "A", "text": "1/1"}, {"label": "B", "text": "5/4"}, {"label": "C", "text": "5/3"}, {"label": "D", "text": "10/5"}], "answerKey": "B", "model_answer": "LECTURE: To compare two numbers, first compare their digits until you have two digits that are different. The number with the bigger digit is larger. For example, compare 7 and 8. The digit 8 is bigger than the digit 7. So, 8 is larger than 7.\nIf both digits are the same, compare the next digits. For example, compare 5 and 5. The digits are the same, so the numbers are equal.\nIf each digit is different, the bigger number has a bigger digit in each place. For example, compare 34 and 55. The digit 5 is bigger than the digit 3. So, 55 is larger than 34.\nSOLUTION: Compare the digits in the total time required for the compilation. The bigger digit is larger.\nThe compilation requires 200 file page accesses. The average access time per page is 0.1 second. So, the time required for the file page accesses is 200 x 0.1 = 20 seconds.\nThe compilation also requires 30 seconds of computation. So, the total time required for the compilation is 30 + 20 = 50 seconds.\nThe compilation requires 200 file page accesses. The average access time per page is 0.05 second. So, the time required for the file page accesses is 200 x 0.05 = 10 seconds.\nThe compilation also requires 30 seconds of computation. So, the total time required for the compilation is 30 + 10 = 40 seconds.\nThe compilation requires 200 file page accesses. The average access time per page is 0.1 second. So, the time required for the file page accesses is 200 x 0.1 = 20 seconds.\nThe compilation also requires 30 seconds of computation. So, the total time required for the compilation is 30 + 20 = 50 seconds.\nThe ratio of the total time required by this compilation if run on the diskless workstation to the total time required if run on the workstation with the local disk is 50 / 40. This ratio is larger than 1. So, the compilation is faster when run on the workstation with the local disk."}
{"question": "Assume that a debugger places a breakpoint at a load instruction at virtual address 0x77E81234 (hexadecimal notation) in a debugged process P. If the text segment of P begins at 0x77E80000 in P\u2019s virtual address space and if the debugger has mapped this same text segment at 0x01000000 in its virtual address space, which of the following is the virtual address used by the debugger in its WRITE operation, along with a description of how the debugger has mapped the virtual memory page containing this address?", "choices": [{"label": "A", "text": "0x01001234; page mapped with READ/WRITE access"}, {"label": "B", "text": "0x01001234; page mapped with COPY-ON-WRITE access"}, {"label": "C", "text": "0x76E81234; page mapped with READ/WRITE access"}, {"label": "D", "text": "0x76E81234; page mapped with COPY-ON-WRITE access"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following considerations applies (apply) to choosing the page size in a paging system?\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: When considering different criteria for making a decision, you will often find that some criteria are more important than others. If one criterion is more important, it means that it has a greater influence on the decision. You can determine which criterion has a greater influence on the decision by considering which criterion would be most important to you under the circumstances.\nFor example, when choosing a car, the criterion of fuel efficiency may be more important to you than the criterion of number of cup holders. This is because fuel efficiency may have a greater impact on your long-term satisfaction with the car.\nSOLUTION: Use the following criteria to determine which consideration applies to choosing the page size in a paging system:\nAn advantage of larger pages is that they lead to smaller page tables.\nAn advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nNormally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.\nI. An advantage of larger pages is that they lead to smaller page tables.\nA smaller page table can lead to faster access of page table information. So, this consideration applies to choosing the page size.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nInternal fragmentation occurs when there is unused space at the end of a page. Smaller pages would have less unused space, so this consideration applies to choosing the page size.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.\nDisk access time is not influenced by page length. So, this consideration does not apply to choosing the page size."}
{"question": "Two processors, M-5 and M-7, implement the same instruction set. Processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. Processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds. Which of the following is (are) true?\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline.\nII. The latency of a single instruction is shorter on M-7\u2019s pipeline than on M-5\u2019s pipeline.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III"}, {"label": "D", "text": "II and III"}], "answerKey": "A", "model_answer": "LECTURE: Pipelining is a technique used in processors to increase their throughput. Pipelining involves breaking the execution of an instruction into a series of stages, with one or more stages being executed at any given time.\nA processor with pipelining has a pipeline of stages that instructions follow, one at a time. The instructions do not wait for each other to complete. Instead, each instruction moves through the pipeline stages one at a time.\nPipelining allows more instructions to be executed in a given time period. This is because instructions that are waiting in the pipeline for one stage to complete can proceed directly to the next stage.\nA processor's clock rate, which determines the time taken between clock ticks, affects the time it takes for an instruction to pass through the pipeline. A processor with a faster clock rate will complete more instructions in a given time period.\nThe maximum throughput of a pipeline is determined by its stage transition times and clock rate. Maximum throughput is the number of instructions per clock cycle that the processor can execute.\nThe latency of an instruction is the time it takes for the instruction to complete, from the time it is fetched from memory until the time it is executed. Latency is affected by the pipeline length and the clock rate.\nA processor with a longer pipeline will have higher latency for its instructions. This is because instructions in a longer pipeline must wait for more stages to complete before they are executed.\nA processor with a slower clock rate will have higher latency for its instructions. This is because instructions will spend more clock cycles waiting in the pipeline for each stage to complete.\nSOLUTION: M-7's pipeline has more stages than M-5's pipeline. So, M-7's pipeline has better maximum throughput than M-5's pipeline.\nThe latency of a single instruction is shorter on M-7's pipeline than on M-5's pipeline. This is because M-7's pipeline has more stages.\nPrograms executing on M-7 will always run faster than programs executing on M-5. This is because M-7's pipeline has a higher maximum throughput than M-5's pipeline."}
{"question": "Which of the following pairs of 8-bit, two's-complement numbers will result in overflow when the members of the pairs are added?", "choices": [{"label": "A", "text": "11111111, 00000001"}, {"label": "B", "text": "00000001, 10000000"}, {"label": "C", "text": "11111111, 10000001"}, {"label": "D", "text": "10000001, 10101010"}], "answerKey": "D", "model_answer": ""}
{"question": "Two computers communicate with each other by sending data packets across a local area network. The size of these packets is 1,000 bytes. The network has the capacity to carry 1,000 packets per second. The CPU time required to execute the network protocol to send one packet is 10 milliseconds. The maximum rate at which one computer can send data to another is approximately", "choices": [{"label": "A", "text": "10,000 bytes/second"}, {"label": "B", "text": "25,000 bytes/ second"}, {"label": "C", "text": "100,000 bytes/ second"}, {"label": "D", "text": "500,000 bytes/ second"}], "answerKey": "C", "model_answer": ""}
{"question": "Consider the following grammar.\nS \u2192 ( S )\nS \u2192 x\nWhich of the following statements is (are) true?\nI. The grammar is ambiguous.\nII. The grammar is suitable for top-down parsing.\nIII. The grammar is suitable for bottom-up parsing.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: A grammar is a set of rules that describe the structure of sentences in a language. Classes of grammars are created by combining rules for constructing sentences.\nFor example, consider the following rules:\nS \u2192 aSb\nS \u2192 bSb\nThese rules describe a grammar that is not suitable for top-down parsing or bottom-up parsing.\nTop-down parsing is done by searching the tree of possible parses from the target sentence to the root of the grammar.\nBottom-up parsing is done by building the tree of possible parses from the root of the grammar to the target sentence.\nA grammar is unambiguous if every sentence in the language is generated by the grammar.\nThere are two ways to check for ambiguity in a grammar:\nShow that the grammar generates more than one sentence in the language.\nShow that the grammar does not generate a sentence in the language.\nA grammar is suitable for top-down parsing if it can be used to find the parse with the highest probability of being the correct parse. This is not the same as saying that top-down parsing is possible.\nA grammar is suitable for bottom-up parsing if it can be used to find the parse with the highest probability of being the correct parse. This is not the same as saying that bottom-up parsing is possible.\nSOLUTION: The grammar is ambiguous. It is possible to generate more than one sentence in the language.\nFor example, the sentence x can be parsed as S or as ( S ).\nThe grammar is suitable for bottom-up parsing. Each nonterminal symbol has exactly one rule.\nThe grammar is not suitable for top-down parsing. There are alternative paths to the root of the grammar from the nonterminal symbols S and x."}
{"question": "Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT:", "choices": [{"label": "A", "text": "Counting distinct values: Given a set of n keys, determine the number of distinct key values."}, {"label": "B", "text": "Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary."}, {"label": "C", "text": "Range search: Given values a and b, find all the records whose key value is in the range a, b."}, {"label": "D", "text": "Symbol table lookup: Given a program identifier, find its type and address."}], "answerKey": "C", "model_answer": "LECTURE: A hash table is a data structure that uses a hash function to map keys to values.\nA hash function is a function that takes a key as input and returns a value. The key is often a piece of data, and the value is the data that the hash function computes based on the key.\nFor example, a hash function could take a string as input and return the string's reverse.\nIf the input to the hash function changes, the hash function returns a different value. This is called a dynamic function.\nDynamic hash tables support the operations of insert, delete, and search. When you insert a key-value pair into an empty hash table, the hash function is used to determine the right location to store the pair. When you search for a key, the hash function is used to determine the right location to look.\nIf the hash function is well designed, most operations take constant time. This makes hash tables a useful data structure for problems that require looking up keys.\nSOLUTION: A symbol table is a data structure that stores information about a program. The information includes the types of the program's identifiers and the identifiers' locations in memory.\nWhen a program is loaded, the symbol table is searched to find the identifiers that are used in the program. The symbol table maps identifiers to their types and locations.\nRange search is a problem that involves searching for records in a data structure. A range search takes advantage of the fact that the hash function is used to determine the right location to look.\nIf the range search is performed using a hash table, the average case performance is O(1). This makes hash tables a useful data structure for range search.\nDynamic dictionaries support the operations of insert, delete, and search. They use a hash function to determine the right location to store a key-value pair.\nIf the hash function is well designed, most operations take constant time. This makes dynamic dictionaries a useful data structure for many applications.\nCounting distinct values is a problem that involves counting the number of records in a data structure. A hash table can efficiently solve this problem by counting the number of records as they are inserted into the hash table.\nSince the hash function is used to determine the right location to look, the average case performance is O(1). This makes hash tables a useful data structure for counting distinct values."}
{"question": "Let A be a finite set with m elements, and let B be a finite set with n elements. The number of distinct functions mapping A into B is", "choices": [{"label": "A", "text": "n^m"}, {"label": "B", "text": "n!/(n - m)!"}, {"label": "C", "text": "n!"}, {"label": "D", "text": "n!/(m!(n - m)!)"}], "answerKey": "A", "model_answer": "LECTURE: Finite sets are sets with a fixed number of elements. The numbers of elements in the sets A and B are m and n, respectively.\nThe number of functions from set A to set B is a function of the sizes of A and B.\nIf A and B are of equal size, the number of functions from A to B is equal to the number of functions from B to A. This holds because each function is reciprocal to its own reciprocal.\nIf A and B are not of equal size, the number of functions from A to B is not the same as the number of functions from B to A.\nSOLUTION: Let f(A, B) represent the number of functions from set A to set B. Then f(A, B) is a function of the sizes of A and B.\nf(A, B) = n! / (n - m)! if m <= n.\nf(A, B) = n^m if m > n.\nf(A, B) = 0 if m \u2260 n."}
{"question": "To compute the matrix product M_1M_2, where M_1 has p rows and q columns and where M_2 has q rows and r columns, takes time proportional to pqr, and the result is a matrix of p rows and r columns. Consider the product of three matrices N_1N_2N_3 that have, respectively, w rows and x columns, x rows and y columns, and y rows and z columns. Under what condition will it take less time to compute the product as (N_1N_2)N_3 (i.e., multiply the first two matrices first) than to compute it as N_1(N_2 N_3)?", "choices": [{"label": "A", "text": "There is no such condition; i.e., they will always take the same time."}, {"label": "B", "text": "1/x + 1/z < 1/w + 1/y"}, {"label": "C", "text": "x > y"}, {"label": "D", "text": "1/w + 1/x < 1/y + 1/z"}], "answerKey": "B", "model_answer": ""}
{"question": "The hit ratio of a cache memory is the percentage of accesses (reads and writes) for which data are found in the cache. Write-through is a policy whereby every write operation updates main memory. Write-back is a policy whereby a write operation to a line found in the cache does not affect main memory until the line is evicted from the cache. Write-allocation is a policy whereby a cache line is allocated and loaded on a write-miss. If it is assumed that write-allocation is always used, which of the following is true?", "choices": [{"label": "A", "text": "Write-back usually results in a better hit ratio than write-through."}, {"label": "B", "text": "Write-through usually results in a better hit ratio than write-back."}, {"label": "C", "text": "The percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through."}, {"label": "D", "text": "The percentage of write operations resulting in a main memory operation will never be larger for writethrough than for write-back."}], "answerKey": "C", "model_answer": ""}
{"question": "A particular disk unit uses a bit string to record the occupancy or vacancy of its tracks, with O denoting vacant and 1 denoting occupied. A 32-bit segment of this string has the hexadecimal value D4FE2003. The percentage of occupied tracks for the corresponding part of the disk, to the nearest percent, is", "choices": [{"label": "A", "text": "12%"}, {"label": "B", "text": "25%"}, {"label": "C", "text": "38%"}, {"label": "D", "text": "44%"}], "answerKey": "D", "model_answer": ""}
{"question": "An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. Which of the following undirected graphs must have an Euler circuit?\nI. A complete graph with 12 vertices\nII. A complete graph with 13 vertices\nIII. A tree with 13 vertices", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "B", "model_answer": "LECTURE: An undirected graph has an Euler circuit if and only if the graph has exactly two more edges than vertices.\nA complete graph is a graph with all pairs of vertices connected by edges.\nA tree is a complete graph without any cycles.\nSo, a tree is a graph with exactly two more edges than vertices.\nChoice \"I only\" is incorrect.\nThe complete graph with 12 vertices is a tree, and it has exactly two more edges than vertices. So, this graph must have an Euler circuit.\nChoice \"II only\" is incorrect.\nThe complete graph with 13 vertices is a tree, and it has exactly two more edges than vertices. So, this graph must have an Euler circuit.\nChoice \"III only\" is incorrect.\nA graph is a tree if and only if it has no cycles. So, a tree is a graph with exactly two more edges than vertices.\nChoice \"I and II\" is incorrect.\nBoth complete graphs have 13 vertices and are trees. So, each of them must have an Euler circuit.\nChoice \"II only\" is incorrect.\nBoth complete graphs have 13 vertices and are trees. So, each of them must have an Euler circuit."}
{"question": "Which of the following characteristics of a programming language is best specified using a context-free grammar?", "choices": [{"label": "A", "text": "Identifier length"}, {"label": "B", "text": "Maximum level of nesting"}, {"label": "C", "text": "Operator precedence"}, {"label": "D", "text": "Type compatibility"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following statements about datagrams sent by a node in a network using IPv4 protocol is (are) true?\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nIII. Datagrams are reassembled only at the destination.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "LECTURE: When a node in a network sends a datagram to a destination, the datagram is sent over the links of a path to the destination. The path may include links to other nodes in the network.\nThe path may include links that have different maximum transmission unit (MTU) sizes. The MTU is the largest amount of data that can be sent over a link. If a datagram is too big to be sent over a link, it must be broken into smaller fragments.\nA datagram may be fragmented during routing. This occurs when a link MTU is smaller than the datagram. The datagram is broken into fragments, each of which is sent over a link. When the fragments reach the destination, they are reassembled into the original datagram.\nA datagram is reassembled only at the destination. This pattern is for the Transmission Control Protocol (TCP), which is a connection-oriented protocol. When a datagram is fragmented, each fragment is sent with a fragment offset that indicates the position of the fragment in the original datagram. The destination uses this information to reassemble the fragments into the original datagram.\nSOLUTION: II. Datagrams may be fragmented during routing.\nA datagram may be fragmented during routing if a link MTU is smaller than the datagram.\nThis statement is true.\nIII. Datagrams are reassembled only at the destination.\nA datagram is reassembled only at the destination. This is because TCP is a connection-oriented protocol. When a datagram is fragmented, each fragment is sent with a fragment offset that indicates the position of the fragment in the original datagram. The destination uses this information to reassemble the fragments into the original datagram.\nThis statement is false.\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nDatagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination. If a datagram is larger than the smallest MTU of all the links, it must be broken into smaller fragments.\nThis statement is true."}
{"question": "A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. Which of the following job-scheduling policies is starvation-free?", "choices": [{"label": "A", "text": "Round-robin"}, {"label": "B", "text": "Priority queuing"}, {"label": "C", "text": "Shortest job first"}, {"label": "D", "text": "Youngest job first"}], "answerKey": "A", "model_answer": "LECTURE: A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. If a job has been waiting for service for a long time, it will not be given a timeslice.\nThe round-robin policy is starvation-free. When a job does get a timeslice, the scheduler runs it for a fixed amount of time, called a timeslice. If the job does not complete in the timeslice, it will be given another timeslice. If the job still does not complete, it will be given another timeslice, and so on.\nThe priority queuing policy is not starvation-free. Higher-priority jobs are served first, but lower-priority jobs may never get served.\nThe shortest job first policy is not starvation-free. A short job may be given a timeslice after a long job has been given many timeslices. The short job may spend all its timeslices before the long job gets a timeslice.\nThe youngest job first policy is not starvation-free. A job is considered to be young until it has been waiting for service for a long time. A young job will not get a timeslice until an older job has been given many timeslices."}
{"question": "Of the following, which gives the best upper bound for the value of f(N) where f is a solution to the recurrence f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0?", "choices": [{"label": "A", "text": "O(log N)"}, {"label": "B", "text": "O(N log N)"}, {"label": "C", "text": "O(log N) + 0(1)"}, {"label": "D", "text": "O((log N)^2)"}], "answerKey": "D", "model_answer": ""}
{"question": "Company X shipped 5 computer chips, 1 of which was defective, and Company Y shipped 4 computer chips, 2 of which were defective. One computer chip is to be chosen uniformly at random from the 9 chips shipped by the companies. If the chosen chip is found to be defective, what is the probability that the chip came from Company Y?", "choices": [{"label": "A", "text": "2 / 9"}, {"label": "B", "text": "4 / 9"}, {"label": "C", "text": "1 / 2"}, {"label": "D", "text": "2 / 3"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following problems can be solved by a standard greedy algorithm?\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights\nII. Finding a maximum clique in an undirected graph\nIII. Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A graph is a collection of nodes or vertices connected by edges or arcs.\nA simple graph is a graph with no loops (edges that start and end at the same node).\nAn undirected graph is a simple graph in which every edge is connected to exactly two nodes.\nA directed graph is a simple graph in which every edge is connected to exactly one node.\nA graph with no edges is called an empty graph.\nA graph with one edge is called a tree.\nA graph with no nodes is called an empty graph.\nA graph with one node is called a branch.\nA graph with more than one node is called a graph.\nA maximal independent set is a set of nodes with no edges connecting them.\nA maximal clique is a set of nodes with a common neighbor.\nA minimum spanning tree is a tree that connects all the nodes in a graph with the smallest possible total edge weight.\nA maximum flow is a value such that no edge in a directed graph has a weight exceeding the maximum flow.\nSOLUTION: A standard greedy algorithm is a simple algorithm that follows the \"divide and conquer\" strategy. This strategy involves dividing a complex problem into two or more smaller, simpler problems, solving each smaller problem, and then combining the solutions to the smaller problems to get a solution to the original problem.\nA standard greedy algorithm can solve the following types of problems:\na problem with a greedy solution, which is a solution that can be found by selecting elements one at a time in a way that maintains the optimal solution;\na problem that can be divided into subproblems, with each subproblem being solved by a standard greedy algorithm;\na problem that can be formed by composing a number of simple problems, with each simple problem being solved by a standard greedy algorithm.\nA standard greedy algorithm cannot solve the following types of problems:\na problem with a local optimum, which is a solution that is not optimal when any of the elements are chosen later;\na problem with a global optimum, which is a solution that is optimal when any of the elements are chosen;\na problem that cannot be divided into subproblems, with each subproblem being solved by a standard greedy algorithm.\nA minimum spanning tree in an undirected graph with positive-integer edge weights is a problem with a greedy solution. You can find a minimum spanning tree by selecting elements one at a time in a way that maintains the optimal solution. First, choose the smallest available edge. Then, add the edge with the smallest available weight that connects the two nodes not already in the tree.\nA maximum clique in an undirected graph is a problem with a greedy solution. You can find a maximum clique by selecting elements one at a time in a way that maintains the optimal solution. First, choose the largest available node. Then, add the node with the largest available number of neighbors that is not already in the clique.\nA maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities is a problem with a greedy solution. You can find a maximum flow by selecting elements one at a time in a way that maintains the optimal solution. First, add the edge with the smallest available capacity that is not already in the flow."}
{"question": "A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined. Which of the following is (are) correct?\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: A hash table is a data structure that uses a hash function to map keys to values.\nWhen you add a new item to a hash table, it may be assigned a new value. This is because the hash function assigns the item to an empty bucket in the hash table.\nIf the hash function is not properly designed, some bucket may end up containing more items than others. This is called a hash collision.\nThere are several ways to handle hash collisions. One way is to use a resize function. When a hash collision occurs, the resize function is used to make the hash table larger.\nThe length of a hash table is called its size. The size of a hash table should be chosen carefully. A hash table with a size that is too small will start to reject new items too frequently. A hash table with a size that is too large will start to waste space too frequently.\nSOLUTION: A hash table is a data structure that uses a hash function to map keys to values.\nWhen you add a new item to a hash table, it may be assigned a new value. This is because the hash function assigns the item to an empty bucket in the hash table.\nIf the hash function is not properly designed, some bucket may end up containing more items than others. This is called a hash collision.\nThere are several ways to handle hash collisions. One way is to use a resize function. When a hash collision occurs, the resize function is used to make the hash table larger.\nThe length of a hash table is called its size. The size of a hash table should be chosen carefully. A hash table with a size that is too small will start to reject new items too frequently. A hash table with a size that is too large will start to waste space too frequently.\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.\nTo check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined.\nSo, the hash table size should increase with the number of words in the document.\nSince the size of the hash table should increase with the size of the document, a larger hash table size will be needed for longer documents."}
{"question": "One approach to handling fuzzy logic data might be to design a computer using ternary (base-3) logic so that data could be stored as \u201ctrue,\u201d \u201cfalse,\u201d and \u201cunknown.\u201d If each ternary logic element is called a flit, how many flits are required to represent at least 256 different values?", "choices": [{"label": "A", "text": "4"}, {"label": "B", "text": "5"}, {"label": "C", "text": "6"}, {"label": "D", "text": "7"}], "answerKey": "C", "model_answer": "LECTURE: Ternary logic is a binary logic that uses three possible values: 'true', 'false', and 'unknown'. In ternary logic, each piece of information is represented by a single bit.\nA ternary logic element is called a flit. A flit has a value of 'true', 'false', or 'unknown'.\nTo represent a number in ternary logic, first write the number in binary form. Then, for each bit in the binary number, decide whether to assign a value of 'true', 'false', or 'unknown'. For example, the binary number 1011 is equivalent to the ternary number 1101.\nThe base-3 number system uses ternary logic. In base-3, numbers are represented in ternary form. For example, the base-3 representation of 10 is 110.\nSOLUTION: To represent at least 256 different values, you need at least 2 flits. Each flit can have one of three values. So, 2 flits can represent at least 3 x 3 = 9 different values.\n256 is equal to 2^8. There are 8 bits in 256. So, 8 flits are required to represent 256 different values."}
{"question": "Local caching of files is common in distributed file systems, but it has the disadvantage that", "choices": [{"label": "A", "text": "Temporary inconsistencies among views of a file by different machines can result"}, {"label": "B", "text": "The file system is likely to be corrupted when a computer crashes"}, {"label": "C", "text": "A much higher amount of network traffic results"}, {"label": "D", "text": "Caching makes file migration impossible"}], "answerKey": "A", "model_answer": ""}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-through policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2048"}], "answerKey": "C", "model_answer": "LECTURE: In a write-through policy, when a cache blocks are written to, both the cache block and its value are written to main memory. This is called a write-once, read-many policy.\nWith a write-through policy, the entire array A is written to memory. The loop writes 256 bytes to memory."}
{"question": "At time 0, five jobs are available for execution on a single processor, with service times of 25, 15, 5, 3, and 2 time units. Which of the following is the minimum value of the average completion time of these jobs?", "choices": [{"label": "A", "text": "50"}, {"label": "B", "text": "208/5"}, {"label": "C", "text": "92/5"}, {"label": "D", "text": "10"}], "answerKey": "C", "model_answer": "LECTURE: The average completion time of a set of jobs is the time it takes to complete all the jobs. The average completion time of these five jobs is the total time it takes to complete all the jobs, divided by the number of jobs.\nThe total time it takes to complete all the jobs is 25 + 15 + 5 + 3 + 2 = 53 time units.\nThe number of jobs is 5.\nSo, the minimum value of the average completion time of these jobs is 53/5 = 10.6.\nRounding this value to the nearest tenth, the minimum average completion time is 10."}
{"question": "Let G = (V, E) be a connected, undirected graph, and let a and b be two distinct vertices in V. Let P_1 be the problem of finding a shortest simple path between a and b, and let P_2 be the problem of finding a longest simple path between a and b. Which of the following statements about P_1 and P_2 is true?", "choices": [{"label": "A", "text": "Both P_1 and P_2 can be solved in polynomial time."}, {"label": "B", "text": "P_1 can be solved in polynomial time but P_2 is not known to be solvable in polynomial time."}, {"label": "C", "text": "P_1 is not known to be solvable in polynomial time but P_2 can be solved in polynomial time."}, {"label": "D", "text": "It is not known whether either P_1 or P_2 can be solved in polynomial time."}], "answerKey": "B", "model_answer": ""}
{"question": "A major advantage of direct mapping of a cache is its simplicity. The main disadvantage of this organization is that", "choices": [{"label": "A", "text": "it does not allow simultaneous access to the intended data and its tag"}, {"label": "B", "text": "it is more expensive than other types of cache organizations"}, {"label": "C", "text": "the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache"}, {"label": "D", "text": "its access time is greater than that of other cache organizations"}], "answerKey": "C", "model_answer": ""}
{"question": "Let M be a single-tape, deterministic Turing machine with tape alphabet {blank,0,1}, and let C denote the (possibly infinite) computation of M starting with a blank tape. The input to each problem below is M, together with a positive integer n. Which of the following problems is (are) decidable?\nI. The computation C lasts for at least n steps.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nIII. M scans at least n distinct tape squares during the computation C.", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "D", "model_answer": "LECTURE: A Turing machine is a mathematical model of a computer. It consists of a tape of infinite length, divided into cells, and a machine that can read and write on the tape and move the tape back and forth. The machine starts with an initial tape configuration, and it performs a computation by moving back and forth on the tape, reading and writing cells, and changing the tape configuration.\nA Turing machine M is said to compute a sequence of symbols if, starting with an initial tape configuration with only blank cells, M moves its tape head to write the first symbol in the sequence, and then M moves its tape head to write the rest of the sequence in order.\nA problem is decidable if there is a Turing machine that can solve it.\nThe following are decidable problems:\nA problem is decidable if there is a Turing machine that can solve it.\nThe input to a decidable problem is always in a finite number of states.\nAn undecidable problem is not decidable.\nAn undecidable problem is not in a finite number of states.\nThe halting problem is undecidable.\nThe input to the halting problem is a Turing machine M. The problem is to decide whether M will ever stop running."}
{"question": "A 3-way, set-associative cache is", "choices": [{"label": "A", "text": "one in which each main memory word can be stored at any of 3 cache locations"}, {"label": "B", "text": "effective only if 3 or fewer processes are running alternately on the processor"}, {"label": "C", "text": "possible only with write-back"}, {"label": "D", "text": "faster to access than a direct-mapped cache"}], "answerKey": "A", "model_answer": ""}
{"question": "Consider an object-oriented language in which all entities are objects. Two relationships arise: (1) the instance relationship, between an object and the class of which that object is a member, and (2) the subclass relationship, between a class and the superclass from which that class inherits properties. In such a language, when a message is sent to an object requesting execution of one of its methods (procedures), the method is located by following", "choices": [{"label": "A", "text": "one instance link and then zero or more subclass links"}, {"label": "B", "text": "one or more instance links and then one or more subclass links"}, {"label": "C", "text": "one or more instance links"}, {"label": "D", "text": "one subclass link and then one or more instance links"}], "answerKey": "A", "model_answer": ""}
{"question": "In a pipelined RISC computer where all arithmetic instructions have the same CPI (cycles per instruction), which of the following actions would improve the execution time of a typical program?\nI. Increasing the clock cycle rate\nII. Disallowing any forwarding in the pipeline\nIII. Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "D", "model_answer": "LECTURE: In a pipelined RISC computer, the clock cycle rate is the rate at which the clock signal changes state. The clock cycle time is the time it takes for the clock signal to change state. The clock cycle rate is related to the clock cycle time by the formula: clock cycle rate = clock cycle time / time per instruction.\nThe time per instruction is determined by the instruction set architecture, and it is equal for all instructions in a typical RISC computer.\nFor a pipelined RISC computer to execute a program, it must have enough instructions waiting in the pipeline. The supplies number is a measure of the number of instructions in the pipeline. The supplies number is equal to the pipeline depth multiplied by the number of instructions per clock cycle.\nWith more instructions in the pipeline, a pipelined RISC computer can complete more instructions per second. This can improve the execution time of a typical program.\nSOLUTION: Increasing the clock cycle rate would increase the number of instructions per second that the pipelined RISC computer can execute. This would improve the execution time of a typical program.\nDisallowing any forwarding in the pipeline would force the pipelined RISC computer to execute instructions sequentially. This would prevent the computer from executing multiple instructions at the same time. As a result, the computer's execution time would be equal to the time it takes to execute a single instruction. This would not improve the execution time of a typical program.\nDoubling the sizes of the instruction cache and the data cache without changing the clock cycle time would not improve the execution time of a typical program. The execution time of a program is determined by the time it takes to execute the instructions in the program. The instructions in a program can be in the cache or not. If the instructions are in the cache, they can be executed more quickly. But doubling the sizes of the caches would not make any instructions in a program appear in the caches. So, the execution time of a program would not be improved."}
{"question": "A microcomputer used for data acquisition and control is required to digitize and process four analog input signals and to output their average continually; i.e., in real time. The time for an external analog-to-digital converter (which is triggered by a CPU instruction) to digitize one input is 12 microseconds, and only one digitization occurs at a time. Five CPU instructions, including the triggering instruction, must be executed for each signal digitized. Ten CPU instructions are executed in order to average each set of four samples and output this value. The time to convert the output from digital to analog form is to be ignored. If it is assumed that suitable data buffering is employed, then the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates, is", "choices": [{"label": "A", "text": "0.8 microseconds"}, {"label": "B", "text": "1.2 microseconds"}, {"label": "C", "text": "1.6 microseconds"}, {"label": "D", "text": "2.4 microseconds"}], "answerKey": "C", "model_answer": ""}
{"question": "Suppose that a certain software product has a mean time between failures of 10,000 hours and has a mean time to repair of 20 hours. If the product is used by 100 customers, what is its availability?", "choices": [{"label": "A", "text": "80%"}, {"label": "B", "text": "90%"}, {"label": "C", "text": "98%"}, {"label": "D", "text": "99.80%"}], "answerKey": "D", "model_answer": ""}
