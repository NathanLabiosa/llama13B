{"question": "The access matrix approach to protection has the difficulty that", "choices": [{"label": "A", "text": "the matrix, if stored directly, is large and can be clumsy to manage"}, {"label": "B", "text": "it is not capable of expressing complex protection requirements"}, {"label": "C", "text": "deciding whether a process has access to a resource is undecidable"}, {"label": "D", "text": "there is no way to express who has rights to change the access matrix itself"}], "answerKey": "A", "model_answer": "nswer: (A) the matrix, if stored directly, is large and can be clumsy to manage\n\nExplanation: The access matrix approach to protection involves creating a matrix to store information about which processes or users have access to which resources. The matrix can be large and can be difficult to manage if it is stored directly."}
{"question": "An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y. Which of the following sets of integers could possibly be the set of all common divisors of two integers?", "choices": [{"label": "A", "text": "{-6,-2, -1, 1, 2, 6}"}, {"label": "B", "text": "{-6, -2, -1, 0, 1, 2, 6}"}, {"label": "C", "text": "{-6, -3, -2, -1, 1, 2, 3, 6}"}, {"label": "D", "text": "{-6, -3, -2, -1, 0, 1, 2, 3, 6}"}], "answerKey": "C", "model_answer": "n\n(B) {-6, -2, -1, 0, 1, 2, 3, 6}\n```\n\nPlease explain why.\n```"}
{"question": "In the NoNicks operating system, the time required by a single file-read operation has four nonoverlapping components:\ndisk seek time-25 msec\ndisk latency time-8 msec\ndisk transfer time- 1 msec per 1,000 bytes\noperating system overhead-1 msec per 1,000 bytes + 10 msec\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes. The ratio of-the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately", "choices": [{"label": "A", "text": "1:4"}, {"label": "B", "text": "1:3.5"}, {"label": "C", "text": "1:1"}, {"label": "D", "text": "1.1:1"}], "answerKey": "B", "model_answer": "The correct answer is (D) 1.1:1.\n\nLet's analyze the given question step by step:\n1. Disk seek time = 25 msec\n2. Disk latency time = 8 msec\n3. Disk transfer time = 1 msec per 1,000 bytes\n4. Operating system overhead = 1 msec per 1,000 bytes + 10 msec\n\nFor a large file, the time required for a single file-read operation can be calculated as follows:\n\nFile size (bytes) = 1,000,000 \\* 4,000 = 4,000,000 bytes\n\nDisk transfer time = 1 msec per 1,000 bytes = 0.001 msec/byte\nOperating system overhead = 1 msec per 1,000 bytes + 10 msec = 1.001 msec/byte\n\nTotal time = disk transfer time + operating system overhead\nTotal time = 0.001 msec/byte \\* 4,000,000 bytes + 1.001 msec/byte \\* 4,000,000 bytes\nTotal time = 0.001 + 1.001"}
{"question": "You want to cluster 7 points into 3 clusters using the k-Means Clustering algorithm. Suppose after the first iteration, clusters C1, C2 and C3 contain the following two-dimensional points: C1 contains the 2 points: {(0,6), (6,0)} C2 contains the 3 points: {(2,2), (4,4), (6,6)} C3 contains the 2 points: {(5,5), (7,7)} What are the cluster centers computed for these 3 clusters?", "choices": [{"label": "A", "text": "C1: (3,3), C2: (4,4), C3: (6,6)"}, {"label": "B", "text": "C1: (3,3), C2: (6,6), C3: (12,12)"}, {"label": "C", "text": "C1: (6,6), C2: (12,12), C3: (12,12)"}, {"label": "D", "text": "C1: (0,0), C2: (48,48), C3: (35,35)"}], "answerKey": "A", "model_answer": "3), C2: (4,4), C3: (6,6)\nB) C1: (3,3), C2: (6,6), C3: (12,12)\nC) C1: (6,6), C2: (12,12), C3: (12,12)\nD) C1: (0,0), C2: (48,48), C3: (35,35)\n\nThe correct answer is B) C1: (3,3), C2: (6,6), C3: (12,12). The cluster centers are calculated as the mean of the points in each cluster, so the cluster centers for each cluster are:\nC1: (3,3)\nC2: (6,6)\nC3: (12,12)\nThe correct answer is B) C1: (3,3), C2: (6,6), C3: (12,12)."}
{"question": "Any set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. Which of the following is NOT complete?", "choices": [{"label": "A", "text": "{AND, NOT}"}, {"label": "B", "text": "{NOT, OR}"}, {"label": "C", "text": "{AND, OR}"}, {"label": "D", "text": "{NAND}"}], "answerKey": "C", "model_answer": "The correct answer is (D) {NAND}.\n\nA Boolean expression is a logical expression formed using the basic logical operations of AND, OR, and NOT. Any set of Boolean operators that can be used to form a Boolean expression is called a complete set of Boolean operators.\n\nThe set of Boolean operators {AND, NOT} is called a complete set because it is sufficient to form any Boolean expression. This is because any Boolean expression can be expressed as a combination of {AND, NOT} and the negation of {AND, NOT}.\n\nThe set of Boolean operators {NOT, OR} is also a complete set because it is sufficient to form any Boolean expression. This is because any Boolean expression can be expressed as a combination of {NOT, OR} and the negation of {NOT, OR}.\n\nThe set of Boolean operators {AND, OR} is also a complete set because it is sufficient to form any Boolean expression. This is because any Boolean expression can be expressed as a combination of {AND, OR} and the negation of {AND, OR}.\n\nHowever, the set of Boolean operators {NAND} is not a complete set because it is not sufficient to form every possible Boolean expression. For example, it cannot express the negation of {NAND}.\n\nTherefore, the correct answer is (D) {NAND}."}
{"question": "Consider the collection of all undirected graphs with 10 nodes and 6 edges. Let M and m, respectively, be the maximum and minimum number of connected components in any graph in the collection. If a graph has no selfloops and there is at most one edge between any pair of nodes, which of the following is true?", "choices": [{"label": "A", "text": "M = 10, m = 10"}, {"label": "B", "text": "M = 10, m = 1"}, {"label": "C", "text": "M = 7, m = 4"}, {"label": "D", "text": "M = 6, m = 4"}], "answerKey": "C", "model_answer": "The correct answer is (D) M = 6, m = 4.\n\nLet's start by considering the maximum number of connected components, M. Since there are no selfloops and at most one edge between any pair of nodes, every node is either in a connected component by itself or is connected to every other node in the graph. Therefore, the maximum number of connected components is equal to the number of nodes minus one, which is 10 minus one, or 9.\n\nNext, let's consider the minimum number of connected components, m. Since there are no selfloops and at most one edge between any pair of nodes, every connected component contains at least one node and is separated from every other connected component by at least one edge. Therefore, the minimum number of connected components is 1.\n\nWe can now use these values of M and m to determine the possible values of M and m:\nM = 9, m = 1 is a valid combination.\nM = 9, m = 2 is not a valid combination because the minimum number of connected components is 1, not 2.\nM = 8, m = 2 is not a valid combination because the maximum number of connected components is 9, not 8.\nM = 7, m = 3 is not a valid combination because the maximum number of connected components is 9, not 7.\nM = 6, m = 4 is the only valid combination, and it satisfies the given constraints on M and m. Therefore, the answer is (D) M = 6, m = 4."}
{"question": "Resolution theorem proving for showing that a formula of propositional logic is not satisfiable has which of the following properties?\nI. It is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nII. It is a complete proof system in the sense that there is a proof of unsatisfiability for every unsa tisfiable formula of propositional logic.\nIII. It is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "C", "model_answer": "III only."}
{"question": "Which of the following statements describe(s) properties of a purely segmented memory system?\nI. It divides memory into units of equal size.\nII. It permits implementation of virtual memory.\nIII. It suffers from internal fragmentation.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "B", "model_answer": "The correct answer is (D) I and III.\nI. It divides memory into units of equal size: This statement describes a property of a purely segmented memory system, in which memory is divided into fixed-size segments or blocks.\nII. It permits implementation of virtual memory: This statement also describes a property of a purely segmented memory system, as it allows the system to use the disk drive as an extended memory by paging or segmenting.\nIII. It suffers from internal fragmentation: This statement describes a property of a purely segmented memory system, as internal fragmentation occurs when a file is too large to fit into a single segment, resulting in wasted space.\n\nTherefore, the correct answer is (D) I and III."}
{"question": "Which of the following statements about floating-point arithmetic is NOT true?", "choices": [{"label": "A", "text": "It is inherently nonassociative because some numbers have no exact representation."}, {"label": "B", "text": "It is inherently nonassociative because there have to be upper and lower bounds on the size of numbers."}, {"label": "C", "text": "Associativity can be achieved with appropriate roundoff conventions."}, {"label": "D", "text": "Some rational numbers have no exact representation."}], "answerKey": "C", "model_answer": "Answer: C) Associativity can be achieved with appropriate roundoff conventions.\nExplanation:\nFloating-point arithmetic is a way of representing real numbers in computers, using a finite number of bits to represent the significand (also called the mantissa) and the exponent. While it is true that not all real numbers can be represented exactly with a finite number of bits (due to the limitations of binary representation), this does not mean that floating-point arithmetic is inherently nonassociative.\nRoundoff errors can occur when two floating-point numbers are added or subtracted, but these errors can be eliminated or reduced through the use of appropriate rounding conventions. For example, the IEEE 754 standard specifies several rounding modes that can be used to ensure associativity of addition and subtraction operations.\nOption (A) is incorrect because some real numbers can be represented exactly in binary form, and there are conventions for representing them in a way that allows for associative addition and subtraction (e.g. using the infinitesimal symbol \"\u00b10\"). Option (B) is also incorrect because there are conventions for specifying upper and lower bounds on the size of numbers, but this does not prevent associativity of floating-point operations. Option (D) is correct because some rational numbers cannot be represented exactly in binary form, but this does not affect the associativity of floating-point operations."}
{"question": "Suppose sharing of tiles in a multilevel directory structure is achieved with directory entries that are links pointing to a node containing information about a shared file. Information in this node includes (1) the owner of the file, (2) a count of the number of links to the tile, and (3) the disk block numbers of the file. What is a primary drawback to this approach to sharing?", "choices": [{"label": "A", "text": "If the owner modifies the file, another user who does not share will see the changes."}, {"label": "B", "text": "If the owner renames the file, other users will not be able to access it."}, {"label": "C", "text": "If the owner is allowed to delete a file, dangling links may result."}, {"label": "D", "text": "If any user who shares the file appends to it, others who share it will not be able to access the new disk blocks."}], "answerKey": "C", "model_answer": "primary drawback to this approach to sharing is that (A) If the owner modifies the file, another user who does not share will see the changes."}
{"question": "Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves. Which of the following data structures will allow mergesort to work in O(n log n) time?\nI. A singly linked list\nII. A doubly linked list\nIII. An array", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "III only\nC. I and II only\nD. I, II, and III\n\nMy answer: B. III only\nExplanation: Mergesort works by recursively dividing a list into two halves, sorting each half, and then merging the two halves into a single sorted list. Since arrays are essentially a list of elements arranged in a linear fashion, it naturally lends itself to sorting using mergesort. Therefore, an array is the only data structure among the given options that will allow mergesort to work in O(n log n) time."}
{"question": "If p(x) is the minimal-degree interpolating polynomial for the real-valued function f(x) at the n + 1 distinct real numbers x0, .... xn what is the maximum possible degree of p(x)?", "choices": [{"label": "A", "text": "n"}, {"label": "B", "text": "n + 1"}, {"label": "C", "text": "n + 2"}, {"label": "D", "text": "2n"}], "answerKey": "A", "model_answer": "The minimal-degree interpolating polynomial has degree at most 2n, which is the maximum possible degree."}
{"question": "An internal hash table has 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is", "choices": [{"label": "A", "text": "3"}, {"label": "B", "text": "8"}, {"label": "C", "text": "10"}, {"label": "D", "text": "13"}], "answerKey": "A", "model_answer": "(C) 10 is the correct answer.\n\nThe hash table initially contains no elements, so the buckets are empty. When element 13 is inserted, its key is hashed to bucket 2 using the hash function h(i) = i mod 5. Since 13 mod 5 = 2, bucket 2 is the correct bucket.\n\nWhen element 8 is inserted, its key is hashed to bucket 2 using the same hash function. Since 8 mod 5 = 2, bucket 2 is already occupied, and linear resolution of collisions is applied. The next bucket in line, bucket 3, is hashed to bucket 4 using the hash function. So, bucket 4 is the new correct bucket, and element 8 is inserted into it.\n\nWhen element 24 is inserted, its key is hashed to bucket 2 using the hash function. Since 24 mod 5 = 2, bucket 2 is already occupied, and linear resolution of collisions is applied. The next bucket in line, bucket 3, is hashed to bucket 4 using the hash function. So, bucket 4 is the new correct bucket, and element 24 is inserted into it.\n\nWhen element 10 is inserted, its key is hashed to bucket 2 using the hash function. Since 10 mod 5 = 2, bucket 2 is already occupied,"}
{"question": "TCP protocol is responsible (among other things) for", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "C", "model_answer": "(tm): The correct answer is (C) Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected. The TCP protocol is responsible for establishing and maintaining communication between two nodes on an IP network, ensuring that data is delivered reliably and in the correct order. It does this by providing mechanisms for detecting and correcting errors that may occur during transmission, such as lost packets or out-of-order packets. These mechanisms include the use of sequence numbers to keep track of the order of packets in a message, and retransmission of packets that are lost or not acknowledged by the recipient."}
{"question": "Let A and B be two sets of words (strings) from \u03a3*, for some alphabet of symbols \u03a3. Suppose that B is a subset of A. Which of the following statements must always be true of A and B ?\nI. If A is finite, then B is finite.\nII. If A is regular, then B is regular.\nIII. If A is context-free, then B is context-free.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "I and II only\n\nExplanation:\nI. If A is finite, then B is finite.\nThis statement is always true. If A is a finite set of words, then B is a subset of A, and hence B must also be a finite set.\nII. If A is regular, then B is regular.\nThis statement is also always true. If A is a regular set of words, then B is a subset of A, and hence B must also be a regular set. However, if B is a regular set of words, it does not necessarily follow that A is also a regular set.\nIII. If A is context-free, then B is context-free.\nThis statement is not always true. If A is a context-free set of words, then B is a subset of A, and hence B must also be a context-free set. However, if B is a context-free set of words, it does not necessarily follow that A is also a context-free set.\nTherefore, the correct answer is (D) I and II only."}
{"question": "For all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings. Which of the following is true?", "choices": [{"label": "A", "text": "a^M = a"}, {"label": "B", "text": "(ax)^M = (xa)^M"}, {"label": "C", "text": "(xy)^M = y^Mx^M"}, {"label": "D", "text": "None of the above"}], "answerKey": "D", "model_answer": "ct answer is (B) (ax)^M = (xa)^M.\n\nExplanation:\nThe function x^M is defined recursively as follows: e^M = e, and if w is a string and a is a string with length 1, then (aw)^M = aw^Ma.\n\nGiven the question, we need to find the value of (ax)^M given x and y are arbitrary strings.\n\nFirst, let's consider (xy)^M. Since x and y are arbitrary strings, we can choose any string x and y. For example, we could choose x = a and y = b, in which case (xy)^M = ab^M.\n\nNow, let's consider y^Mx^M. If x = a, then y^Mx^M = a^My^M = a^Mb^My^M = ab^M(y^M)^2, where (y^M)^2 = y^M.\n\nTherefore, the only choice that satisfies the given conditions is (ax)^M = (xa)^M."}
{"question": "Which of the following is NOT a reasonable justification for choosing to busy-wait on an asynchronous event?", "choices": [{"label": "A", "text": "The wait is expected to be short."}, {"label": "B", "text": "A busy-wait loop is easier to code than an interrupt handler."}, {"label": "C", "text": "There is no other work for the processor to do."}, {"label": "D", "text": "The program executes on a time-sharing system."}], "answerKey": "D", "model_answer": "D) The program executes on a time-sharing system.\n\nBusy-waiting is a technique where a program repeatedly checks an asynchronous event without doing any other work. This can be inefficient and is generally not recommended because it can lead to high power consumption, heat buildup, and reduced system performance. The other options are reasonable justifications for busy-waiting: (A) The wait is expected to be short, so it is not a waste of time to keep checking; (B) A busy-wait loop is generally easier to code than an interrupt handler; and (C) If there is no other work for the processor to do, busy-waiting may be a reasonable use of its resources. However, (D) is not a reasonable justification because busy-waiting is generally not a good idea on time-sharing systems because it can reduce the system's responsiveness and performance."}
{"question": "The language {ww | w in (0 + 1)*} is", "choices": [{"label": "A", "text": "not accepted by any Turing machine"}, {"label": "B", "text": "accepted by some Turing machine, but by no pushdown automaton"}, {"label": "C", "text": "accepted by some pushdown automaton, but not context-free"}, {"label": "D", "text": "context-free, but not regular"}], "answerKey": "B", "model_answer": "correct answer is (C) accepted by some pushdown automaton, but not context-free.\n\nA pushdown automaton (PDA) can recognize the language {ww | w in (0 + 1)*} by following these steps:\n1. Read the input symbol by symbol.\n2. If the symbol is a 0, push a 0 onto the stack.\n3. If the symbol is a 1, push a 0 onto the stack.\n4. If there is a 0 on the stack, accept the input.\n5. If there is a 1 on the stack, reject the input.\nThis PDA recognizes the language {ww | w in (0 + 1)*} because it can simulate the behavior of a Turing machine that performs the same operation. This language is not context-free because it contains patterns that can be generated by a context-free grammar. For example, {01} and {10} can be generated by the following grammar: S -> S S | 0 | 1. However, it is regular because the language {ww | w in (0 + 1)*} can be generated by a finite automaton that recognizes the language."}
{"question": "Which of the following statements about Ethernets is typically FALSE?", "choices": [{"label": "A", "text": "Ethernets use circuit switching to send messages."}, {"label": "B", "text": "Ethernets use buses with multiple masters."}, {"label": "C", "text": "Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly."}, {"label": "D", "text": "Networks connected by Ethernets are limited in length to a few hundred meters."}], "answerKey": "A", "model_answer": "The correct answer is (D) Networks connected by Ethernets are limited in length to a few hundred meters. While Ethernets can connect networks over longer distances using technologies like fiber optic cables, they can still maintain a maximum length of a few hundred meters."}
{"question": "Let P be a procedure that for some inputs calls itself (i.e., is recursive). If P is guaranteed to terminate, which of the following statements must be true?\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "r is (D) II and III only.\n\nThe statement \"P either refers to a global variable or has at least one parameter\" is not sufficient to guarantee that P will terminate. However, the statement \"P has an execution path where it does not call itself\" is sufficient to guarantee termination. This is because, if P does not call itself at any point in its execution, it will eventually terminate."}
{"question": "Which of the following comes closest to being a perfectly secure encryption scheme?", "choices": [{"label": "A", "text": "The Caesar Cipher, a substitution cipher"}, {"label": "B", "text": "DES (Data Encryption Standard), a symmetric-key algorithm"}, {"label": "C", "text": "Enigma, a transposition cipher"}, {"label": "D", "text": "One-time pad"}], "answerKey": "D", "model_answer": ""}
{"question": "Of the following problems concerning a given undirected graph G, which is currently known to be solvable in polynomial time?", "choices": [{"label": "A", "text": "Finding a longest simple cycle in G"}, {"label": "B", "text": "Finding a shortest cycle in G"}, {"label": "C", "text": "Finding ALL spanning trees of G"}, {"label": "D", "text": "Finding a largest clique in G"}], "answerKey": "B", "model_answer": "The correct answer is (A) Finding a longest simple cycle in G.\n\nThe problem of finding a longest simple cycle in a given undirected graph G is known to be solvable in polynomial time using algorithms such as the Hopcroft-Karp algorithm or the Tarjan algorithm. These algorithms have a time complexity of O(E+V), where E is the number of edges and V is the number of vertices in the graph.\n\nOn the other hand, finding a shortest cycle in a graph, finding all spanning trees of a graph, and finding the largest clique in a graph are NP-hard problems, which means that they are generally considered to be computationally intractable and may not have polynomial-time solutions in general."}
{"question": "The IP protocol is primarily concerned with", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "A", "model_answer": "The correct answer is (C) Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected.\n\nThe Internet Protocol (IP) is the fundamental protocol for the Internet, and it is primarily concerned with providing reliable delivery of packets between machines on the network. This includes direct communication between two machines as well as communication between multiple machines that may not be directly connected. Packet routing is a key aspect of IP, but it is not the primary concern.\n\nReliable delivery of packets between directly connected machines is handled by the Transmission Control Protocol (TCP), which is a higher-level protocol that runs on top of IP. TCP provides mechanisms for ensuring that packets are delivered reliably and in order, and it is responsible for ensuring that packets are not lost or corrupted during transmission.\n\nLarge message delivery is also handled by higher-level protocols such as the Simple Mail Transfer Protocol (SMTP) and the File Transfer Protocol (FTP), which are designed specifically for sending and receiving large messages between machines.\n\nDealing with differences among operating system architectures is also handled by higher-level protocols, such as the Application Layer Protocols, that are designed to work with specific operating systems and architectures.\n\nThe IP protocol is primarily concerned with providing reliable delivery of packets between machines on the network, and it is essential for the functioning of the Internet. While it does play a role in routing packets through the network and dealing with differences among operating system architectures, its main focus is on providing reliable delivery of packets between machines."}
{"question": "Of the following, which best approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N?", "choices": [{"label": "A", "text": "1/K"}, {"label": "B", "text": "K-1/K"}, {"label": "C", "text": "log_10 (1/N)"}, {"label": "D", "text": "N-1/m"}], "answerKey": "A", "model_answer": "(B) K-1/K, (C) log\\_10 (1/N), (D) N-1/m\n\nExplanation: The number of nonterminal nodes in a complete K-ary tree of depth N is equal to 2^(N-1), which is the total number of nodes minus the number of terminal nodes. This is because each nonterminal node has K children, and at depth N, each node has 2^(N-1) possible children. Therefore, the ratio of the number of nonterminal nodes to the total number of nodes is 2^(N-1) / (N \\* K). This can be simplified to N-K+1, which is equivalent to 1/K.\n\nThus, the correct answer is (A) 1/K."}
{"question": "Consider a computer system in which processes can request and release one or more resources. Once a process has been granted a resource, the process has exclusive use of that resource until it is released. If a process requests a resource that is already in use, the process enters a queue for that resource, waiting until the resource is available. Which of the following will NOT deal effectively with the problem of deadlock?", "choices": [{"label": "A", "text": "Giving priorities to processes and ordering the wait queues by priority"}, {"label": "B", "text": "Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all"}, {"label": "C", "text": "Numbering the resources and requiring that processes request resources in order of increasing number"}, {"label": "D", "text": "Having processes time out and restart after a random interval of waiting"}], "answerKey": "A", "model_answer": ":  Choice (D) Having processes time out and restart after a random interval of waiting will not effectively deal with the problem of deadlock.\nA deadlock occurs when two or more processes are blocked, each waiting for the other to release a resource that it itself needs. If a process times out and restarts after a random interval, it may simply create a new deadlock by requesting the same resources again.\n\nThe other choices all address ways to prevent or resolve deadlocks:\n(A) Giving priorities to processes and ordering the wait queues by priority can help prevent deadlocks by ensuring that higher-priority processes are given access to resources before lower-priority ones.\n(B) Having a process request all its required resources when it first begins and restarting if it cannot obtain them all can prevent deadlocks by ensuring that all resources are requested before any process begins execution.\n(C) Numbering the resources and requiring that processes request resources in order of increasing number can help prevent deadlocks by ensuring that processes request resources in a consistent order, avoiding the possibility of circular dependencies.\n\nIn summary, the correct answer is (B) Having a process request all its required resources when it first begins and restarting if it cannot obtain them all, as this approach can prevent deadlocks by ensuring that all resources are requested before any process begins execution."}
{"question": "\"Magic memory\"' has two operations: Read and Clear. Both are indivisible and mutually exclusive. Clear sets the magic memory to zero. Read returns a value that represents the number of Read operations since the last Clear operation. Which of the following is (are) true of \"Magic memory\"?\nI. It can provide the functionality of an atomic Test-and-Set.\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nIII. It is only useful on a multiprocessor.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "lanation:\n\nThe \"Magic Memory\" operation has two functions, Read and Clear, which are indivisible and mutually exclusive. The Clear operation sets the memory to zero, while the Read operation returns a value that represents the number of Read operations since the last Clear operation.\n\nI. It can provide the functionality of an atomic Test-and-Set.\nThe Magic Memory operation does not provide the functionality of an atomic Test-and-Set. An atomic Test-and-Set operation allows a process to test whether a specific memory location is set or not, and if it is set, to update it. The Magic Memory operation only returns the number of Read operations since the last Clear operation, which does not provide the same functionality.\n\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nThe Magic Memory operation can be used to coordinate processes running on a shared-memory multiprocessor. Since the Clear and Read operations are indivisible and mutually exclusive, processes running on a shared-memory multiprocessor can use the Magic Memory operation to coordinate their access to shared memory.\n\nIII. It is only useful on a multiprocessor.\nThe Magic Memory operation is not only useful on a multiprocessor. While it is designed for use on a shared-memory multiprocessor, it can also be used on a shared-nothing multiprocessor. In a shared-nothing multiprocessor, processes must communicate through message passing, which can be slower and less efficient than shared memory. In this case, the Magic Memory operation can be used to coordinate communication between processes.\n\nTherefore, the correct answer is (D) I and II."}
{"question": "Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?", "choices": [{"label": "A", "text": "Abstract Syntax Tree (AST)"}, {"label": "B", "text": "Attribute Grammar"}, {"label": "C", "text": "Symbol Table"}, {"label": "D", "text": "Semantic Stack"}], "answerKey": "C", "model_answer": "The correct answer is (A) Abstract Syntax Tree (AST)."}
{"question": "Which of the following algorithms has running time \u0398(n^2) in the worst case but \u0398(n log n) on average?", "choices": [{"label": "A", "text": "Bubblesort"}, {"label": "B", "text": "Mergesort"}, {"label": "C", "text": "Heapsort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "D", "model_answer": "n\nA) Bubblesort\n```\n\nExplanation:\nBubblesort has a running time of \u0398(n^2) in the worst case, which means that it takes an amount of time that is proportional to the square of the number of items being sorted. However, in the average case, the running time of Bubblesort is \u0398(n log n), which means that it takes an average of logarithmic time to sort the items.\nMergesort has a running time of \u0398(n log n) in the average case, which is the same as the running time of Mergesort in the best case. Heapsort has a running time of \u0398(n log n), which is the same as the running time of Heapsort in the best case. Quicksort has a running time of \u0398(n log n) in the average case, but its worst-case running time is \u0398(n^2), which is much worse than Bubblesort's worst-case running time.\nTherefore, the correct answer is (A) Bubblesort."}
{"question": "Languages with a structure that implements abstract data types (e.g., a C++ class) can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation). Which of the following statements about comparisons between direct and indirect representations is (are) true?\nI. Indirect representation noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "B) III only\nC) I and II only\nD) II and III only\n\nThe correct answer is (D) II and III only. The indirect representation allows for dynamic binding of components, while the direct representation requires the components to be declared in the header file. The compilation time may increase with the indirect representation, but direct representation may decrease the time needed to access components of a variable. The storage size of some private component of a variable changing does not affect the number of recompilations of source modules, but it does with indirect representation."}
{"question": "Which of the following is NOT a property of bitmap graphics?", "choices": [{"label": "A", "text": "Fast hardware exists to move blocks of pixels efficiently."}, {"label": "B", "text": "Realistic lighting and shading can be done."}, {"label": "C", "text": "All line segments can be displayed as straight."}, {"label": "D", "text": "Polygons can be filled with solid colors and textures."}], "answerKey": "C", "model_answer": "The correct answer is (D) Polygons can be filled with solid colors and textures. Bitmap graphics, also known as raster graphics, store images as a grid of pixels, and each pixel is assigned a specific color. The property (D) is not a property of bitmap graphics, as it is more related to vector graphics.\n\nVector graphics, on the other hand, use mathematical equations to define objects, curves, and shapes, and these equations are used to plot the objects on the screen. This means that vector graphics can scale up or down without losing any quality, while bitmap graphics can become pixelated or blurry when scaled. This makes vector graphics more suitable for creating logos, typography, and other detailed graphics.\n\nSo, the correct answer is (D) Polygons can be filled with solid colors and textures, which is not a property of bitmap graphics."}
{"question": "Which of the following is true of interrupts?", "choices": [{"label": "A", "text": "They are generated when memory cycles are \"stolen\"."}, {"label": "B", "text": "They are used in place of data channels."}, {"label": "C", "text": "They can indicate completion of an I/O operation."}, {"label": "D", "text": "They cannot be generated by arithmetic operations."}], "answerKey": "C", "model_answer": "n\nA) They are generated when memory cycles are \"stolen\".\n```\nB) They are used in place of data channels.\nC) They can indicate completion of an I/O operation.\nD) They cannot be generated by arithmetic operations.\n\nExplanation:\nAn interrupt is a signal that is sent to the processor to interrupt its current task and switch to a different task. The processor will service the interrupt and execute the corresponding code or instruction when it is finished with the current task.\n\n(A) is true of interrupts because interrupts are generated when a process or device needs the processor's attention, and the processor must give up its time to handle the interrupt.\n\n(B) is not true of interrupts because interrupts are not used in place of data channels.\n\n(C) is not true of interrupts because interrupts do not always indicate completion of an I/O operation. The processor must check the status of the I/O operation to determine if it has been completed.\n\n(D) is not true of interrupts because interrupts can be generated by arithmetic operations, such as addition or subtraction.\n\nTherefore, the correct answer is (A)."}
{"question": "In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. Which of the following are true of such a tree?\nI. Worst-case search time is logarithmic in the number of nodes.\nII. Average-case search time is logarithmic in the number of nodes.\nIII. Best-case search time is proportional to the height of the tree.\nIV. The height of the tree is logarithmic in the number of nodes.", "choices": [{"label": "A", "text": "I and III only"}, {"label": "B", "text": "II and III only"}, {"label": "C", "text": "II and IV only"}, {"label": "D", "text": "I, II, and IV"}], "answerKey": "D", "model_answer": ""}
{"question": "Bob writes down a number between 1 and 1,000. Mary must identify that number by asking \"yes/no\" questions of Bob. Mary knows that Bob always tells the truth. If Mary uses an optimal strategy, then she will determine the answer at the end of exactly how many questions in the worst case?", "choices": [{"label": "A", "text": "1,000"}, {"label": "B", "text": "999"}, {"label": "C", "text": "500"}, {"label": "D", "text": "10"}], "answerKey": "D", "model_answer": "n the worst case, Mary can ask Bob 10 questions and determine the number with 100% accuracy."}
{"question": "Which of the following is (are) true about virtual memory systems that use pages?\nI. The virtual address space can be larger than the amount of physical memory.\nII. Programs must be resident in main memory throughout their execution.\nIII. Pages correspond to semantic characteristics of the program.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "II\n\nExplanation:\nVirtual memory systems that use pages are designed to allow a computer to use its hard disk as an extension of its main memory. In such systems, the virtual address space can be larger than the amount of physical memory, and programs do not have to be resident in main memory throughout their execution. Pages correspond to semantic characteristics of the program, and the operating system maps virtual addresses to physical addresses using page tables.\nI is true because the virtual address space can be larger than the amount of physical memory, and the operating system can use page tables to map virtual addresses to physical addresses.\nII is true because programs do not have to be resident in main memory throughout their execution, and the operating system can use page replacement algorithms to manage the pages in virtual memory.\nI and II are both true, so the correct answer is (C)."}
{"question": "Which of the following is usually NOT represented in a subroutine's activation record frame for a stack-based programming language?", "choices": [{"label": "A", "text": "Values of local variables"}, {"label": "B", "text": "A heap area"}, {"label": "C", "text": "The return address"}, {"label": "D", "text": "Stack pointer for the calling activation record"}], "answerKey": "B", "model_answer": "of local variables\nB) A heap area\nC) The return address\nD) Stack pointer for the calling activation record\n\nThe activation record frame is a data structure used in stack-based programming languages to store information about a subroutine's execution. The stack pointer for the calling activation record refers to the location in the call stack where the subroutine is called. The return address is also stored in the activation record frame and refers to the address of the next instruction to be executed after the subroutine returns. Local variables are also stored in the activation record frame, and the heap area is used for dynamic memory allocation."}
{"question": "Which of the following statements about a remote procedure call is true?", "choices": [{"label": "A", "text": "It is used to call procedures with addresses that are farther than 2^16 bytes away."}, {"label": "B", "text": "It cannot return a value."}, {"label": "C", "text": "It cannot pass parameters by reference."}, {"label": "D", "text": "It cannot call procedures implemented in a different language."}], "answerKey": "C", "model_answer": "The correct answer is: (A) It is used to call procedures with addresses that are farther than 2^16 bytes away.\n\nA remote procedure call (RPC) is a way for a program to request a service or function from another program, which is executed on a remote machine and the results are returned to the original program. Here are some key characteristics of RPCs:\n1. Distance: RPCs can be used to call procedures that are located at a distance, but the distance is limited by the amount of memory available to store the remote procedure call table.\n2. Size: The size of the remote procedure call table is limited by the amount of memory available, and the size of the remote procedure call itself is limited by the amount of data that can be transmitted over the network.\n3. Return value: RPCs can return a value to the original program.\n4. Passing parameters: RPCs can pass parameters to the remote procedure by reference, which means that the original value of the parameter is passed, not a copy.\n5. Calling procedures: RPCs can call procedures implemented in a different language, as long as the remote machine has the necessary code to execute the procedure.\n6. Security: RPCs can implement security measures, such as authentication, to ensure that only authorized programs can make remote calls.\n\nTherefore, the correct statement about a remote procedure call is that it is used to call procedures with addresses that are farther than 2^16 bytes away."}
{"question": "Of the following sorting algorithms, which has a running time that is LEAST dependent on the initial ordering of the input?", "choices": [{"label": "A", "text": "Insertion sort"}, {"label": "B", "text": "Quicksort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Selection sort"}], "answerKey": "C", "model_answer": ""}
{"question": "A particular parallel program computation requires 100 seconds when executed on a single processor. If 40 percent of this computation is \"inherently sequential\" (i.e., will not benefit from additional processors), then the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are", "choices": [{"label": "A", "text": "20 and 10 seconds"}, {"label": "B", "text": "30 and 15 seconds"}, {"label": "C", "text": "50 and 25 seconds"}, {"label": "D", "text": "70 and 55 seconds"}], "answerKey": "D", "model_answer": "70 and 55 seconds\n\nExplanation:\nThe given information tells us that the computation requires 100 seconds when executed on a single processor, and 40 percent of it is inherently sequential. This means that the amount of parallelizable work in the computation is 60 percent, or 60 \\* 100 = 600 seconds.\nIf we run the computation on a single processor, it will take 100 seconds \\* 1 processor = 100 seconds.\nIf we run it on 2 processors, the best possible elapsed time would be 600 seconds / 2 processors = 300 seconds. This is equal to the elapsed time of running on a single processor, so the answer is (A) 20 and 10 seconds.\nIf we run it on 4 processors, the best possible elapsed time would be 600 seconds / 4 processors = 150 seconds"}
{"question": "Consider the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude. In which representation is there overflow from the addition of the integers 011000 and 011000?", "choices": [{"label": "A", "text": "Two's complement only"}, {"label": "B", "text": "Sign and magnitude and one's complement only"}, {"label": "C", "text": "Two's complement and one's complement only"}, {"label": "D", "text": "All three representations"}], "answerKey": "D", "model_answer": "complement only\nB. Sign and magnitude and one's complement only\nC. Two's complement and one's complement only\nD. All three representations\n\nThe correct answer is A. Two's complement only."}
{"question": "Of the following, which best characterizes computers that use memory-mapped I/O?", "choices": [{"label": "A", "text": "The computer provides special instructions for manipulating I/O ports."}, {"label": "B", "text": "I/O ports are placed at addresses on the bus and are accessed just like other memory locations."}, {"label": "C", "text": "To perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}, {"label": "D", "text": "Ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}], "answerKey": "B", "model_answer": ": The correct answer is (B) I/O ports are placed at addresses on the bus and are accessed just like other memory locations. \n\nA computer that uses memory-mapped I/O is a type of computer architecture where I/O devices are attached to the computer bus, and I/O operations are performed by placing data in an address register and calling the channel to perform the operation. This type of architecture allows the computer to access I/O devices as if they were memory locations, which simplifies the programming process and allows for easy sharing of memory between the I/O device and the main memory. This is in contrast to I/O-mapped systems, where I/O operations are performed by using special instructions to access the I/O device directly, and dedicated hardware is used to control the flow of data between the I/O device and the CPU."}
{"question": "Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that", "choices": [{"label": "A", "text": "integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs"}, {"label": "B", "text": "P = NP"}, {"label": "C", "text": "even if P = NP, integer factorization is still likely not to be polynomial-time computable"}, {"label": "D", "text": "testing primality is computationally intractable"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following sets of bit strings CANNOT be described with a regular expression?", "choices": [{"label": "A", "text": "All bit strings whose number of zeros is a multiple of five"}, {"label": "B", "text": "All bit strings starting with a zero and ending with a one"}, {"label": "C", "text": "All bit strings with an even number of zeros"}, {"label": "D", "text": "All bit strings with more ones than zeros"}], "answerKey": "D", "model_answer": "The correct answer is (D) All bit strings with more ones than zeros.\n\nA regular expression is a sequence of characters that defines a search pattern. It can be used to match specific patterns of characters in a string. However, not all bit strings can be described with a regular expression. Here are some examples of bit strings that cannot be described with a regular expression:\n1. A bit string that has an uneven number of zeros and ones.\n2. A bit string that starts with a one and ends with a one.\n3. A bit string that has the same pattern of zeros and ones repeated over and over again.\n4. A bit string that is made up of only zeroes or only ones.\nThese bit strings cannot be described with a regular expression because they do not follow the pattern specified by the regular expression."}
{"question": "Which of the following conditions can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac)?\nI. At least three of p_1, p_2, p_3, p_4 are true.\nII. Exactly three of p_1, p_2, p_3, p_4 are true.\nIII. An even number of p_1, p_2, p_3, p_4 are true.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "The correct answer is (D) I and III.\n\nA Boolean formula with the variables p\\_1, p\\_2, p\\_3, p\\_4 and the connectives \u2227, \u2228 (without \u00ac) can be used to express the conditions in the question. The formula should have three disjunctive clauses, representing conditions I and III.\nHere is one possible Boolean formula that satisfies the conditions:\n(p\\_1 \u2227 p\\_3 \u2227 \u00acp\\_2 \u2227 \u00acp\\_4) \u2228\n(\u00acp\\_1 \u2227 p\\_2 \u2227 p\\_4 \u2227 \u00acp\\_3) \u2228\n(p\\_1 \u2227 p\\_2 \u2227 p\\_3 \u2227 \u00acp\\_4)\nThis formula has three disjunctive clauses, and each clause corresponds to one of the conditions mentioned in the question. The first clause (p\\_1 \u2227 p\\_3 \u2227 \u00acp\\_2 \u2227 \u00acp\\_4) means that at least three of the variables are true, which satisfies condition I. The second clause (\u00acp\\_1 \u2227 p\\_2 \u2227 p\\_4 \u2227 \u00acp\\_3) means that exactly three of the variables are true, which satisfies condition II. And the third clause (p\\_1 \u2227 p\\_2 \u2227 p\\_3 \u2227 \u00acp\\_4) means that an even number of the variables are true, which satisfies condition III.\nTherefore, the correct answer is (D) I and III, as both conditions can be expressed by the Boolean formula in the question."}
{"question": "Two alternatives for interconnecting a set of processors with bidirectional links are (1) the fully interconnected network, in which each processor is directly connected to every other processor, and (2) the ring network, in which each processor is connected to two other processors. The worst-case path length for a network is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes. For each type of interconnection of n processors, a figure of merit can be formed as the product of the number of links required for the network times the worst-case path length connecting any two processors. The ratio of this figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is", "choices": [{"label": "A", "text": "1/(n^2)"}, {"label": "B", "text": "1/(n(n-1))"}, {"label": "C", "text": "1/n"}, {"label": "D", "text": "(n-1)/n"}], "answerKey": "D", "model_answer": "/n.\n\nThe figure of merit is the product of the number of links required for the network times the worst-case path length connecting any two processors. For the fully interconnected network, the worst-case path length is (n-1)/n, and the number of links is n. Thus, the figure of merit is n \\* (n-1)/n = (n-1)/n.\nFor the ring network, the worst-case path length is (n-1)/2, and the number of links is 2n - 2. Thus, the figure of merit is 2n - 2 \\* (n-1)/2 = (n-1)/n.\n\nTherefore, the answer is (D) (n-1)/n."}
{"question": "For a connected, undirected graph G = (V, E), which of the following must be true?\nI. \u03a3_{v\u2208V} degree(v) is even.\nII. |E| \u2265 |V| \u2212 1\nIII. G has at least one vertex with degree 1.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "n\n        I. \u03a3_{v\u2208V} degree(v) is even.\n        II. |E| \u2265 |V| \u2212 1\n        III. G has at least one vertex with degree 1.\n        D. I and II\n```"}
{"question": "In multiprogrammed systems it is advantageous if some programs such as editors and compilers can be shared by several users. Which of the following must be true of multiprogrammed systems in order that a single copy of a program can be shared by several users?\nI. The program is a macro.\nII. The program is recursive.\nIII. The program is reentrant.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following decimal numbers has an exact representation in binary notation?", "choices": [{"label": "A", "text": "0.1"}, {"label": "B", "text": "0.2"}, {"label": "C", "text": "0.3"}, {"label": "D", "text": "0.5"}], "answerKey": "D", "model_answer": "The decimal number that has an exact representation in binary notation is (D) 0.5.\n\nIn binary notation, a fraction with a decimal value of 0.5 can be represented as follows:\n0.5 = 1/2\n\nThe representation of 0.1, 0.2, and 0.3 in binary notation is (A), (B), and (C), respectively:\n0.1 = 0.01\n0.2 = 0.0101\n0.3 = 0.00101\n\nHowever, 0.5 has an exact representation in binary notation as 1/2, which cannot be represented as a binary fraction with a decimal value less than 0.5."}
{"question": "Function signatures describe the types of the arguments to a function as well as the return value of the function. For instance, the addition function on reals has a signature of\nadd : real x real -> real\nsince it takes two real numbers and returns a real number. But, for a language that allows functions as return values, addition could be considered to have the signature\nadd : real -> (real -> real)\nwhich means that add takes a single real (the first operand) and returns a new function that itself takes a single real (the second operand) and returns a real (the result). This process of reducing a function with multiple arguments to a function with fewer arguments is called currying. Which of the following is correct?", "choices": [{"label": "A", "text": "Currying can be applied to any function to the point where it has exactly one input argument."}, {"label": "B", "text": "Currying cannot be applied to functions of more than two arguments."}, {"label": "C", "text": "Currying cannot be applied to functions that return functions as arguments."}, {"label": "D", "text": "Currying cannot be applied w functions that haw arguments that are functions."}], "answerKey": "A", "model_answer": "A) Currying can be applied to any function to the point where it has exactly one input argument."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-back policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2000"}], "answerKey": "A", "model_answer": "000\n\nThe physical address of the first element in Array A is 4096, and the physical address of the first element in Array B is 8192. The loop writes the value of each element in Array B to the corresponding element in Array A, shifting the elements in Array A to the right by 1. Since each element in Array A is 4 bytes, the loop writes 512 \\* 4 = 2048 bytes to memory. Since the cache has an 8-byte block size, the loop writes 2048 / 8 = 256 bytes to memory per iteration. The loop runs 256 times, so the total number of bytes written to memory is 256 \\* 256 = 65,536 bytes. Therefore, the answer is (D) 2000."}
{"question": "In which of the following representations of numbers by 8-bit words is the addition of the integers 109 and -42 within range?\nI. One's complement\nII. Two's complement\nIII. Sign and magnitude", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "The correct answer is (D) I, II, and III. All three representations are able to represent the sum of 109 and -42 within the 8-bit word.\n\nThe three representations are:\n\nI. One's complement: Add 109 and -42, we get 105. The one's complement of 105 is 01101, which is the same as the two's complement.\nII. Two's complement: Add 109 and -42, we get 105. The two's complement of 105 is 10100, which can be represented as the sign and magnitude format (10100100).\nIII. Sign and magnitude: The decimal representation of 109 + -42 is 105. We can represent this as the sign bit of 1 and the magnitude of 01001 (in binary)."}
{"question": "If a malicious process is granted temporary administrator-level access to a system", "choices": [{"label": "A", "text": "the threat is over as soon as the process is killed"}, {"label": "B", "text": "the threat is over after the operating system is rebooted"}, {"label": "C", "text": "the thread is over after rebooting the machine and replacing files that show a virus infection"}, {"label": "D", "text": "the threat is often permanent until the entire disk is wiped clean"}], "answerKey": "D", "model_answer": "The correct answer is (B) the threat is over after the operating system is rebooted.\n\nWhen a malicious process is granted temporary administrator-level access to a system, it can potentially cause a lot of damage, such as installing additional malware, modifying system files, or stealing sensitive data. If the process is killed, it should no longer be able to cause any further damage. However, it is still a good idea to reboot the system to ensure that no other malicious processes have been installed and to restore the system to its original state.\n\nOption (A) is incorrect because the threat is not necessarily over just because the process is killed.\n\nOption (C) is incorrect because replacing affected files does not necessarily remove the malware infection or restore the system to its original state.\n\nOption (D) is incorrect because wiping the entire disk is a drastic measure that should be avoided unless necessary, as it will result in the loss of all data on the system."}
{"question": "Which of the following statements about horizontal versus vertical microarchitecture is (are) true?\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nII. Horizontal microinstructions are unencoded.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "nly.\n\nHorizontal microinstructions usually have a single opcode and multiple operand specifiers, which allows for more flexibility in addressing operands.\n\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nThis statement is not universally true, as it depends on the specific design of the architecture and the algorithms being executed.\n\nII. Horizontal microinstructions are unencoded.\nThis statement is not true.\nHorizontal microinstructions are typically encoded as bitpatterns, which are decoded into specific microinstructions during the decoding phase.\n\nTherefore, the correct answer is (C) III only."}
{"question": "A \"strictly binary tree\" is a binary tree in which every node that is not a leaf has two children. Suppose that for a class of strictly binary trees there exists c > 0 such that, for any tree in the class, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. Which of the following best characterizes the height h of any tree in this class, where N is the number of nodes in the tree and N > 1 ?", "choices": [{"label": "A", "text": "h <= log2(N)"}, {"label": "B", "text": "h = 1/c * log2(N)"}, {"label": "C", "text": "h < c log2(N)"}, {"label": "D", "text": "h > c log2(N)"}], "answerKey": "C", "model_answer": "og2(N)\nB) h = 1/c * log2(N)\nC) h < c log2(N)\nD) h > c log2(N)\n\nThe correct answer is (B) h = 1/c * log2(N)."}
{"question": "Which of the following sorting algorithms has average-case and worst-case running times of O(n log n)?", "choices": [{"label": "A", "text": "Bubble sort"}, {"label": "B", "text": "Insertion sort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "C", "model_answer": "sort.\n\nQuicksort is a divide-and-conquer sorting algorithm with an average-case running time of O(n log n) and a worst-case running time of O(n^2). Bubble sort, Insertion sort, and Merge sort are all O(n^2) algorithms, while Bubble sort has a worst-case of O(n^2\\*"}
{"question": "Consider the following equations concerning a stack module that has the operations Push, Pop, Top, and IsEmpty. Which of the equations does NOT represent the conventional semantics of a stack?", "choices": [{"label": "A", "text": "IsEmpty(Push(Stack,Elem)) = true"}, {"label": "B", "text": "Pop(Push(Stack,Elem)) = Stack"}, {"label": "C", "text": "Top(Push(Stack,Elem)) = Elem"}, {"label": "D", "text": "IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false"}], "answerKey": "A", "model_answer": "The correct answer is (D) IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false.\n\nThe conventional semantics of a stack module is defined by the following equations:\n\n* Push(S,x) = S || [x]\n* Pop() = x\n* Top() = S\n* IsEmpty(S) = S = []\n\nEquation (D) is not one of the conventional semantics of a stack module. It defines the behavior of the IsEmpty function on a stack module that was created by calling the Push function twice on a stack that was previously empty. This equation is not consistent with the other equations that define the semantics of a stack module, which only involve the Push, Pop, and Top functions and the empty stack S."}
{"question": "Assume that any assignment statement can be executed in unit time. If as many identical processors as needed are used, what is the minimum number of time units needed to execute the assignments\nA := B + C\nB := A - B\nC := A * E\nD := A/F\nE := B - C\nF := A + B\nwith the same result as if the assignments were executed in the order shown?", "choices": [{"label": "A", "text": "1"}, {"label": "B", "text": "2"}, {"label": "C", "text": "3"}, {"label": "D", "text": "4"}], "answerKey": "C", "model_answer": "planation:\nThe given assignments can be executed in any order, and the result will be the same. Therefore, the minimum number of time units needed to execute the assignments is the maximum number of time units each assignment takes to execute, which is 4. Since each assignment can be executed in 1 time unit, the minimum number of time units needed is also 4. Therefore, the correct answer is (D) 4."}
{"question": "Two expressions E and F are said to be unifiable if there are substitutions for the variables of E and F that make the expressions lexically identical. In the following three expressions, only w, x, y, and z are variables.\nI. f(w,w)\nII. f(x,1)\nIII. f(y,g(z))\nWhich pairs of these expressions is (are) pairs of unifiable expressions?", "choices": [{"label": "A", "text": "(I, II) only"}, {"label": "B", "text": "(I, III) only"}, {"label": "C", "text": "(II, III) only"}, {"label": "D", "text": "(I, II) and (I, III) only"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following instruction-set features is NOT generally considered an obstacle to aggressive pipelining of an integer unit?", "choices": [{"label": "A", "text": "Condition codes set by every instruction"}, {"label": "B", "text": "Variable-length encoding of instructions"}, {"label": "C", "text": "Instructions requiring widely varying numbers of cycles to execute"}, {"label": "D", "text": "Several different classes (sets) of registers"}], "answerKey": "D", "model_answer": "(Human): The correct answer is (D) Several different classes (sets) of registers.\n\nAn aggressive pipelining of an integer unit can benefit from instruction-set features that allow for efficient and quick processing. Features such as variable-length encoding of instructions, condition codes set by every instruction, and instructions requiring widely varying numbers of cycles to execute are all advantageous for pipelining. However, having several different classes (sets) of registers can pose an obstacle to efficient pipelining, as it can lead to complex register renaming and stalling mechanisms, which can negatively impact performance."}
{"question": "Let k >= 2. Let L be the set of strings in {0, 1}^* such that x \\in L if and only if the number of 0's in x is divisible by k and the number of 1's in x is odd. The minimum number of states in a deterministic finite automaton (DFA) that recognizes L is", "choices": [{"label": "A", "text": "k + 2"}, {"label": "B", "text": "2k"}, {"label": "C", "text": "k log k"}, {"label": "D", "text": "k^2"}], "answerKey": "B", "model_answer": "n\nThe correct answer is (C) k log k.\n```\nExplanation: To recognize L, we need to check if the number of 0's is divisible by k and the number of 1's is odd. This can be done using a DFA with k states. The number of states in the DFA is k \\* log k, which is the minimum number of states required to recognize L.\n\nTherefore, the correct answer is (C) k log k."}
{"question": "Let G = (V, E) be a finite directed acyclic graph with |E| > 0. Which of the following must be true?\nI. G has a vertex with no incoming edge.\nII. G has a vertex with no outgoing edge.\nIII. G has an isolated vertex, that is, one with neither an incoming edge nor an outgoing edge.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "D", "model_answer": "n\n      I. G has a vertex with no incoming edge.\n     (D) I and II only.\n```\n\nThe correct answer is (D) I and II only."}
{"question": "Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v. Let (u, v) be an edge in G that is not in T, such that pre(u) < pre(v). Which of the following statements about u and v must be true?\nI. post(u) < post(v)\nII. u is an ancestor of v in T.\nIII. If w is the lowest common ancestor of u and v in T, then w = u.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "ll choose (D) II and III.\n\nReasoning:\nStatement II implies that u is not an ancestor of v in T, which means that (u, v) is not in T. This contradicts the assumption that (u, v) is a directed edge in G that is not in T. Therefore, Statement III must be false, and u cannot be the lowest common ancestor of u and v in T.\n\nSince u is not an ancestor of v in T, it follows that u is not an ancestor of v in the original graph G either. Therefore, Statement I must also be false, and post(u) cannot be less than post(v).\n\nTherefore, the correct answer is (D) II and III."}
{"question": "In systems with support for automatic memory management, a garbage collector typically has the responsibility for reclaiming allocated memory objects whose contents cannot affect any future legal computation. Such objects are identified by determining that they cannot be reached from a root set. Which of the following is NOT part of the root set in a typical garbage collector?", "choices": [{"label": "A", "text": "Actual parameters of the active procedures"}, {"label": "B", "text": "Dynamically allocated objects on the heap"}, {"label": "C", "text": "Global variables of the program"}, {"label": "D", "text": "Local variables on the call stack"}], "answerKey": "B", "model_answer": "variables on the call stack."}
{"question": "In the Internet Protocol (IP) suite of protocols, which of the following best describes the purpose of the Address Resolution Protocol?", "choices": [{"label": "A", "text": "To translate Web addresses to host names"}, {"label": "B", "text": "To determine the IP address of a given host name"}, {"label": "C", "text": "To determine the hardware address of a given host name"}, {"label": "D", "text": "To determine the hardware address of a given IP address"}], "answerKey": "D", "model_answer": "esolution Protocol (ARP) is responsible for mapping a host's IP address to its hardware address in the local network."}
{"question": "Which of the following language features requires that stack-based storage allocation be used rather than static allocation?", "choices": [{"label": "A", "text": "Recursive procedures"}, {"label": "B", "text": "Arbitrary goto's"}, {"label": "C", "text": "Two-dimensional arrays"}, {"label": "D", "text": "Integer-valued functions"}], "answerKey": "A", "model_answer": "sive procedures.\n\nRecursive procedures require stack-based storage allocation rather than static allocation, because each recursive call involves a stack frame that is stored on the stack until the function returns. The stack frame contains information about the current function call, such as local variables and the current value of the call stack."}
{"question": "Which of the following is not a sentence that is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z?", "choices": [{"label": "A", "text": "xyz"}, {"label": "B", "text": "xy"}, {"label": "C", "text": "xxzy"}, {"label": "D", "text": "xxxxy"}], "answerKey": "A", "model_answer": "The correct answer is (D) xxxxy.\n\nExplanation:\nThe given grammar generates sentences in the format \"x ABCDE\". Here is a breakdown of each choice:\n\n(A) xyz: This is not a sentence generated by the given grammar, as it does not follow the format of \"x ABCDE\".\n\n(B) xy: This is a valid sentence generated by the given grammar, as it follows the format of \"x ABCDE\".\n\n(C) xxzy: This is also a valid sentence generated by the given grammar, as it follows the format of \"x ABCDE\".\n\n(D) xxxxy: This is not a valid sentence generated by the given grammar, as it does not follow the format of \"x ABCDE\". It should be \"x ABCDE\" or \"xy ABCDE\", but not \"xxxxy ABCDE\"."}
{"question": "Let T (n) be defined by T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1. Which of the following represents the order of growth of T(n) as a function of n?", "choices": [{"label": "A", "text": "\u0398(n)"}, {"label": "B", "text": "\u0398(n log n)"}, {"label": "C", "text": "\u0398(n^2)"}, {"label": "D", "text": "\u0398(n^2 log n)"}], "answerKey": "C", "model_answer": "To determine the order of growth of T(n) as a function of n, we need to find the function value at n = infinity, i.e., T(\u221e).\n\nT(1) = 7 and T(2) = 3 \\* 2 + 7 = 21, so T(n + 1) = 3 \\* (n + 1) + T(n).\n\nWe can see that T(n) grows linearly with n, so T(n) = c \\* n for some constant c > 0.\n\nAt n = \u221e, we have T(\u221e) = 3 \\* \u221e + T(0) = 3 + T(0) = 3 + 0 = 3, so T(n) grows linearly with n.\n\nThus, the order of growth of T(n) is (D) \u0398(n^2 log n)."}
{"question": "Which of the following problems is (are) decidable?\nI. Given a (finite) string w, is w a prefix of the decimal expansion of \u03c0?\nII. Given a program and an input, is the program\u2019s output the decimal expansion of \u03c0?\nIII. Given a program that takes as input a prefix of the decimal expansion of \u03c0, is the program\u2019s output always the same for every prefix?", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "I and II only\nExplanation: Both problems I and II are undecidable. Problem I is undecidable because there is no algorithm that can determine whether a given string is a prefix of the decimal expansion of \u03c0. Problem II is undecidable because there is no algorithm that can determine whether a given program and input will produce the decimal expansion of \u03c0. However, problem III is decidable because there is an algorithm that can determine whether a given program and input will always produce the same output for every prefix of the decimal expansion of \u03c0. Therefore, the correct answer is (D) I and II only."}
{"question": "Which of the following statements about circuits is (are) true?\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nIII. Both sequential and combinational circuits must be controlled by an external clock.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "n\n        A) I only\n```\n\nExplain:\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nThis statement is false because both types of circuits can have memory.\nIII. Both sequential and combinational circuits must be controlled by an external clock.\nThis statement is true because both types of circuits require a clock signal to function."}
{"question": "Two single-user workstations are attached to the same local area network. On one of these workstations, file pages are accessed over the network from a file server; the average access time per page is 0.1 second. On the other of these workstations, file pages are accessed from a local disk; the average access time per page is 0.05 second. A particular compilation requires 30 seconds of computation and 200 file page accesses. What is the ratio of the total time required by this compilation if run on the diskless (file server) workstation to the total time required if run on the workstation with the local disk, if it is assumed that computation is not overlapped with file access?", "choices": [{"label": "A", "text": "1/1"}, {"label": "B", "text": "5/4"}, {"label": "C", "text": "5/3"}, {"label": "D", "text": "10/5"}], "answerKey": "B", "model_answer": "1/1\nExplanation: The time required to complete the compilation can be broken down into two parts: the time required for computation and the time required for file page access.\nIf we assume that computation is not overlapped with file access, then the total time required for the compilation is the sum of the time required for computation and the time required for file page access.\n\nOn the diskless (file server) workstation, the time required for file page access is 0.1 second per page access, for a total of 200 page accesses, or 200 \\* 0.1 = 20 seconds.\nOn the workstation with the local disk, the time required for file page access is 0.05 second per page access, for a total of 200 page accesses, or 200 \\* 0.05 = 10 seconds.\nThe ratio of the total time required for file page access on the diskless workstation to the total time required for file page access on the workstation with the local disk is 200/10, which simplifies to a ratio of 20:1.\nTherefore, the total time required for the compilation is the same on both workstations, and the ratio of the total time required on the diskless workstation to the total time required on the workstation with the local disk is 1:1.\n\nThus, the correct answer is (A) 1/1."}
{"question": "Assume that a debugger places a breakpoint at a load instruction at virtual address 0x77E81234 (hexadecimal notation) in a debugged process P. If the text segment of P begins at 0x77E80000 in P\u2019s virtual address space and if the debugger has mapped this same text segment at 0x01000000 in its virtual address space, which of the following is the virtual address used by the debugger in its WRITE operation, along with a description of how the debugger has mapped the virtual memory page containing this address?", "choices": [{"label": "A", "text": "0x01001234; page mapped with READ/WRITE access"}, {"label": "B", "text": "0x01001234; page mapped with COPY-ON-WRITE access"}, {"label": "C", "text": "0x76E81234; page mapped with READ/WRITE access"}, {"label": "D", "text": "0x76E81234; page mapped with COPY-ON-WRITE access"}], "answerKey": "A", "model_answer": "Answer: (C) 0x76E81234; page mapped with READ/WRITE access.\n\nExplanation:\nThe debugger has mapped the text segment of the process P at 0x01000000 in its virtual address space. The breakpoint has been set at a load instruction in virtual address 0x77E81234 in the process P's virtual address space.\n\nAssuming the debugged process P is a 32-bit process, the virtual address 0x76E81234 corresponds to the physical address 0x77E81234 \\* 2^(32-12) + 0x00001234, where 12 is the offset corresponding to the page size (4KB).\n\nSince the debugger has mapped the same text segment at 0x01000000 in its virtual address space, it has also mapped the page containing the virtual address 0x76E81234 in its physical address space. Therefore, the debugger has mapped the virtual memory page containing the virtual address 0x76E81234 with read/write access."}
{"question": "Which of the following considerations applies (apply) to choosing the page size in a paging system?\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": ": The correct answer is (D) I, II, and III.\n\nExplanation: The choice of page size in a paging system is a trade-off between various factors, including disk access time, page table size, and internal fragmentation.\n\nI. An advantage of larger pages is that they lead to smaller page tables. This is true, as larger pages require fewer page table entries to represent the same number of pages. However, larger pages also lead to longer page tables, which can increase cache thrashing and increase page faults.\n\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation. This is also true, as smaller pages require less memory to represent the same number of pages, and less internal fragmentation means fewer wasted memory pages. However, smaller pages also lead to larger page tables, which can increase cache thrashing and increase page faults.\n\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously. This is false. The page length does affect disk access time, as longer pages result in more disk head movement and increased disk seek time.\n\nTherefore, a combination of all three considerations is necessary to choose the page size in a paging system. A larger page size can lead to smaller page tables and less internal fragmentation, while a smaller page size can lead to less wasted memory and fewer page table entries. The optimal page size depends on the specific system architecture and the trade-offs between different factors."}
{"question": "Two processors, M-5 and M-7, implement the same instruction set. Processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. Processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds. Which of the following is (are) true?\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline.\nII. The latency of a single instruction is shorter on M-7\u2019s pipeline than on M-5\u2019s pipeline.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III"}, {"label": "D", "text": "II and III"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following pairs of 8-bit, two's-complement numbers will result in overflow when the members of the pairs are added?", "choices": [{"label": "A", "text": "11111111, 00000001"}, {"label": "B", "text": "00000001, 10000000"}, {"label": "C", "text": "11111111, 10000001"}, {"label": "D", "text": "10000001, 10101010"}], "answerKey": "D", "model_answer": ""}
{"question": "Two computers communicate with each other by sending data packets across a local area network. The size of these packets is 1,000 bytes. The network has the capacity to carry 1,000 packets per second. The CPU time required to execute the network protocol to send one packet is 10 milliseconds. The maximum rate at which one computer can send data to another is approximately", "choices": [{"label": "A", "text": "10,000 bytes/second"}, {"label": "B", "text": "25,000 bytes/ second"}, {"label": "C", "text": "100,000 bytes/ second"}, {"label": "D", "text": "500,000 bytes/ second"}], "answerKey": "C", "model_answer": "0 bytes/second\n(B) 25,000 bytes/second\n(C) 100,000 bytes/second\n(D) 500,000 bytes/second"}
{"question": "Consider the following grammar.\nS \u2192 ( S )\nS \u2192 x\nWhich of the following statements is (are) true?\nI. The grammar is ambiguous.\nII. The grammar is suitable for top-down parsing.\nIII. The grammar is suitable for bottom-up parsing.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "n\nThe correct answer is (D) II and III only.\n```"}
{"question": "Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT:", "choices": [{"label": "A", "text": "Counting distinct values: Given a set of n keys, determine the number of distinct key values."}, {"label": "B", "text": "Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary."}, {"label": "C", "text": "Range search: Given values a and b, find all the records whose key value is in the range a, b."}, {"label": "D", "text": "Symbol table lookup: Given a program identifier, find its type and address."}], "answerKey": "C", "model_answer": "correct answer is (B) Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary. Hash tables are a type of data structure that can be used to implement dynamic dictionaries, which support the operations of insert, delete, and search in a dictionary. This is in contrast to other data structures, such as arrays or linked lists, which may not be as efficient for these operations."}
{"question": "Let A be a finite set with m elements, and let B be a finite set with n elements. The number of distinct functions mapping A into B is", "choices": [{"label": "A", "text": "n^m"}, {"label": "B", "text": "n!/(n - m)!"}, {"label": "C", "text": "n!"}, {"label": "D", "text": "n!/(m!(n - m)!)"}], "answerKey": "A", "model_answer": "The correct answer is (D) n!/(m!(n - m)!).\n\nThis is because the number of distinct functions from A to B is equal to the number of ways to choose a function from A to B, which is given by n!/(n - m)!, and then for each of those functions, we can choose which elements of A to send to which element of B, which gives us m!/(m - n)! choices for the mapping of A onto B. Therefore, the total number of distinct functions from A to B is n!/(m!(n - m)!)"}
{"question": "To compute the matrix product M_1M_2, where M_1 has p rows and q columns and where M_2 has q rows and r columns, takes time proportional to pqr, and the result is a matrix of p rows and r columns. Consider the product of three matrices N_1N_2N_3 that have, respectively, w rows and x columns, x rows and y columns, and y rows and z columns. Under what condition will it take less time to compute the product as (N_1N_2)N_3 (i.e., multiply the first two matrices first) than to compute it as N_1(N_2 N_3)?", "choices": [{"label": "A", "text": "There is no such condition; i.e., they will always take the same time."}, {"label": "B", "text": "1/x + 1/z < 1/w + 1/y"}, {"label": "C", "text": "x > y"}, {"label": "D", "text": "1/w + 1/x < 1/y + 1/z"}], "answerKey": "B", "model_answer": ""}
{"question": "The hit ratio of a cache memory is the percentage of accesses (reads and writes) for which data are found in the cache. Write-through is a policy whereby every write operation updates main memory. Write-back is a policy whereby a write operation to a line found in the cache does not affect main memory until the line is evicted from the cache. Write-allocation is a policy whereby a cache line is allocated and loaded on a write-miss. If it is assumed that write-allocation is always used, which of the following is true?", "choices": [{"label": "A", "text": "Write-back usually results in a better hit ratio than write-through."}, {"label": "B", "text": "Write-through usually results in a better hit ratio than write-back."}, {"label": "C", "text": "The percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through."}, {"label": "D", "text": "The percentage of write operations resulting in a main memory operation will never be larger for writethrough than for write-back."}], "answerKey": "C", "model_answer": ""}
{"question": "A particular disk unit uses a bit string to record the occupancy or vacancy of its tracks, with O denoting vacant and 1 denoting occupied. A 32-bit segment of this string has the hexadecimal value D4FE2003. The percentage of occupied tracks for the corresponding part of the disk, to the nearest percent, is", "choices": [{"label": "A", "text": "12%"}, {"label": "B", "text": "25%"}, {"label": "C", "text": "38%"}, {"label": "D", "text": "44%"}], "answerKey": "D", "model_answer": "The correct answer is (D) 44%.\n\nTo find the percentage of occupied tracks, we need to divide the number of occupied tracks by the total number of tracks and multiply by 100%. We are given that there are 10 occupied tracks out of 20 tracks, so:\n20 - 10 = 10\n10 \\* 100% = 10%\nTherefore, the percentage of occupied tracks is 10%. However, the answer choice (A) 12% is not correct because it is less than the given percentage. The answer choice (B) 25% is also incorrect because it is greater than the given percentage. The answer choice (C) 38% is not correct because it is still less than 44%. The answer choice (D) 44% is correct because it is exactly the percentage of occupied tracks."}
{"question": "An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. Which of the following undirected graphs must have an Euler circuit?\nI. A complete graph with 12 vertices\nII. A complete graph with 13 vertices\nIII. A tree with 13 vertices", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "B", "model_answer": "n\n      A) I only\n```\n\n```markdown\n      B) II only\n```\n\n```markdown\n      C) III only\n```\n\n```markdown\n      D) I and II\n```\n\nAnswer: D) I and II\nExplanation: An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. A complete graph is a graph in which every vertex is connected to every other vertex. Therefore, a complete graph must have an Euler circuit if and only if it is connected.\n\nFor option I, a complete graph with 12 vertices must have an Euler circuit since it is connected. However, for option II, a complete graph with 13 vertices is not necessarily connected, so it may or may not have an Euler circuit. For option III, a tree with 13 vertices may or may not be connected, so it may or may not have an Euler circuit.\n\nTherefore, the correct answer is D) I and II."}
{"question": "Which of the following characteristics of a programming language is best specified using a context-free grammar?", "choices": [{"label": "A", "text": "Identifier length"}, {"label": "B", "text": "Maximum level of nesting"}, {"label": "C", "text": "Operator precedence"}, {"label": "D", "text": "Type compatibility"}], "answerKey": "C", "model_answer": "compatibility\n\nA programming language can have different types of data, such as integers, floating-point numbers, and characters. The type compatibility rule specifies how these types can be used together in a program. It defines the rules for assigning values to variables, passing arguments to functions, and returning values from functions. The type compatibility rule is best specified using a context-free grammar."}
{"question": "Which of the following statements about datagrams sent by a node in a network using IPv4 protocol is (are) true?\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nIII. Datagrams are reassembled only at the destination.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "The correct answer is (D) II and III.\nExplanation:\n\n* Datagrams may be fragmented during routing: This means that a datagram can be divided into smaller fragments during transmission to accommodate intermediate network devices with smaller MTUs.\n* Datagrams are reassembled only at the destination: This means that the receiving node must reassemble the fragmented datagrams before it can read the entire message.\n\nSo, statement II is true and statement I is not necessarily true. Statement III is false, as datagrams are reassembled at the destination, not just at the source."}
{"question": "A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. Which of the following job-scheduling policies is starvation-free?", "choices": [{"label": "A", "text": "Round-robin"}, {"label": "B", "text": "Priority queuing"}, {"label": "C", "text": "Shortest job first"}, {"label": "D", "text": "Youngest job first"}], "answerKey": "A", "model_answer": "> The correct answer is (C) Shortest job first.\n\nShortest job first (SJF) is a job-scheduling policy that selects jobs based on their length, scheduling the longest jobs first and the shortest jobs last. This policy aims to minimize the average waiting time for all jobs by scheduling shorter jobs sooner and allowing longer jobs to wait. Shortest job first is starvation-free because it ensures that all jobs are eventually served, but it does not allow any job to wait indefinitely for service.\n\nRound-robin is not starvation-free because it schedules jobs in a cyclic order, and if a job is small enough, it can be preemptively killed before it completes. Priority queuing is also not starvation-free because it allows priority jobs to jump the queue, which can lead to starvation. Youngest job first is not starvation-free because it schedules the youngest job in the queue first, which can lead to older jobs waiting indefinitely if there are no jobs with a younger timestamp.\n\nTherefore, the only starvation-free job-scheduling policy among the given choices is (C) Shortest job first."}
{"question": "Of the following, which gives the best upper bound for the value of f(N) where f is a solution to the recurrence f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0?", "choices": [{"label": "A", "text": "O(log N)"}, {"label": "B", "text": "O(N log N)"}, {"label": "C", "text": "O(log N) + 0(1)"}, {"label": "D", "text": "O((log N)^2)"}], "answerKey": "D", "model_answer": ""}
{"question": "Company X shipped 5 computer chips, 1 of which was defective, and Company Y shipped 4 computer chips, 2 of which were defective. One computer chip is to be chosen uniformly at random from the 9 chips shipped by the companies. If the chosen chip is found to be defective, what is the probability that the chip came from Company Y?", "choices": [{"label": "A", "text": "2 / 9"}, {"label": "B", "text": "4 / 9"}, {"label": "C", "text": "1 / 2"}, {"label": "D", "text": "2 / 3"}], "answerKey": "D", "model_answer": "(B) 4 / 9\n\n(C) 1 / 2\n\n(D) 2 / 3\n\nThe correct answer is (C) 1 / 2.\n\nTo see why, we can use the formula for conditional probability:\nP(Y | defective) = P(defective chip from Company Y) / P(defective chip)\nP(Y | non-defective) = P(non-defective chip from Company Y) / P(non-defective chip)\nP(defective) = 2/9\nP(non-defective) = 4/9\nP(Y) = P(Y | non-defective) \\* P(non-defective) + P(Y | defective) \\* P(defective)\n= (4/9) \\* 4/9 + (1/9) \\* 2/9\n= 16/9 + 2/9\n= 18/9\nP(defective | Y) = P(defective chip from Company Y) / P(defective chip)\n= (1/2) / (2/9)\n= 1/1\n= 1\nP(non-defective | Y) = P(non-defective chip from Company Y) / P(non-defective chip)\n= (4/9) / (4/9)\n= 1"}
{"question": "Which of the following problems can be solved by a standard greedy algorithm?\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights\nII. Finding a maximum clique in an undirected graph\nIII. Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "The correct answer is (D) I and II only.\n\nA greedy algorithm is a simple algorithm that makes the locally optimal choice at each step with the hope of finding a global optimum. However, it may not always guarantee the global optimum.\n\nFor the first problem, finding a minimum spanning tree in an undirected graph with positive-integer edge weights, a greedy algorithm can be used. The algorithm starts by adding the edge with the smallest weight that connects two previously unconnected nodes. The process is repeated until all nodes are connected, forming a tree. This algorithm can find a minimum spanning tree, but it may not always be the optimal solution.\n\nFor the second problem, finding a maximum clique in an undirected graph, a greedy algorithm can be used as well. The algorithm starts by selecting the node with the largest degree and adding it to the clique. The process is repeated until all nodes are in the clique. This algorithm can find a maximum clique, but it may not always be the optimal solution.\n\nFor the third problem, finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities, a greedy algorithm cannot be used directly. Maximum flow can be found using algorithms like the Ford-Fulkerson algorithm or the Edmonds-Karp algorithm, which are not greedy algorithms but are guaranteed to find the optimal solution."}
{"question": "A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined. Which of the following is (are) correct?\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "correct answer is (D) II and III only.\nThe hash table size should increase with the document size to accommodate more entries. This is because the size of the hash table will determine the number of entries that can be stored, and the number of entries that need to be stored will depend on the size of the document. Therefore, increasing the hash table size with the document size is necessary to ensure that all words in the document can be checked for spelling.\nI and II are not correct. True means that the word was in the dictionary, and false means that the word was not in the dictionary. However, whether a word was in the dictionary or not does not affect the size of the hash table. The size of the hash table only affects the number of entries that can be stored.\nOption (C) I and II only is also not correct. Both I and II are necessary for the program to work correctly. I is necessary to determine whether the word was in the dictionary or not, and II is necessary to ensure that the hash table can store all the entries needed to check the spelling of the document."}
{"question": "One approach to handling fuzzy logic data might be to design a computer using ternary (base-3) logic so that data could be stored as \u201ctrue,\u201d \u201cfalse,\u201d and \u201cunknown.\u201d If each ternary logic element is called a flit, how many flits are required to represent at least 256 different values?", "choices": [{"label": "A", "text": "4"}, {"label": "B", "text": "5"}, {"label": "C", "text": "6"}, {"label": "D", "text": "7"}], "answerKey": "C", "model_answer": "6\nExplanation: To represent at least 256 different values, we need to be able to represent all 8 bits of a binary number (0-255), which requires 2^8 = 256 different values. Each ternary logic element (flit) can represent two binary digits (bits), so we need 2^5 (which is 32) flits to represent all 256 different values. Since we can't represent 0 in ternary logic, we need one more flit to represent the additional value of 1 in binary. Therefore, we need 33 flits to represent at least 256 different values."}
{"question": "Local caching of files is common in distributed file systems, but it has the disadvantage that", "choices": [{"label": "A", "text": "Temporary inconsistencies among views of a file by different machines can result"}, {"label": "B", "text": "The file system is likely to be corrupted when a computer crashes"}, {"label": "C", "text": "A much higher amount of network traffic results"}, {"label": "D", "text": "Caching makes file migration impossible"}], "answerKey": "A", "model_answer": "e correct answer is (A) Temporary inconsistencies among views of a file by different machines can result.\n\nExplanation:\nCaching is a technique used in distributed file systems to store frequently accessed files locally on machines closer to the users who access them, in an effort to speed up access times. While caching has some advantages, such as improved performance and lower network traffic, it also has some disadvantages. One of the disadvantages is that it can lead to temporary inconsistencies among views of a file by different machines, as each machine might have its own cached version of the file that may be out of date or incomplete. This can result in errors or unexpected behavior when users try to access or modify the file."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-through policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2048"}], "answerKey": "C", "model_answer": "rect answer is (D) 2048.\n\nExplanation:\nThe cache has a write-through policy, which means that any changes made to the cache will be immediately written to the main memory. In this case, the loop is adding the elements of array B to the elements of array A, which means that the cache will be filled with the contents of array B. Since the cache can hold 512 elements of 4 bytes each, and the loop is executing 256 iterations, the cache will be filled with 512 \\* 256 = 128,256 bytes of data.\nSince the first 2K bytes of memory are cached, the cache will be filled with the first 2K \\* 256 = 512 bytes of data from array B, which will be immediately written to the main memory. Therefore, 128,256 - 512 = 128,204 bytes will be written to main memory."}
{"question": "At time 0, five jobs are available for execution on a single processor, with service times of 25, 15, 5, 3, and 2 time units. Which of the following is the minimum value of the average completion time of these jobs?", "choices": [{"label": "A", "text": "50"}, {"label": "B", "text": "208/5"}, {"label": "C", "text": "92/5"}, {"label": "D", "text": "10"}], "answerKey": "C", "model_answer": "ge completion time of these jobs is calculated as follows:\n\n(25 + 15 + 5 + 3 + 2) / 5 = 38 / 5 = 7.6\n\nTherefore, the minimum value of the average completion time of these jobs is 7.6 time units."}
{"question": "Let G = (V, E) be a connected, undirected graph, and let a and b be two distinct vertices in V. Let P_1 be the problem of finding a shortest simple path between a and b, and let P_2 be the problem of finding a longest simple path between a and b. Which of the following statements about P_1 and P_2 is true?", "choices": [{"label": "A", "text": "Both P_1 and P_2 can be solved in polynomial time."}, {"label": "B", "text": "P_1 can be solved in polynomial time but P_2 is not known to be solvable in polynomial time."}, {"label": "C", "text": "P_1 is not known to be solvable in polynomial time but P_2 can be solved in polynomial time."}, {"label": "D", "text": "It is not known whether either P_1 or P_2 can be solved in polynomial time."}], "answerKey": "B", "model_answer": "in:  The shortest path problem and the longest path problem are two fundamental problems in computer science and graph theory that deal with finding the shortest or longest path between two vertices in a graph. The shortest path problem (P\\_1) is concerned with finding the shortest path between two vertices, while the longest path problem (P\\_2) is concerned with finding the longest path between two vertices.\n\nThe polynomial time complexity of an algorithm refers to the amount of time it takes to solve a problem given a specific input size. In this case, we are asked about the complexity of the algorithms that solve P\\_1 and P\\_2.\n\nChoice (A) states that both P\\_1 and P\\_2 can be solved in polynomial time, meaning that a solution exists that can be found in a polynomial number of steps for any size of input. This is a desirable property for algorithms, as it means they can solve the problem efficiently and accurately.\n\nChoice (B) states that P\\_1 can be solved in polynomial time but P\\_2 is not known to be solvable in polynomial time. This means that an algorithm exists for P\\_1, but the problem of finding a longest path between two vertices (P\\_2) is not known to have a polynomial time solution for all input sizes.\n\nChoice (C) states that P\\_1 is not known to be solvable in polynomial time but P\\_2 can be solved in"}
{"question": "A major advantage of direct mapping of a cache is its simplicity. The main disadvantage of this organization is that", "choices": [{"label": "A", "text": "it does not allow simultaneous access to the intended data and its tag"}, {"label": "B", "text": "it is more expensive than other types of cache organizations"}, {"label": "C", "text": "the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache"}, {"label": "D", "text": "its access time is greater than that of other cache organizations"}], "answerKey": "C", "model_answer": "s not allow simultaneous access to the intended data and its tag\n\nB) it is more expensive than other types of cache organizations\n\nC) the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache\n\nD) its access time is greater than that of other cache organizations"}
{"question": "Let M be a single-tape, deterministic Turing machine with tape alphabet {blank,0,1}, and let C denote the (possibly infinite) computation of M starting with a blank tape. The input to each problem below is M, together with a positive integer n. Which of the following problems is (are) decidable?\nI. The computation C lasts for at least n steps.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nIII. M scans at least n distinct tape squares during the computation C.", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "D", "model_answer": ". III only\nC. I and II only\nD. I and III only\n\nThe problem I. is undecidable, since M can make an infinite loop and avoid the problem. The problem II. is undecidable too, since M can make an infinite loop and avoid the problem. The problem III is undecidable too, since M can avoid the problem by making an infinite loop.\n\nSo, the correct answer is (B) III only."}
{"question": "A 3-way, set-associative cache is", "choices": [{"label": "A", "text": "one in which each main memory word can be stored at any of 3 cache locations"}, {"label": "B", "text": "effective only if 3 or fewer processes are running alternately on the processor"}, {"label": "C", "text": "possible only with write-back"}, {"label": "D", "text": "faster to access than a direct-mapped cache"}], "answerKey": "A", "model_answer": "The correct answer is (A) one in which each main memory word can be stored at any of 3 cache locations.\n\nA 3-way, set-associative cache is a type of cache memory organization that enables each memory word to be stored in one of three cache locations. The cache is divided into three sets, and each set contains a subset of the memory words. When a memory word is accessed, the cache compares the address of the word to the addresses of the words stored in each of the three sets. The set that contains the word is determined, and the word is retrieved from that set.\n\nOption (A) accurately describes the basic functioning of a 3-way, set-associative cache. Option (B) suggests that the cache is only effective when fewer than 3 processes are running simultaneously, which is not the case. Option (C) refers to write-back caches, which differ from set-associative caches in that write-back caches write the data back to main memory when they evict a word. Option (D) suggests that 3-way, set-associative caches are faster to access than direct-mapped caches, which is not necessarily the case."}
{"question": "Consider an object-oriented language in which all entities are objects. Two relationships arise: (1) the instance relationship, between an object and the class of which that object is a member, and (2) the subclass relationship, between a class and the superclass from which that class inherits properties. In such a language, when a message is sent to an object requesting execution of one of its methods (procedures), the method is located by following", "choices": [{"label": "A", "text": "one instance link and then zero or more subclass links"}, {"label": "B", "text": "one or more instance links and then one or more subclass links"}, {"label": "C", "text": "one or more instance links"}, {"label": "D", "text": "one subclass link and then one or more instance links"}], "answerKey": "A", "model_answer": "stance link and then zero or more subclass links\n\nB: One or more instance links and then one or more subclass links\n\nC: One or more instance links\n\nD: One subclass link and then one or more instance links\n\nExplanation:\nThe correct answer is (A) one instance link and then zero or more subclass links. This is because when a message is sent to an object requesting execution of one of its methods, the method is located by following the instance link (the relationship between the object and the class of which that object is a member) and then zero or more subclass links (the relationship between a class and the superclass from which that class inherits properties).\n\nThe other options are not correct because they do not accurately describe the process of locating a method in object-oriented programming:\n\n(B) One or more instance links and then one or more subclass links is incorrect because it suggests that there could be multiple instances and subclass links, which is not the case.\n\n(C) One or more instance links is incorrect because it only describes the relationship between an object and the class of which that object is a member, without specifying the order in which the links should be followed.\n\n(D) One subclass link and then one or more instance links is incorrect because it suggests that the subclass link should be followed before the instance link, which is not the case."}
{"question": "In a pipelined RISC computer where all arithmetic instructions have the same CPI (cycles per instruction), which of the following actions would improve the execution time of a typical program?\nI. Increasing the clock cycle rate\nII. Disallowing any forwarding in the pipeline\nIII. Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "D", "model_answer": "B. II only\nC. III only\nD. I and III\n\nExplain the answer."}
{"question": "A microcomputer used for data acquisition and control is required to digitize and process four analog input signals and to output their average continually; i.e., in real time. The time for an external analog-to-digital converter (which is triggered by a CPU instruction) to digitize one input is 12 microseconds, and only one digitization occurs at a time. Five CPU instructions, including the triggering instruction, must be executed for each signal digitized. Ten CPU instructions are executed in order to average each set of four samples and output this value. The time to convert the output from digital to analog form is to be ignored. If it is assumed that suitable data buffering is employed, then the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates, is", "choices": [{"label": "A", "text": "0.8 microseconds"}, {"label": "B", "text": "1.2 microseconds"}, {"label": "C", "text": "1.6 microseconds"}, {"label": "D", "text": "2.4 microseconds"}], "answerKey": "C", "model_answer": "n\nA) 0.8 microseconds\n```"}
{"question": "Suppose that a certain software product has a mean time between failures of 10,000 hours and has a mean time to repair of 20 hours. If the product is used by 100 customers, what is its availability?", "choices": [{"label": "A", "text": "80%"}, {"label": "B", "text": "90%"}, {"label": "C", "text": "98%"}, {"label": "D", "text": "99.80%"}], "answerKey": "D", "model_answer": "To calculate the availability of the software product, we can use the formula:\n\nAvailability = (Uptime / (Uptime + Downtime)) \\* 100\n\nWhere uptime is the amount of time the product was available for use, and downtime is the amount of time the product was not available for use.\n\nIn this case, the product has a mean time between failures of 10,000 hours, which means it is available for use for the first 10,000 hours. During this time, it can be assumed that the product will not fail, so the uptime is 10,000 hours.\n\nAfter the first 10,000 hours, the product will fail, and the downtime begins. The mean time to repair is 20 hours, which means it will take 20 hours to repair the product after it fails.\n\nIf the product is used by 100 customers, and each customer uses the product for 8 hours per day, then the total downtime for all customers is:\n\n20 hours/customer \\* 100 customers \\* 8 hours/day \\* 365 days/year = 48,200 hours/year\n\nThe total downtime for all customers is 48,200 hours/year.\n\nThe availability can be calculated as:\n\nAvailability = (10,000 hours / (10,000 hours + 48,200 hours)) \\* 100 = 36.32%\n\nTherefore, the correct answer is (D) 99.80%."}
