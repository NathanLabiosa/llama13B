{"question": "The access matrix approach to protection has the difficulty that", "choices": [{"label": "A", "text": "the matrix, if stored directly, is large and can be clumsy to manage"}, {"label": "B", "text": "it is not capable of expressing complex protection requirements"}, {"label": "C", "text": "deciding whether a process has access to a resource is undecidable"}, {"label": "D", "text": "there is no way to express who has rights to change the access matrix itself"}], "answerKey": "A", "model_answer": ""}
{"question": "An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y. Which of the following sets of integers could possibly be the set of all common divisors of two integers?", "choices": [{"label": "A", "text": "{-6,-2, -1, 1, 2, 6}"}, {"label": "B", "text": "{-6, -2, -1, 0, 1, 2, 6}"}, {"label": "C", "text": "{-6, -3, -2, -1, 1, 2, 3, 6}"}, {"label": "D", "text": "{-6, -3, -2, -1, 0, 1, 2, 3, 6}"}], "answerKey": "C", "model_answer": ""}
{"question": "In the NoNicks operating system, the time required by a single file-read operation has four nonoverlapping components:\ndisk seek time-25 msec\ndisk latency time-8 msec\ndisk transfer time- 1 msec per 1,000 bytes\noperating system overhead-1 msec per 1,000 bytes + 10 msec\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes. The ratio of-the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately", "choices": [{"label": "A", "text": "1:4"}, {"label": "B", "text": "1:3.5"}, {"label": "C", "text": "1:1"}, {"label": "D", "text": "1.1:1"}], "answerKey": "B", "model_answer": "atios describe how many times one quantity is equal to another quantity.\nRatio a:b is written a:b.\nIf a and b are equal, the ratio is written as 1:1.\nIf a is greater than b, the ratio is written as a:b.\nIf a is less than b, the ratio is written as b:a.\nSOLUTION: The ratio of the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately 1:3.5.\nThis means that version 2 takes 3.5 times as long as version 1 to read the same large file."}
{"question": "You want to cluster 7 points into 3 clusters using the k-Means Clustering algorithm. Suppose after the first iteration, clusters C1, C2 and C3 contain the following two-dimensional points: C1 contains the 2 points: {(0,6), (6,0)} C2 contains the 3 points: {(2,2), (4,4), (6,6)} C3 contains the 2 points: {(5,5), (7,7)} What are the cluster centers computed for these 3 clusters?", "choices": [{"label": "A", "text": "C1: (3,3), C2: (4,4), C3: (6,6)"}, {"label": "B", "text": "C1: (3,3), C2: (6,6), C3: (12,12)"}, {"label": "C", "text": "C1: (6,6), C2: (12,12), C3: (12,12)"}, {"label": "D", "text": "C1: (0,0), C2: (48,48), C3: (35,35)"}], "answerKey": "A", "model_answer": "LECTURE: The k-means clustering algorithm is a method of clustering that seeks to partition a data set into k clusters. In the algorithm, k points are chosen as the initial cluster centers. Each point is then assigned to the cluster it is closest to, and the cluster centers are updated by computing the mean of all the points in the cluster. This process is repeated until the cluster centers no longer change.\nSOLUTION: The first iteration of the k-means algorithm starts with the choice of k initial cluster centers. Each point is assigned to the cluster it is closest to, and the cluster centers are updated by computing the mean of all the points in the cluster.\nFor each cluster, the mean of the points in the cluster is a possible cluster center. To see this, suppose that the mean of the points in a cluster is x. Then, the cluster is closest to the point x, and every point in the cluster is closer to x than to any other point. So, x is a good choice for a cluster center.\nIn this case, the first iteration of the k-means algorithm starts with the choice of 3 initial cluster centers. The points {(0,6), (6,0)} and {(5,5), (7,7)} are chosen as the initial cluster centers. After the first iteration, the cluster centers are updated to {(3,3), (4,4), (6,6)}."}
{"question": "Any set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. Which of the following is NOT complete?", "choices": [{"label": "A", "text": "{AND, NOT}"}, {"label": "B", "text": "{NOT, OR}"}, {"label": "C", "text": "{AND, OR}"}, {"label": "D", "text": "{NAND}"}], "answerKey": "C", "model_answer": "LECTURE: A set of Boolean operators is complete if it is sufficient to represent all Boolean expressions.\nA set of Boolean operators is incomplete if it is insufficient to represent all Boolean expressions."}
{"question": "Consider the collection of all undirected graphs with 10 nodes and 6 edges. Let M and m, respectively, be the maximum and minimum number of connected components in any graph in the collection. If a graph has no selfloops and there is at most one edge between any pair of nodes, which of the following is true?", "choices": [{"label": "A", "text": "M = 10, m = 10"}, {"label": "B", "text": "M = 10, m = 1"}, {"label": "C", "text": "M = 7, m = 4"}, {"label": "D", "text": "M = 6, m = 4"}], "answerKey": "C", "model_answer": ""}
{"question": "Resolution theorem proving for showing that a formula of propositional logic is not satisfiable has which of the following properties?\nI. It is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nII. It is a complete proof system in the sense that there is a proof of unsatisfiability for every unsa tisfiable formula of propositional logic.\nIII. It is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "C", "model_answer": "LECTURE: A proof system is a set of rules for constructing proofs. In general, a proof system is sound if it is not possible to prove falsehood. A proof system is complete if it is possible to prove every possible case. These properties are defined in the following ways:\nA sound proof system is one in which no proof can attempt to prove a false statement.\nA complete proof system is one in which every provable statement is true.\nA succinct proof system is one in which a short proof exists for every possible case.\nGiven these definitions, look at the proof of unsatisfiability for each type of formula:\nFor a satisfiable formula, a resolution proof must contain a assignment that makes the formula true. But then, the formula is not unsatisfiable! So, it is not possible to prove the unsatisfiability of a satisfiable formula.\nFor an unsatisfiable formula, a resolution proof must contain a assignment that makes the formula false. This is possible for every unsatisfiable formula. So, the proof system is complete.\nFor an unsatisfiable formula, a resolution proof must contain a assignment that makes the formula false. This is possible for every unsatisfiable formula. So, the proof system is succinct.\nBut the proof system is not sound. To see this, consider a satisfiable formula F. By the previous argument, F does not have a resolution proof. But F is satisfiable! So, the proof system is not sound."}
{"question": "Which of the following statements describe(s) properties of a purely segmented memory system?\nI. It divides memory into units of equal size.\nII. It permits implementation of virtual memory.\nIII. It suffers from internal fragmentation.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "B", "model_answer": "LECTURE: In a purely segmented memory system, memory is divided into units of equal size. Each unit is called a segment.\nSegments can be of different sizes. The amount of memory allocated to each segment is fixed, and the memory is divided into segments of that size.\nFor example, a system might have a segment size of 4 kilobytes. After 4 kilobytes have been allocated to a segment, an additional byte will not be allocated until the first 4 kilobytes have been exhausted.\nA purely segmented memory system does not support virtual memory.\nVirtual memory allows a program to use more memory than is physically available. This can be a problem for a program that uses too much memory. One solution is to use virtual memory.\nVirtual memory allows a program to use more memory than is physically available. This can be a problem for a program that uses too much memory. One solution is to use virtual memory.\nVirtual memory allows a program to use more memory than is physically available. This can be a problem for a program that uses too much memory. One solution is to use virtual memory.\nIn a virtual memory system, the operating system maps the virtual memory addresses used by a program to physical memory addresses. This mapping occurs every time the program runs.\nIf a program writes to a virtual memory address, the operating system maps the virtual address to a physical address and writes to the physical address.\nIf a program reads from a virtual memory address, the operating system maps the virtual address to a physical address and reads from the physical address.\nBecause the operating system maps virtual memory addresses to physical memory addresses, a program cannot directly access the memory in between its allocated segments. This extra memory is called internal fragmentation.\nA purely segmented memory system suffers from internal fragmentation.\nBecause each segment is a fixed size, the memory between segments is not used. This memory is lost to the program, and the system cannot use it."}
{"question": "Which of the following statements about floating-point arithmetic is NOT true?", "choices": [{"label": "A", "text": "It is inherently nonassociative because some numbers have no exact representation."}, {"label": "B", "text": "It is inherently nonassociative because there have to be upper and lower bounds on the size of numbers."}, {"label": "C", "text": "Associativity can be achieved with appropriate roundoff conventions."}, {"label": "D", "text": "Some rational numbers have no exact representation."}], "answerKey": "C", "model_answer": "LECTURE: Floating-point arithmetic is used in computers to represent real numbers. It is based on representing numbers as an integer part and a fractional part. The fractional part is represented in a way that supports addition and multiplication.\nThere are two floating-point rounding conventions, or rounds: round to the nearest whole number (round up) and round to the nearest integer (round down). These rounds can cause numbers to be rounded up or down when they are evaluated in a computation.\nSOLUTION: The statement that some rational numbers have no exact representation is not true. For example, the rational number 1/2 has an exact representation."}
{"question": "Suppose sharing of tiles in a multilevel directory structure is achieved with directory entries that are links pointing to a node containing information about a shared file. Information in this node includes (1) the owner of the file, (2) a count of the number of links to the tile, and (3) the disk block numbers of the file. What is a primary drawback to this approach to sharing?", "choices": [{"label": "A", "text": "If the owner modifies the file, another user who does not share will see the changes."}, {"label": "B", "text": "If the owner renames the file, other users will not be able to access it."}, {"label": "C", "text": "If the owner is allowed to delete a file, dangling links may result."}, {"label": "D", "text": "If any user who shares the file appends to it, others who share it will not be able to access the new disk blocks."}], "answerKey": "C", "model_answer": ""}
{"question": "Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves. Which of the following data structures will allow mergesort to work in O(n log n) time?\nI. A singly linked list\nII. A doubly linked list\nIII. An array", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: In general, mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves.\nFor example, if n = 6, the list looks like this before mergesort:\nThe list is split into two smaller lists, each with 3 numbers.\nThese smaller lists are then sorted by mergesort.\nThe two smaller sorted lists are then merged back into one larger sorted list:\nThe final sorted list is:\nSOLUTION: Mergesort can work in O(n log n) time with an array.\nWhen mergesort is called with an array, the array is sorted in O(n log n) time.\nFor example, the mergesort algorithm can be called with a chunk of size n/2 and sort it in O(n log n) time.\nThis takes care of the first half of the array.\nTo sort the second half of the array, mergesort is called again with the second half of the array.\nSince the array is now half as long, mergesort is called with a chunk size of n/2.\nThe overall running time of this process is O(n log n).\nMergesort cannot work in O(n log n) time with a singly linked list or a doubly linked list.\nWith a singly linked list, mergesort has to traverse the entire linked list to sort it.\nThis takes O(n) time.\nWith a doubly linked list, mergesort has to traverse the entire linked list to sort it.\nThis takes O(n) time."}
{"question": "If p(x) is the minimal-degree interpolating polynomial for the real-valued function f(x) at the n + 1 distinct real numbers x0, .... xn what is the maximum possible degree of p(x)?", "choices": [{"label": "A", "text": "n"}, {"label": "B", "text": "n + 1"}, {"label": "C", "text": "n + 2"}, {"label": "D", "text": "2n"}], "answerKey": "A", "model_answer": ""}
{"question": "An internal hash table has 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is", "choices": [{"label": "A", "text": "3"}, {"label": "B", "text": "8"}, {"label": "C", "text": "10"}, {"label": "D", "text": "13"}], "answerKey": "A", "model_answer": ""}
{"question": "TCP protocol is responsible (among other things) for", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "C", "model_answer": ""}
{"question": "Let A and B be two sets of words (strings) from \u03a3*, for some alphabet of symbols \u03a3. Suppose that B is a subset of A. Which of the following statements must always be true of A and B ?\nI. If A is finite, then B is finite.\nII. If A is regular, then B is regular.\nIII. If A is context-free, then B is context-free.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A set is infinite if it contains an infinite number of elements. A set is finite if it contains a finite number of elements.\nA set is regular if it contains an equal number of odd and even elements.\nA set is context-free if it does not contain the substring uvwx, where u, v, w, and x are distinct elements of \u03a3.\nSOLUTION: B is a subset of A. So, B is finite if and only if A is finite.\nB is regular if and only if A is regular.\nB is context-free if and only if A is context-free."}
{"question": "For all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings. Which of the following is true?", "choices": [{"label": "A", "text": "a^M = a"}, {"label": "B", "text": "(ax)^M = (xa)^M"}, {"label": "C", "text": "(xy)^M = y^Mx^M"}, {"label": "D", "text": "None of the above"}], "answerKey": "D", "model_answer": "LECTURE: Recursive functions are functions that refer to themselves with their own output as an input. Recursive functions can be defined using a recursive definition, which is a definition that refers to the function itself.\nFor example, the factorial of a nonnegative integer n is defined recursively using the formula:\nn! = n \u00d7 (n-1)!\nThe recursive definition for the factorial function is:\n!n = n \u00d7 !(n-1)\nThis recursive definition can be used to calculate the factorial of any nonnegative integer.\nSOLUTION: The function M is defined recursively as follows:\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nApplying the function M to the strings x and y of the problem, we get:\n(ax)^M = (xa)^M, and\n(xy)^M = y^Mx^M.\nTherefore, LECTURE: A function is a rule that assigns to each element of a set a unique element of a second set.\nIf one set is the set of integers and the other set is the set of integers, the function is called a constant function.\nIf one set is the set of integers and the other set is the set of real numbers, the function is called a linear function.\nIf one set is the set of real numbers and the other set is the set of real numbers, the function is called a linear function.\nAn elementary function is a function that is either a constant function, a linear function, or a function that can be expressed using the arithmetic operations plus, minus, times, and divide and the square root operation.\nThe graph of a function f is the set of all points (x,f(x)) that satisfy the rule for f.\nThe graph of a function has several properties that tell you about the function.\nIf the graph of a function is a line, the function is a linear function.\nIf the graph of a function is a straight line with a slope of 1 and a y-intercept of 1, the function is the constant function f(x) = 1.\nThe graph of a function is a set of points. It does not have to be nice-looking or easy to see. The graph of a function may be a curve, a spiral, or a set of points that is not a line.\nA function is one-to-one (or an injection) if each input has exactly one output. The function is a one-to-one function.\nIf a function is one-to-one, then the function is also a function.\nA function is onto (or a surjection) if each output has at least one output. The function is an onto function.\nIf a function is onto, then the function is also a function.\nA function is a bijection if the function is both one-to-one and onto. The function is a bijection.\nA function is a function.\nIf a function is a bijection, then the function can be converted into an inverse function.\nAn inverse function is a function that undoes another function.\nIf a function is one-to-one and onto, then the function has an inverse function.\nSOLUTION: To show that (ax)^M = (xa)^M, consider the pair of strings x and a.\nBy the recursive definition of the function M, we have:\n(ax)^M = (a x)^M.\nNow, use the pair of strings y and x to define a string z.\nz = x.\nThen, by the recursive definition of the function M, we have:\n(az)^M = a(x)^M.\nNow, substitute the first equation into the second equation.\n(az)^M = (a x)^M.\nSo, (ax)^M = (xa)^M.\nTo show that (xy)^M = y^Mx^M, consider the pair of strings y and x.\nBy the recursive definition of the function M, we have:\n(xy)^M = y(xy)^(M-1).\nNow, use the pair of strings z and x to define a string w.\nw = x.\nThen, by the recursive definition of the function M, we have:\n(zw)^M = w^Mz^M.\nNow, substitute the first equation into the second equation.\n(zw)^M = x^Mw^M.\nSo, (xy)^M = y^Mx^M."}
{"question": "Which of the following is NOT a reasonable justification for choosing to busy-wait on an asynchronous event?", "choices": [{"label": "A", "text": "The wait is expected to be short."}, {"label": "B", "text": "A busy-wait loop is easier to code than an interrupt handler."}, {"label": "C", "text": "There is no other work for the processor to do."}, {"label": "D", "text": "The program executes on a time-sharing system."}], "answerKey": "D", "model_answer": "LECTURE: In an asynchronous program, events may occur at any time. In order to keep a program running when these events occur, the program must be able to respond to them. There are two ways to do this:\nA program can use polling. The program regularly checks to see if an event has occurred. This is the most simple way to respond to an event.\nA program can use interrupts. The program registers a handler function to be called when an event occurs. When the event occurs, the processor interrupts the normal flow of the program and calls the handler function.\nA busy-wait loop is a simple form of polling. It works as follows:\n1. The program repeatedly checks to see if the event has occurred.\n2. The program continues to run normally when the event is not yet occur.\nThis is not as efficient as an interrupt-based solution, because the program wastes time waiting for the event to occur. But a busy-wait loop is easier to write and use than an interrupt handler.\nSOLUTION: A program executes on a time-sharing system.\nA time-sharing system is a system that allows many programs to share a single processor. The processor switches quickly between programs, making it appear as though each program is running simultaneously on its own processor.\nA program does not need to use interrupts to respond to events on a time-sharing system. The processor will be available to handle the events when the program is not using it."}
{"question": "The language {ww | w in (0 + 1)*} is", "choices": [{"label": "A", "text": "not accepted by any Turing machine"}, {"label": "B", "text": "accepted by some Turing machine, but by no pushdown automaton"}, {"label": "C", "text": "accepted by some pushdown automaton, but not context-free"}, {"label": "D", "text": "context-free, but not regular"}], "answerKey": "B", "model_answer": "LECTURE: A language is a set of strings. The notation {ww | w in (0 + 1)*} represents a language of strings that contain only one symbol. More formally, the language contains all strings that contain exactly one symbol from the set {0, 1}.\nThe symbol 0 is represented by the binary number 00, and the symbol 1 is represented by the binary number 01.\nThe language {ww | w in (0 + 1)*} is accepted by some Turing machines, but by no pushdown automaton.\nA pushdown automaton can recognize a language that contains one symbol, but it is not powerful enough to recognize the {ww | w in (0 + 1)*} language.\nA Turing machine can recognize the {ww | w in (0 + 1)*} language.\nA language is context-free if it can be recognized by a context-free grammar.\nA context-free grammar is a set of production rules that generates a language.\nThe language {ww | w in (0 + 1)*} is not regular.\nA language is regular if it can be recognized by a finite state machine.\nA finite state machine is a machine that has a finite number of states and transitions.\nThe {ww | w in (0 + 1)*} language is not recognized by any finite state machine."}
{"question": "Which of the following statements about Ethernets is typically FALSE?", "choices": [{"label": "A", "text": "Ethernets use circuit switching to send messages."}, {"label": "B", "text": "Ethernets use buses with multiple masters."}, {"label": "C", "text": "Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly."}, {"label": "D", "text": "Networks connected by Ethernets are limited in length to a few hundred meters."}], "answerKey": "A", "model_answer": "LECTURE: In a network, a protocol is a set of rules that devices use to communicate with each other. Ethernet is a type of protocol for networks.\nEthernet protocols use a collision-detection method to ensure that messages are transmitted properly. If two devices try to transmit a message at the same time, the Ethernet protocol detects the collision and has each device transmit its message on the next clock cycle.\nEthernet protocols use buses with multiple masters. A bus is a set of wires that all devices share. Each master device can send messages on the bus.\nEthernet protocols do not use circuit switching to send messages. In circuit switching, a circuit is established for the duration of the communication session. Ethernet protocols use a connection-oriented approach in which a connection is established just long enough to transmit a message.\nNetworks connected by Ethernets are limited in length to a few hundred meters. Ethernet protocols can transmit messages over a distance of a few hundred meters to a few kilometers.\nSOLUTION: Typically, Ethernet protocols use buses with multiple masters.\nEthernet protocols do not use circuit switching to send messages.\nNetworks connected by Ethernets are limited in length to a few hundred meters."}
{"question": "Let P be a procedure that for some inputs calls itself (i.e., is recursive). If P is guaranteed to terminate, which of the following statements must be true?\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: Procedures can be recursive, which means they call themselves. A procedure is guaranteed to terminate if it has a base case that is a base procedure call.\nA base procedure call is a call to a procedure that does not call itself.\nFor example, in the following procedure, the call to square is a base procedure call. It is not a recursive call.\nprocedure area of a square:\nsquare := input\narea := square\u00b2"}
{"question": "Which of the following comes closest to being a perfectly secure encryption scheme?", "choices": [{"label": "A", "text": "The Caesar Cipher, a substitution cipher"}, {"label": "B", "text": "DES (Data Encryption Standard), a symmetric-key algorithm"}, {"label": "C", "text": "Enigma, a transposition cipher"}, {"label": "D", "text": "One-time pad"}], "answerKey": "D", "model_answer": ""}
{"question": "Of the following problems concerning a given undirected graph G, which is currently known to be solvable in polynomial time?", "choices": [{"label": "A", "text": "Finding a longest simple cycle in G"}, {"label": "B", "text": "Finding a shortest cycle in G"}, {"label": "C", "text": "Finding ALL spanning trees of G"}, {"label": "D", "text": "Finding a largest clique in G"}], "answerKey": "B", "model_answer": "LECTURE: A graph is a collection of nodes or vertices and a set of edges that connect pairs of nodes.\nA simple cycle is a cycle that does not contain any other edges.\nA spanning tree is a tree that uses all of the vertices in a graph.\nA clique is a set of vertices in a graph that are connected by edges.\nSOLUTION: Finding a longest simple cycle in G can be solved in polynomial time.\nFinding a shortest cycle in G can be solved in polynomial time.\nFinding all spanning trees of G can be solved in exponential time.\nFinding a largest clique in G can be solved in polynomial time."}
{"question": "The IP protocol is primarily concerned with", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "A", "model_answer": ""}
{"question": "Of the following, which best approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N?", "choices": [{"label": "A", "text": "1/K"}, {"label": "B", "text": "K-1/K"}, {"label": "C", "text": "log_10 (1/N)"}, {"label": "D", "text": "N-1/m"}], "answerKey": "A", "model_answer": "LECTURE: A tree is a connected graph that does not contain any cycles.\nA K-ary tree is a tree with each edge is connected to exactly K vertices.\nThe depth of a node in a tree is the number of edges on the path from the node to a leaf node.\nIf a tree has depth N and K branches at each node, then the total number of nodes in the tree is KN.\nSOLUTION: At each node, N-1 of the branches lead to leave nodes. So, the number of nonterminal nodes is N-1.\nThe total number of nodes in a K-ary tree of depth N is KN.\nSo, the ratio of nonterminal nodes to the total number of nodes is N-1/KN. This ratio approximates 1/K."}
{"question": "Consider a computer system in which processes can request and release one or more resources. Once a process has been granted a resource, the process has exclusive use of that resource until it is released. If a process requests a resource that is already in use, the process enters a queue for that resource, waiting until the resource is available. Which of the following will NOT deal effectively with the problem of deadlock?", "choices": [{"label": "A", "text": "Giving priorities to processes and ordering the wait queues by priority"}, {"label": "B", "text": "Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all"}, {"label": "C", "text": "Numbering the resources and requiring that processes request resources in order of increasing number"}, {"label": "D", "text": "Having processes time out and restart after a random interval of waiting"}], "answerKey": "A", "model_answer": ""}
{"question": "\"Magic memory\"' has two operations: Read and Clear. Both are indivisible and mutually exclusive. Clear sets the magic memory to zero. Read returns a value that represents the number of Read operations since the last Clear operation. Which of the following is (are) true of \"Magic memory\"?\nI. It can provide the functionality of an atomic Test-and-Set.\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nIII. It is only useful on a multiprocessor.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: Atomic operations allow processes to communicate with each other and coordinate their activities. An atomic operation is indivisible and cannot be interrupted by another process.\nIn a shared memory model, processes can communicate by reading and writing values to memory locations. Imagine a process that needs to communicate an integer value to another process. The process can write the value to a memory location. Then, the receiving process can read the value from that location.\nIf the writing process and the receiving process both access the memory location at the same time, they can read and write the incorrect value. To ensure that this does not happen, the memory operation can become atomic. An atomic memory operation sets the value to the memory location in one indivisible operation.\nSOLUTION: \"Magic memory\" has two atomic operations: Read and Clear. \"Magic memory\" can be used to coordinate processes running on a shared-memory multiprocessor.\nThe magic memory is only useful on a multiprocessor."}
{"question": "Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?", "choices": [{"label": "A", "text": "Abstract Syntax Tree (AST)"}, {"label": "B", "text": "Attribute Grammar"}, {"label": "C", "text": "Symbol Table"}, {"label": "D", "text": "Semantic Stack"}], "answerKey": "C", "model_answer": "LECTURE: A symbol table is a data structure that keeps track of the variables and their attributes in a program. It is used by a compiler or interpreter.\nWhen a variable is mentioned in a program, the symbol table is consulted to find its value. The symbol table also keeps track of the types of variables."}
{"question": "Which of the following algorithms has running time \u0398(n^2) in the worst case but \u0398(n log n) on average?", "choices": [{"label": "A", "text": "Bubblesort"}, {"label": "B", "text": "Mergesort"}, {"label": "C", "text": "Heapsort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "D", "model_answer": ""}
{"question": "Languages with a structure that implements abstract data types (e.g., a C++ class) can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation). Which of the following statements about comparisons between direct and indirect representations is (are) true?\nI. Indirect representation noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: A data structure is a collection of fields, or variables, that are organized in a specific way. Every data structure has a specific purpose for which it was designed. For example, an array is a data structure that stores a collection of elements. An element can be accessed by its index.\nThe diagram below shows the structure of an array.\nAn array has two main parts: the elements and the index.\nThe elements are stored in a contiguous block of memory. The index tells you the address of the first element in the array.\nFor example, the address of the first element is given by the expression:\nindex * sizeof(element)\nIf the array is dynamic, the index is also a pointer. The expression integer * sizeof(integer) always refers to the first element of the array.\nAn array has a maximum size, which is the size of the contiguous block of memory that stores the elements.\nThe maximum size of an array is determined by the amount of free memory.\nA class is a data structure that has both fields and methods. A class can contain any type of data.\nFor example, a class can have fields of type int, float, or string. It can also have methods, or functions, that perform actions on the data.\nThe purpose of a class is to bundle data and the methods that operate on that data into a single unit. This unit can be passed around and can have methods called on it.\nHere is an example of a simple class.\nThis class has one field, called value, of type float. It also has one method, called doubleValue, which doubles the value of the field.\nSOLUTION: An object's name can be bound to either direct or indirect representation of the object's components.\nAn object's direct representation has its component values stored in stack storage.\nAn object's indirect representation has its component values stored in heap storage, with a stack pointer referencing the heap storage.\nThe table below compares direct and indirect representations.\nQuality of direct representation\nQuality of indirect representation\nComponents are accessed on the stack.\nComponents are accessed through a pointer.\nAccess time is faster.\nAccess time is slower.\nCompilation time is shorter.\nCompilation time is longer.\nFewer recompilations are needed when the size of a private component changes.\nMore recompilations are needed when the size of a private component changes."}
{"question": "Which of the following is NOT a property of bitmap graphics?", "choices": [{"label": "A", "text": "Fast hardware exists to move blocks of pixels efficiently."}, {"label": "B", "text": "Realistic lighting and shading can be done."}, {"label": "C", "text": "All line segments can be displayed as straight."}, {"label": "D", "text": "Polygons can be filled with solid colors and textures."}], "answerKey": "C", "model_answer": "LECTURE: Bitmap graphics are made up of a grid of pixels, or picture elements. A bitmap can display only what is in the image, and can change the image by moving or removing pixels.\nA bitmap graphic is a digital image. It is not as smooth as a vector graphic, but bitmaps can be used to create detailed images.\nSOLUTION: Hardware does exist to move blocks of pixels efficiently.\nAll line segments can be displayed as straight.\nPolygons can be filled with solid colors and textures.\nRealistic lighting and shading can be done."}
{"question": "Which of the following is true of interrupts?", "choices": [{"label": "A", "text": "They are generated when memory cycles are \"stolen\"."}, {"label": "B", "text": "They are used in place of data channels."}, {"label": "C", "text": "They can indicate completion of an I/O operation."}, {"label": "D", "text": "They cannot be generated by arithmetic operations."}], "answerKey": "C", "model_answer": "LECTURE: Interrupts are a way for your program to respond to a event that happens in the computer. When an interrupt occurs, the processor stops executing your program and starts executing the interrupt handler. The interrupt handler is a piece of code that is run in response to the interrupt.\nInterrupts are generated by hardware devices. For example, the keyboard sends an interrupt when a key is pressed. The interrupt signals to the processor that it needs to stop executing your program and run the interrupt handler.\nThe interrupt handler is responsible for handling the interrupt. It performs any necessary actions and then returns control to your program.\nSOLUTION: The correct answer is C.\nWhen an interrupt is generated, the processor switches from executing your program to executing the interrupt handler. The interrupt handler is executed instead of the remaining instructions in your program.\nInterrupts can indicate completion of an I/O operation. For example, when data is sent to a serial port, the interrupt is generated when the data is sent."}
{"question": "In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. Which of the following are true of such a tree?\nI. Worst-case search time is logarithmic in the number of nodes.\nII. Average-case search time is logarithmic in the number of nodes.\nIII. Best-case search time is proportional to the height of the tree.\nIV. The height of the tree is logarithmic in the number of nodes.", "choices": [{"label": "A", "text": "I and III only"}, {"label": "B", "text": "II and III only"}, {"label": "C", "text": "II and IV only"}, {"label": "D", "text": "I, II, and IV"}], "answerKey": "D", "model_answer": "LECTURE: In a height-balanced binary search tree, the height of the tree is logarithmic in the number of nodes.\nA height-balanced binary search tree is a binary search tree in which the height of the tree is approximately equal to the logarithm of the number of nodes in the tree.\nFor example, if the number of nodes in a height-balanced binary search tree is 2^n, then the height of the tree is log2 2^n = n.\nA height-balanced binary search tree is a height-balanced binary tree.\nEvery tree is height-balanced.\nA binary tree is height-balanced if and only if the height of the tree is equal to the logarithm of the number of nodes in the tree.\nIf the root has a left child and a right child, the height of the tree is 1 + the height of the left tree.\nIf the root has only one child, the height of the tree is the height of the root.\nIf the root has no children, the height of the tree is 0.\nSOLUTION: A height-balanced binary search tree is a binary search tree in which the height of the tree is approximately equal to the logarithm of the number of nodes in the tree.\nSo, the height of the tree is logarithmic in the number of nodes."}
{"question": "Bob writes down a number between 1 and 1,000. Mary must identify that number by asking \"yes/no\" questions of Bob. Mary knows that Bob always tells the truth. If Mary uses an optimal strategy, then she will determine the answer at the end of exactly how many questions in the worst case?", "choices": [{"label": "A", "text": "1,000"}, {"label": "B", "text": "999"}, {"label": "C", "text": "500"}, {"label": "D", "text": "10"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following is (are) true about virtual memory systems that use pages?\nI. The virtual address space can be larger than the amount of physical memory.\nII. Programs must be resident in main memory throughout their execution.\nIII. Pages correspond to semantic characteristics of the program.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "LECTURE: A virtual memory system is designed to make the memory space available in a computer seem larger than it actually is. The virtual memory system uses a combination of main memory and secondary storage to simulate a larger memory space.\nPages are small units of memory that are stored in secondary storage, such as a hard drive. When a program needs to access data from a page, the page is brought into main memory. This process is called paging.\nThe operating system manages the process of paging. As pages are brought into main memory, the operating system ensures that the data is stored in the correct order and that each page is accessed only by the program that created it.\nA virtual memory system that uses pages has the following characteristics:\nThe virtual address space can be larger than the amount of physical memory. When a program tries to access an address that is not currently in main memory, the operating system retrieves the required page from secondary storage into main memory. This process is called swapping.\nPrograms must be resident in main memory throughout their execution. When a program is running, its code and data must be stored in main memory. If the program's data is not in main memory, the program may try to access pages that are still in secondary storage.\nPages correspond to semantic characteristics of the program. A page is a unit of memory that is created and used by a program. A page of memory is typically associated with a program's code or data.\nSOLUTION: The correct answer is C.\nThe operating system can use pages to simulate a larger memory space than is available in main memory. When a program needs to access data that is not currently in main memory, the operating system retrieves the required page into main memory.\nA program does not have to be completely resident in main memory. Some of a program's code and data may be in main memory, and the rest may be in secondary storage. This is called partial loading.\nPages correspond to semantic characteristics of the program. For example, a page of memory may be associated with a program's code or data."}
{"question": "Which of the following is usually NOT represented in a subroutine's activation record frame for a stack-based programming language?", "choices": [{"label": "A", "text": "Values of local variables"}, {"label": "B", "text": "A heap area"}, {"label": "C", "text": "The return address"}, {"label": "D", "text": "Stack pointer for the calling activation record"}], "answerKey": "B", "model_answer": "LECTURE: A subroutine is a sequence of instructions that performs a specific task. Subroutines can be called from other parts of a program, and they can return values to the location where they were called.\nA subroutine has an activation record, which is kept on the stack. The activation record contains information about the subroutine's call, including the values of the arguments that were passed to the subroutine.\nWhen a subroutine is called, the activation record for the calling subroutine is pushed onto the stack. The stack is a special region of memory that stores information about the calls that are currently active in a program.\nWhen a subroutine returns, its activation record is popped from the stack. The stack pointer is updated to remove the space that was used for the activation record.\nSOLUTION: A heap area is usually not represented in a subroutine's activation record frame for a stack-based programming language. Heap areas and stack areas are both areas of memory, but they are used for different purposes.\nThe stack is used for temporary data that is pushed and popped by subroutines. The stack is managed automatically by the program.\nThe heap is used for permanent data that is created by subprograms. The program must manage the heap explicitly."}
{"question": "Which of the following statements about a remote procedure call is true?", "choices": [{"label": "A", "text": "It is used to call procedures with addresses that are farther than 2^16 bytes away."}, {"label": "B", "text": "It cannot return a value."}, {"label": "C", "text": "It cannot pass parameters by reference."}, {"label": "D", "text": "It cannot call procedures implemented in a different language."}], "answerKey": "C", "model_answer": "LECTURE: Procedures and functions are two ways to divide up code.\nA procedure is a series of statements that performs a task. It is defined using the procedure keyword.\nA function is a named procedure. A function can be called like a variable.\nRemote procedure calls are calls to procedures that are located in a different address space."}
{"question": "Of the following sorting algorithms, which has a running time that is LEAST dependent on the initial ordering of the input?", "choices": [{"label": "A", "text": "Insertion sort"}, {"label": "B", "text": "Quicksort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Selection sort"}], "answerKey": "C", "model_answer": "LECTURE: In an efficient sorting algorithm, the running time is the amount of time it takes to sort a list. The running time of a sorting algorithm is determined by the algorithm's step, or the order in which it performs its steps.\nAn efficient sorting algorithm has a running time that is not dependent on the initial ordering of the input. This means that the running time is the same, regardless of the order of the elements in the input.\nSOLUTION: To determine which sorting algorithm has a running time that is least dependent on the initial ordering of the input, look at the steps of each algorithm.\nSelection sort has a running time of O(n^2), which means that the running time is directly dependent on the ordering of the elements in the input. For small input sizes, Selection sort may be efficient. But, for larger input sizes, Insertion sort is usually faster.\nInsertion sort has a running time of O(n^2), which is the same as Selection sort. But, Insertion sort is simpler and easier to understand than Selection sort.\nMerge sort has a running time of O(n log n), which means that the running time is dependent on the initial ordering of the input. But, Merge sort is generally considered to be the most efficient sorting algorithm, so it is a good choice when you need to sort a large list.\nQuicksort has a running time of O(n log n), which is the same as Merge sort. But, Quicksort has a step that involves choosing a pivot element. The choice of pivot can greatly affect the running time of Quicksort. So, Quicksort is not as reliable as Merge sort."}
{"question": "A particular parallel program computation requires 100 seconds when executed on a single processor. If 40 percent of this computation is \"inherently sequential\" (i.e., will not benefit from additional processors), then the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are", "choices": [{"label": "A", "text": "20 and 10 seconds"}, {"label": "B", "text": "30 and 15 seconds"}, {"label": "C", "text": "50 and 25 seconds"}, {"label": "D", "text": "70 and 55 seconds"}], "answerKey": "D", "model_answer": ""}
{"question": "Consider the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude. In which representation is there overflow from the addition of the integers 011000 and 011000?", "choices": [{"label": "A", "text": "Two's complement only"}, {"label": "B", "text": "Sign and magnitude and one's complement only"}, {"label": "C", "text": "Two's complement and one's complement only"}, {"label": "D", "text": "All three representations"}], "answerKey": "D", "model_answer": "LECTURE: To perform arithmetic operations on numbers written in binary, assume that the binary numbers are represented with a sign and a magnitude. The sign is represented by the leftmost bit, which can have a value of 0 or 1. The magnitude is represented by the remaining bits.\nIf the leftmost bit is 0, the number is positive. If the leftmost bit is 1, the number is negative.\nTo add or subtract binary numbers, first perform the operation on the magnitude parts of the numbers. Then, combine the signs as needed.\nTwo numbers with the same sign have the same magnitude sum. Two numbers with different signs have a sum that is the magnitude of one number plus the magnitude of the other number.\nFor example, consider the binary numbers 1011 and 0110.\nTo add these numbers, add the magnitude parts of the numbers: 1011 + 0110 = 1101.\nThen, combine the signs as needed. The numbers have the same sign, so the sum is 1101.\nIf the numbers have different signs, the sum is the magnitude of the number with the greater magnitude plus the magnitude of the number with the lesser magnitude. For example, consider the binary numbers 1011 and 0110.\nTo add these numbers, add the magnitude parts of the numbers: 1011 + 0110 = 1101.\nThen, combine the signs as needed. The numbers have different signs, so the sum is 1101.\nSOLUTION: To determine if there is overflow from the addition of 011000 and 011000, consider the two's complement, sign and magnitude, and one's complement representations of six-bit numbers.\nIn the two's complement representation, there is no overflow. The addition of 011000 and 011000 in the two's complement representation is 011000.\nIn the sign and magnitude representation, there is overflow. The sign of the result must be different from the signs of the two numbers. So, the result is negative.\nThe magnitude of the result is the magnitude of 011000 + the magnitude of 011000.\n011000 + 011000 = 110000.\nIn the one's complement representation, there is no overflow. The addition of 011000 and 011000 in the one's complement representation is 011000."}
{"question": "Of the following, which best characterizes computers that use memory-mapped I/O?", "choices": [{"label": "A", "text": "The computer provides special instructions for manipulating I/O ports."}, {"label": "B", "text": "I/O ports are placed at addresses on the bus and are accessed just like other memory locations."}, {"label": "C", "text": "To perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}, {"label": "D", "text": "Ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}], "answerKey": "B", "model_answer": "LECTURE: I/O stands for input/output. I/O operations are ways for a computer program to communicate with the outside world.\nMany computers have a set of instructions called ports that allow a program to communicate with external devices. A port is simply an address in memory that a program can use to write data or read data.\nWhen a program writes data to a port, it is sending data to an external device. When a program reads data from a port, it is reading data from an external device.\nSome devices have multiple ports. A port is identified by a number. For example, the port number 0 might be used to represent a specific type of device. The port number 1 might be used to represent another specific type of device.\nA device driver is a set of instructions that tells the computer how to communicate with a specific type of device. The device driver uses the port numbers to figure out how to send data to and receive data from the device.\nSOLUTION: A computer that uses memory-mapped I/O makes the ports available at addresses on the bus. The computer can access these ports just like it accesses other memory locations.\nTo perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}
{"question": "Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that", "choices": [{"label": "A", "text": "integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs"}, {"label": "B", "text": "P = NP"}, {"label": "C", "text": "even if P = NP, integer factorization is still likely not to be polynomial-time computable"}, {"label": "D", "text": "testing primality is computationally intractable"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following sets of bit strings CANNOT be described with a regular expression?", "choices": [{"label": "A", "text": "All bit strings whose number of zeros is a multiple of five"}, {"label": "B", "text": "All bit strings starting with a zero and ending with a one"}, {"label": "C", "text": "All bit strings with an even number of zeros"}, {"label": "D", "text": "All bit strings with more ones than zeros"}], "answerKey": "D", "model_answer": "LECTURE: In a regular expression, a set of characters is called a metacharacter if it has a special meaning. The metacharacters in regular expressions are:\n. | \\ | [] | {}\nThese metacharacters have the following meanings:\n. matches any character.\n\\ escapes a metacharacter. For example, \\. matches a period.\n[] matches any sequence of characters inside the brackets. For example, [abc] matches the sequence abc in a larger character string.\n{} matches any sequence of characters inside the curly braces. For example, {}abc{} matches the sequence abc in a larger character string.\nSOLUTION: The regular expression for each set of bit strings is:\nAll bit strings with an even number of zeros: \\d\\d*\\d\\d\\d.\nAll bit strings starting with a zero and ending with a one: ^0\\d*1$.\nAll bit strings whose number of zeros is a multiple of five: 0\\d*5.\nAll bit strings with more ones than zeros: \\d+>\\d+."}
{"question": "Which of the following conditions can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac)?\nI. At least three of p_1, p_2, p_3, p_4 are true.\nII. Exactly three of p_1, p_2, p_3, p_4 are true.\nIII. An even number of p_1, p_2, p_3, p_4 are true.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "LECTURE: A Boolean variable is a variable that can have only two values: true or false.\nA Boolean formula is a combination of variables and connectives.\nA Boolean formula is true if it is made up of true variables.\nA Boolean formula is false if it is made up of false variables.\nSOLUTION: Each condition can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac).\nI. At least three of p_1, p_2, p_3, p_4 are true.\nThis condition can be expressed by the formula p_1 \u2227 p_2 \u2227 p_3 \u2227 p_4.\nThe formula p_1 \u2227 p_2 \u2227 p_3 \u2227 p_4 is true if at least one of p_1, p_2, p_3, p_4 is true.\nExactly three of p_1, p_2, p_3, p_4 are true.\nThis condition can be expressed by the formula (p_1 \u2227 p_2) \u2228 (p_2 \u2227 p_3) \u2228 (p_3 \u2227 p_4).\nThe formula (p_1 \u2227 p_2) \u2228 (p_2 \u2227 p_3) \u2228 (p_3 \u2227 p_4) is true if exactly three of p_1, p_2, p_3, p_4 are true.\nAn even number of p_1, p_2, p_3, p_4 are true.\nThis condition can be expressed by the formula p_1 \u2228 (p_2 \u2227 p_3 \u2227 p_4).\nThe formula p_1 \u2228 (p_2 \u2227 p_3 \u2227 p_4) is true if an even number of p_1, p_2, p_3, p_4 are true."}
{"question": "Two alternatives for interconnecting a set of processors with bidirectional links are (1) the fully interconnected network, in which each processor is directly connected to every other processor, and (2) the ring network, in which each processor is connected to two other processors. The worst-case path length for a network is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes. For each type of interconnection of n processors, a figure of merit can be formed as the product of the number of links required for the network times the worst-case path length connecting any two processors. The ratio of this figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is", "choices": [{"label": "A", "text": "1/(n^2)"}, {"label": "B", "text": "1/(n(n-1))"}, {"label": "C", "text": "1/n"}, {"label": "D", "text": "(n-1)/n"}], "answerKey": "D", "model_answer": ""}
{"question": "For a connected, undirected graph G = (V, E), which of the following must be true?\nI. \u03a3_{v\u2208V} degree(v) is even.\nII. |E| \u2265 |V| \u2212 1\nIII. G has at least one vertex with degree 1.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of vertices and edges. A vertex is a point, and an edge is a line segment that connects two points.\nA graph is connected if there is a path between any two vertices.\nAn undirected graph is made up of edges that do not have a direction.\nA graph is finite if it has a limited number of vertices and edges.\nA graph is loop-free if it has no edges that connect a vertex back to itself.\nSOLUTION: Look at each answer choice.\nI. \u03a3_{v\u2208V} degree(v) is even.\nThe degree of a vertex is the number of edges that connect to it.\nIf the degree of a vertex is even, then the vertex is part of an even number of edges.\nSo, each vertex is part of an even number of edges.\nThis means that the total number of edges is even.\nII. |E| \u2265 |V| \u2212 1.\nThe number of edges, |E|, is at least 1 less than the number of vertices, |V|.\nThis means that the graph has at least one edge.\nIII. G has at least one vertex with degree 1.\nA vertex with degree 1 is part of one edge.\nSo, a graph with at least one vertex with degree 1 has at least one edge.\nThis means that the total number of edges is at least 1.\nBut |E| \u2265 |V| \u2212 1.\nSo, |E| \u2265 1."}
{"question": "In multiprogrammed systems it is advantageous if some programs such as editors and compilers can be shared by several users. Which of the following must be true of multiprogrammed systems in order that a single copy of a program can be shared by several users?\nI. The program is a macro.\nII. The program is recursive.\nIII. The program is reentrant.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "C", "model_answer": "LECTURE: In a multiprogrammed system, many programs can be in memory at the same time. If these programs share a pool of memory, each program can use the memory it needs to store its data. This way, each program can run without using a separate copy of its code.\nA program is reentrant if it can be called by a subroutine.\nA program is recursive if it calls itself.\nA macro is a set of instructions that is stored in the computer's memory. When the macro is executed, the instructions are retrieved from memory and performed.\nSOLUTION: To share a copy of a program, several conditions must be met:\nThe program is reentrant.\nThe program is macro.\nThe program is not recursive."}
{"question": "Which of the following decimal numbers has an exact representation in binary notation?", "choices": [{"label": "A", "text": "0.1"}, {"label": "B", "text": "0.2"}, {"label": "C", "text": "0.3"}, {"label": "D", "text": "0.5"}], "answerKey": "D", "model_answer": ""}
{"question": "Function signatures describe the types of the arguments to a function as well as the return value of the function. For instance, the addition function on reals has a signature of\nadd : real x real -> real\nsince it takes two real numbers and returns a real number. But, for a language that allows functions as return values, addition could be considered to have the signature\nadd : real -> (real -> real)\nwhich means that add takes a single real (the first operand) and returns a new function that itself takes a single real (the second operand) and returns a real (the result). This process of reducing a function with multiple arguments to a function with fewer arguments is called currying. Which of the following is correct?", "choices": [{"label": "A", "text": "Currying can be applied to any function to the point where it has exactly one input argument."}, {"label": "B", "text": "Currying cannot be applied to functions of more than two arguments."}, {"label": "C", "text": "Currying cannot be applied to functions that return functions as arguments."}, {"label": "D", "text": "Currying cannot be applied w functions that haw arguments that are functions."}], "answerKey": "A", "model_answer": ""}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-back policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2000"}], "answerKey": "A", "model_answer": ""}
{"question": "In which of the following representations of numbers by 8-bit words is the addition of the integers 109 and -42 within range?\nI. One's complement\nII. Two's complement\nIII. Sign and magnitude", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: To add 109 and -42 using sign and magnitude, you would first separate the numbers into their signed and magnitude parts.\n109 has a magnitude of 109 and a sign of +.\n-42 has a magnitude of -42 and a sign of -.\nTo add the signed numbers, you would use the rules:\n\u2022 A + B = A if A's sign is greater than B's sign.\n\u2022 A + B = B + A if A's sign is less than B's sign.\n\u2022 A + 0 = A.\n\u2022 0 + A = A.\nApply these rules to the two signed numbers:\n+ + -42.\n-109.\nSo, the sum of 109 and -42 is -109.\nTo check this sum within range, compare it to the original numbers.\n109 is within range.\n-42 is within range.\nSo, the sum of 109 and -42 is within range."}
{"question": "If a malicious process is granted temporary administrator-level access to a system", "choices": [{"label": "A", "text": "the threat is over as soon as the process is killed"}, {"label": "B", "text": "the threat is over after the operating system is rebooted"}, {"label": "C", "text": "the thread is over after rebooting the machine and replacing files that show a virus infection"}, {"label": "D", "text": "the threat is often permanent until the entire disk is wiped clean"}], "answerKey": "D", "model_answer": "LECTURE: Malicious processes that are granted temporary administrator-level access to a system are called \"privileged\" or \"elevated\" threads. These threads can do serious harm to the system, including stealing passwords, deleting files, and installing other harmful programs.\nA process with elevated privileges can do almost anything it wants on a computer. It can read, change, or delete data, and it can install software. It has the power to make the computer do things it should not do.\nSome malicious processes are designed to run in the background and will not stop until the system is rebooted. A malicious process can continue to run even after the system is turned off."}
{"question": "Which of the following statements about horizontal versus vertical microarchitecture is (are) true?\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nII. Horizontal microinstructions are unencoded.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: Microarchitecture is the way a computer's architecture is implemented. It tells you about the ways the various parts of the computer interact with each other.\nSome of the ways that computer architectures can differ include the way they use memory, the way they handle the flow of data, and the way they execute instructions. These differences are called the architecture's microarchitecture.\nSOLUTION: Look at the ways that horizontal and vertical microarchitecture are different:\nIn horizontal microarchitecture, programs have multiple opcodes and multiple operands. This means that a single instruction can perform different operations on different data.\nIn vertical microarchitecture, programs have a single opcode and multiple operands. This means that a single instruction can perform a single operation on multiple data elements.\nSo, the second statement is true. Horizontal microinstructions are unencoded. This means that the opcode is not included in the instruction's byte pattern.\nThe first statement is false. The number of time steps does not affect the way a program is encoded.\nThe third statement is true. Horizontal microinstructions usually have a single opcode and multiple operand specifiers. This means that a single instruction can perform different operations on different data."}
{"question": "A \"strictly binary tree\" is a binary tree in which every node that is not a leaf has two children. Suppose that for a class of strictly binary trees there exists c > 0 such that, for any tree in the class, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. Which of the following best characterizes the height h of any tree in this class, where N is the number of nodes in the tree and N > 1 ?", "choices": [{"label": "A", "text": "h <= log2(N)"}, {"label": "B", "text": "h = 1/c * log2(N)"}, {"label": "C", "text": "h < c log2(N)"}, {"label": "D", "text": "h > c log2(N)"}], "answerKey": "C", "model_answer": ""}
{"question": "Which of the following sorting algorithms has average-case and worst-case running times of O(n log n)?", "choices": [{"label": "A", "text": "Bubble sort"}, {"label": "B", "text": "Insertion sort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "C", "model_answer": ""}
{"question": "Consider the following equations concerning a stack module that has the operations Push, Pop, Top, and IsEmpty. Which of the equations does NOT represent the conventional semantics of a stack?", "choices": [{"label": "A", "text": "IsEmpty(Push(Stack,Elem)) = true"}, {"label": "B", "text": "Pop(Push(Stack,Elem)) = Stack"}, {"label": "C", "text": "Top(Push(Stack,Elem)) = Elem"}, {"label": "D", "text": "IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false"}], "answerKey": "A", "model_answer": "LECTURE: Equations that describe the behavior of a stack module are as follows:\nFor each element E and for each function F:\nPush(Stack, E) \u21a6 F(E)\nPop(Stack) \u21a6 the element on top of the stack\nTop(Stack) \u21a6 the element on top of the stack\nIsEmpty(Stack) \u21a6 false\nThese equations make up the conventional semantics of a stack.\nAn equation does not represent the conventional semantics of a stack if it allows the stack to be changed in a way that does not obey the order of the operations.\nFor example, the equation IsEmpty(Push(Stack,Elem)) = true does not represent the conventional semantics of a stack. This equation allows the stack to be emptied immediately after it is pushed."}
{"question": "Assume that any assignment statement can be executed in unit time. If as many identical processors as needed are used, what is the minimum number of time units needed to execute the assignments\nA := B + C\nB := A - B\nC := A * E\nD := A/F\nE := B - C\nF := A + B\nwith the same result as if the assignments were executed in the order shown?", "choices": [{"label": "A", "text": "1"}, {"label": "B", "text": "2"}, {"label": "C", "text": "3"}, {"label": "D", "text": "4"}], "answerKey": "C", "model_answer": "LECTURE: In computer programming, a sequence of instructions is said to execute in less time than another sequence of instructions. This means that the shorter sequence always takes less time to execute.\nIf the two sequences of instructions have the same result, then the shorter sequence is said to be more efficient.\nSOLUTION: The assignments can be executed in the order shown in 1 unit of time.\nFirst, B is updated. Then, A is updated. Finally, C is updated."}
{"question": "Two expressions E and F are said to be unifiable if there are substitutions for the variables of E and F that make the expressions lexically identical. In the following three expressions, only w, x, y, and z are variables.\nI. f(w,w)\nII. f(x,1)\nIII. f(y,g(z))\nWhich pairs of these expressions is (are) pairs of unifiable expressions?", "choices": [{"label": "A", "text": "(I, II) only"}, {"label": "B", "text": "(I, III) only"}, {"label": "C", "text": "(II, III) only"}, {"label": "D", "text": "(I, II) and (I, III) only"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following instruction-set features is NOT generally considered an obstacle to aggressive pipelining of an integer unit?", "choices": [{"label": "A", "text": "Condition codes set by every instruction"}, {"label": "B", "text": "Variable-length encoding of instructions"}, {"label": "C", "text": "Instructions requiring widely varying numbers of cycles to execute"}, {"label": "D", "text": "Several different classes (sets) of registers"}], "answerKey": "D", "model_answer": ""}
{"question": "Let k >= 2. Let L be the set of strings in {0, 1}^* such that x \\in L if and only if the number of 0's in x is divisible by k and the number of 1's in x is odd. The minimum number of states in a deterministic finite automaton (DFA) that recognizes L is", "choices": [{"label": "A", "text": "k + 2"}, {"label": "B", "text": "2k"}, {"label": "C", "text": "k log k"}, {"label": "D", "text": "k^2"}], "answerKey": "B", "model_answer": "LECTURE: The minimum number of states in a DFA that recognizes L is k + 2. This DFA has one state for each value of k, and each state has a transition on 0 and a transition on 1."}
{"question": "Let G = (V, E) be a finite directed acyclic graph with |E| > 0. Which of the following must be true?\nI. G has a vertex with no incoming edge.\nII. G has a vertex with no outgoing edge.\nIII. G has an isolated vertex, that is, one with neither an incoming edge nor an outgoing edge.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "D", "model_answer": "LECTURE: A graph is a collection of vertices and edges. A vertex is a point where two or more lines meet. An edge is a line that connects two vertices.\nA directed graph is a graph where each edge has a direction. The direction of an edge tells you the order of the vertices it connects.\nIf one vertex has no edges connecting to another vertex in a directed graph, then the second vertex is said to have no incoming edges from the first vertex.\nIf one vertex has no edges connecting from it in a directed graph, then the vertex is said to have no outgoing edges.\nSOLUTION: A graph has an isolated vertex if and only if the vertex has no incoming or outgoing edges.\nSo, G has an isolated vertex if and only if G has a vertex with no incoming edge and a vertex with no outgoing edge."}
{"question": "Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v. Let (u, v) be an edge in G that is not in T, such that pre(u) < pre(v). Which of the following statements about u and v must be true?\nI. post(u) < post(v)\nII. u is an ancestor of v in T.\nIII. If w is the lowest common ancestor of u and v in T, then w = u.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "LECTURE: Depth-first search orders vertices in a tree in a depth-first manner. That is, it first visits the leftmost vertex and then visits each successor in order.\nIf the tree is not a tree, but instead has a cycle, depth-first search orders the vertices in the cycle in the order they appear in the cycle.\nThink about the depth-first search tree of a connected undirected graph. The depth-first search tree contains a vertex of the original graph for each node in the tree. The vertex in the depth-first search tree that is in the same part of the original graph as the node is called a descendant of the node.\nA vertex in the depth-first search tree is a predecessor of a vertex if it is in the original graph and is a predecessor of the vertex in the depth-first search tree.\nA vertex in the depth-first search tree is a successor of a vertex if it is in the original graph and is a successor of the vertex in the depth-first search tree.\nSOLUTION: Let w be the lowest common ancestor of u and v in T. Then, w is a vertex in T that is a descendant of both u and v. So, pre(w) \u2265 pre(u) and pre(w) \u2265 pre(v).\nSince pre(u) < pre(v), pre(u) = k and pre(v) = k+1 for some k. Then, w is a predecessor of v in T.\nSo, v is a successor of w. Since w is the lowest common ancestor of u and v, u is a predecessor of w. So, u is a predecessor of v."}
{"question": "In systems with support for automatic memory management, a garbage collector typically has the responsibility for reclaiming allocated memory objects whose contents cannot affect any future legal computation. Such objects are identified by determining that they cannot be reached from a root set. Which of the following is NOT part of the root set in a typical garbage collector?", "choices": [{"label": "A", "text": "Actual parameters of the active procedures"}, {"label": "B", "text": "Dynamically allocated objects on the heap"}, {"label": "C", "text": "Global variables of the program"}, {"label": "D", "text": "Local variables on the call stack"}], "answerKey": "B", "model_answer": "LECTURE: In a typical garbage collector, the root set is the set of objects that are reachable from the entry point of the program. The root set includes the following objects:\nActual parameters of the active procedures.\nThe call stack.\nThe global variables of the program.\nThe local variables of the current procedure.\nThe dynamically allocated objects on the heap.\nSince the local variables of the call stack are part of the root set, they are not collected."}
{"question": "In the Internet Protocol (IP) suite of protocols, which of the following best describes the purpose of the Address Resolution Protocol?", "choices": [{"label": "A", "text": "To translate Web addresses to host names"}, {"label": "B", "text": "To determine the IP address of a given host name"}, {"label": "C", "text": "To determine the hardware address of a given host name"}, {"label": "D", "text": "To determine the hardware address of a given IP address"}], "answerKey": "D", "model_answer": ""}
{"question": "Which of the following language features requires that stack-based storage allocation be used rather than static allocation?", "choices": [{"label": "A", "text": "Recursive procedures"}, {"label": "B", "text": "Arbitrary goto's"}, {"label": "C", "text": "Two-dimensional arrays"}, {"label": "D", "text": "Integer-valued functions"}], "answerKey": "A", "model_answer": "LECTURE: Programs can use different ways to allocate storage. Some features of programming languages require certain allocation ways.\nStatic allocation: Storage is allocated when the program is loaded. Dynamically allocated storage can also be allocated and de-allocated during the program's execution.\nLinked storage: Storage is allocated one piece at a time. Pieces of storage that are not used by one part of the program can be reused by another part.\nStack-based allocation: Storage is allocated on a stack. Subroutines can be called and return in a stack-based environment."}
{"question": "Which of the following is not a sentence that is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z?", "choices": [{"label": "A", "text": "xyz"}, {"label": "B", "text": "xy"}, {"label": "C", "text": "xxzy"}, {"label": "D", "text": "xxxxy"}], "answerKey": "A", "model_answer": ""}
{"question": "Let T (n) be defined by T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1. Which of the following represents the order of growth of T(n) as a function of n?", "choices": [{"label": "A", "text": "\u0398(n)"}, {"label": "B", "text": "\u0398(n log n)"}, {"label": "C", "text": "\u0398(n^2)"}, {"label": "D", "text": "\u0398(n^2 log n)"}], "answerKey": "C", "model_answer": "LECTURE: The quantities \u0398(n), \u0398(n log n), and \u0398(n^2) are all rates of growth. \u0398(n) means that the function grows as fast as n. \u0398(n log n) means that the function grows as n log n. \u0398(n^2) means that the function grows as n^2.\nAn order of growth is a comparison of the rates of growth of two functions. One function grows at a slower rate than the other if its rate of growth is slower. For example, \u0398(n) is slower than \u0398(n log n) and \u0398(n^2).\nSOLUTION: We can use the definition of T(n) to find its order of growth:\nT(n) = 3n + T(1) = 3n + 7.\nSo, T(n) grows as 3n + 7. This is the same rate of growth as 3n. So, the order of growth of T(n) is \u0398(n)."}
{"question": "Which of the following problems is (are) decidable?\nI. Given a (finite) string w, is w a prefix of the decimal expansion of \u03c0?\nII. Given a program and an input, is the program\u2019s output the decimal expansion of \u03c0?\nIII. Given a program that takes as input a prefix of the decimal expansion of \u03c0, is the program\u2019s output always the same for every prefix?", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: In mathematics, a problem is decidable if its solution can be carried out by a computer. Whether a problem is decidable depends on the problem's rules and the available methods for solving the problem.\nA problem is solvable by a computer if it can be decided by a computer program. In other words, a problem is decidable if there is a computer program that will always finish running and return a correct solution for every input.\nSome problems are decidable but not solvable. For example, the problem of whether a given integer has a prime factor less than 2 is decidable: we can decide whether a number is prime. But the problem is not solvable: there is no way to find a prime number in the number.\nOther problems are not decidable. No computer program can decide whether a given integer is a prime number.\nSOLUTION: This problem is decidable. We can write a computer program to decide the problem.\nStep 1: Write a program to check if a string is a prefix of another string.\nStep 2: Write a program to calculate the decimal expansion of \u03c0.\nStep 3: Find a prefix of the decimal expansion of \u03c0.\nStep 4: Call the program to calculate the decimal expansion of \u03c0.\nStep 5: Call the program to check if the prefix is a prefix of the decimal expansion of \u03c0."}
{"question": "Which of the following statements about circuits is (are) true?\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nIII. Both sequential and combinational circuits must be controlled by an external clock.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: In a circuit, a combination of components can perform a task.\nA combinational circuit is a circuit in which the output depends only on the current input. In a combinational circuit, the output is determined by the current input and the wiring of the circuit.\nA sequential circuit is a circuit in which the output depends on the history of previous inputs and outputs. A sequential circuit has a memory of its own history.\nSOLUTION: The first statement is true. A combinational circuit may have feedback; a sequential circuit does not.\nA combinational circuit has a \"memoryless\" property; it does not depend on its own history.\nThe second statement is true.\nA combinational circuit has a \"memoryless\" property; it does not depend on its own history. A sequential circuit does have a history.\nThe third statement is false.\nA sequential circuit does not have to be controlled by an external clock. A clock signal is a series of pulses that resets the circuit and restarts the process. A sequential circuit can also use other signals to reset and restart the process."}
{"question": "Two single-user workstations are attached to the same local area network. On one of these workstations, file pages are accessed over the network from a file server; the average access time per page is 0.1 second. On the other of these workstations, file pages are accessed from a local disk; the average access time per page is 0.05 second. A particular compilation requires 30 seconds of computation and 200 file page accesses. What is the ratio of the total time required by this compilation if run on the diskless (file server) workstation to the total time required if run on the workstation with the local disk, if it is assumed that computation is not overlapped with file access?", "choices": [{"label": "A", "text": "1/1"}, {"label": "B", "text": "5/4"}, {"label": "C", "text": "5/3"}, {"label": "D", "text": "10/5"}], "answerKey": "B", "model_answer": "LECTURE: When you are given a problem involving calculations with ratios, think about how the ratio affects the calculation.\nIf the numerator and the denominator of a ratio are equal, then the ratio is 1.\nIf the denominator is greater than the numerator, then the ratio is greater than 1.\nIf the denominator is less than the numerator, then the ratio is less than 1.\nSOLUTION: To find the ratio of the total time required by the compilation if run on the diskless workstation to the total time required if run on the workstation with the local disk, consider the cofunction, which calculates the time required to complete a task.\nTime required by the compilation if run on the diskless workstation = Time required to compile + Time required to access file pages.\nTime required to access file pages is slower on the diskless workstation than on the workstation with the local disk.\nSo, Time required by the compilation if run on the diskless workstation is longer than Time required to access file pages on the workstation with the local disk.\nThere are 200 file page accesses in the compilation.\nThe diskless workstation takes 0.1 second to access each file page.\nThe workstation with the local disk takes 0.05 second to access each file page.\nSo, the diskless workstation takes 200 x 0.1 second = 20 second to access file pages.\nThe workstation with the local disk takes 200 x 0.05 second = 10 second to access file pages.\nThere are 30 seconds of computation in the compilation.\nThe diskless workstation takes 0 second to perform computation.\nThe workstation with the local disk takes 30 second to perform computation.\nSo, the diskless workstation takes 30 second to perform computation.\nThe ratio of the total time required by the compilation if run on the diskless workstation to the total time required if run on the workstation with the local disk is 30 second : 20 second = 5 : 4."}
{"question": "Assume that a debugger places a breakpoint at a load instruction at virtual address 0x77E81234 (hexadecimal notation) in a debugged process P. If the text segment of P begins at 0x77E80000 in P\u2019s virtual address space and if the debugger has mapped this same text segment at 0x01000000 in its virtual address space, which of the following is the virtual address used by the debugger in its WRITE operation, along with a description of how the debugger has mapped the virtual memory page containing this address?", "choices": [{"label": "A", "text": "0x01001234; page mapped with READ/WRITE access"}, {"label": "B", "text": "0x01001234; page mapped with COPY-ON-WRITE access"}, {"label": "C", "text": "0x76E81234; page mapped with READ/WRITE access"}, {"label": "D", "text": "0x76E81234; page mapped with COPY-ON-WRITE access"}], "answerKey": "A", "model_answer": ""}
{"question": "Which of the following considerations applies (apply) to choosing the page size in a paging system?\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "LECTURE: Paging is a memory management technique in which the operating system divides memory into fixed blocks, or pages, of a predetermined size.\nPages are used to track the locations of data and instructions in memory. When a program runs, it uses the CPU to access memory. The CPU uses the page numbers to help it find the desired data or instruction.\nThe size of a page affects the design of the page table, which is a data structure that maps page numbers to memory addresses. A larger page size leads to a smaller page table, which simplifies the page table and reduces the overhead of memory allocation.\nHowever, using smaller pages reduces internal fragmentation, which occurs when the available memory is not large enough to satisfy a process's memory requests. Smaller pages lead to fewer memory fragments, which can save memory."}
{"question": "Two processors, M-5 and M-7, implement the same instruction set. Processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. Processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds. Which of the following is (are) true?\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline.\nII. The latency of a single instruction is shorter on M-7\u2019s pipeline than on M-5\u2019s pipeline.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III"}, {"label": "D", "text": "II and III"}], "answerKey": "A", "model_answer": "LECTURE: Pipelining is a technique that is used to improve the performance of a processor. Pipelining allows a processor to do multiple things at the same time, but with some instructions or steps done concurrently.\nPipelining a processor does not make it go faster in terms of clock cycles. But, with pipelining, a processor can execute more instructions in a single clock cycle. This can make the processor appear to run faster.\nA processor with pipelining has multiple stages of execution. A new instruction is loaded into the first stage of the pipeline when a previous instruction is still in one of the later stages. The pipeline can be thought of as a series of interconnected tubes, with each tube stage representing a step in the instruction execution process.\nWhen the first stage of the pipeline is processing an instruction, the next instruction is loaded into the second stage. When the second stage is processing an instruction, the third stage is loaded with the next instruction, and so on.\nIf one of the stages of the pipeline is stalled (waits for some external event to complete), the entire pipeline must wait. If the pipeline is stalled for n stages, the processor must wait for n clock cycles before continuing.\nFor example, if the pipeline has 3 stages, and the second stage is stalled, the processor must wait 2 clock cycles before continuing.\nThe following is a diagram of a 4-stage pipeline. The instructions are loaded into the pipeline on the left side and are processed through the stages in the middle. The completed instructions are stored on the right side of the pipeline.\nThe five pipelined processors have different numbers of stages in their pipelines. The latency of a single instruction is shorter on the 5-stage pipeline than on the other pipelines. The maximum throughput of the 5-stage pipeline is also 5.\nA 7-stage pipeline has more stages than a 5-stage pipeline. So, the latency of a single instruction is longer on the 7-stage pipeline. The maximum throughput of the 7-stage pipeline is also 7.\nSOLUTION: M-7's pipeline has more stages than M-5's pipeline. So, the instructions are being processed for one more stage in M-7's pipeline. This means that the latency of a single instruction is shorter on M-7's pipeline than on M-5's pipeline.\nThe maximum throughput of a pipeline is the number of instructions that can be executed in a single clock cycle. There are 7 stages in M-7's pipeline, but only 5 stages in M-5's pipeline. So, the maximum throughput of M-7's pipeline is 7, and the maximum throughput of M-5's pipeline is 5."}
{"question": "Which of the following pairs of 8-bit, two's-complement numbers will result in overflow when the members of the pairs are added?", "choices": [{"label": "A", "text": "11111111, 00000001"}, {"label": "B", "text": "00000001, 10000000"}, {"label": "C", "text": "11111111, 10000001"}, {"label": "D", "text": "10000001, 10101010"}], "answerKey": "D", "model_answer": ""}
{"question": "Two computers communicate with each other by sending data packets across a local area network. The size of these packets is 1,000 bytes. The network has the capacity to carry 1,000 packets per second. The CPU time required to execute the network protocol to send one packet is 10 milliseconds. The maximum rate at which one computer can send data to another is approximately", "choices": [{"label": "A", "text": "10,000 bytes/second"}, {"label": "B", "text": "25,000 bytes/ second"}, {"label": "C", "text": "100,000 bytes/ second"}, {"label": "D", "text": "500,000 bytes/ second"}], "answerKey": "C", "model_answer": ""}
{"question": "Consider the following grammar.\nS \u2192 ( S )\nS \u2192 x\nWhich of the following statements is (are) true?\nI. The grammar is ambiguous.\nII. The grammar is suitable for top-down parsing.\nIII. The grammar is suitable for bottom-up parsing.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "LECTURE: In a top-down parser, the parser starts with the goal and works its way down to the start symbol. In a bottom-up parser, the parser starts with the start symbol and works its way up to the goal.\nA grammar is suitable for top-down parsing if the start symbol has no rules.\nA grammar is suitable for bottom-up parsing if the start symbol has one or more rules.\nSOLUTION: The grammar is suitable for bottom-up parsing. The start symbol, S, has one or more rules."}
{"question": "Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT:", "choices": [{"label": "A", "text": "Counting distinct values: Given a set of n keys, determine the number of distinct key values."}, {"label": "B", "text": "Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary."}, {"label": "C", "text": "Range search: Given values a and b, find all the records whose key value is in the range a, b."}, {"label": "D", "text": "Symbol table lookup: Given a program identifier, find its type and address."}], "answerKey": "C", "model_answer": ""}
{"question": "Let A be a finite set with m elements, and let B be a finite set with n elements. The number of distinct functions mapping A into B is", "choices": [{"label": "A", "text": "n^m"}, {"label": "B", "text": "n!/(n - m)!"}, {"label": "C", "text": "n!"}, {"label": "D", "text": "n!/(m!(n - m)!)"}], "answerKey": "A", "model_answer": ""}
{"question": "To compute the matrix product M_1M_2, where M_1 has p rows and q columns and where M_2 has q rows and r columns, takes time proportional to pqr, and the result is a matrix of p rows and r columns. Consider the product of three matrices N_1N_2N_3 that have, respectively, w rows and x columns, x rows and y columns, and y rows and z columns. Under what condition will it take less time to compute the product as (N_1N_2)N_3 (i.e., multiply the first two matrices first) than to compute it as N_1(N_2 N_3)?", "choices": [{"label": "A", "text": "There is no such condition; i.e., they will always take the same time."}, {"label": "B", "text": "1/x + 1/z < 1/w + 1/y"}, {"label": "C", "text": "x > y"}, {"label": "D", "text": "1/w + 1/x < 1/y + 1/z"}], "answerKey": "B", "model_answer": ""}
{"question": "The hit ratio of a cache memory is the percentage of accesses (reads and writes) for which data are found in the cache. Write-through is a policy whereby every write operation updates main memory. Write-back is a policy whereby a write operation to a line found in the cache does not affect main memory until the line is evicted from the cache. Write-allocation is a policy whereby a cache line is allocated and loaded on a write-miss. If it is assumed that write-allocation is always used, which of the following is true?", "choices": [{"label": "A", "text": "Write-back usually results in a better hit ratio than write-through."}, {"label": "B", "text": "Write-through usually results in a better hit ratio than write-back."}, {"label": "C", "text": "The percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through."}, {"label": "D", "text": "The percentage of write operations resulting in a main memory operation will never be larger for writethrough than for write-back."}], "answerKey": "C", "model_answer": ""}
{"question": "A particular disk unit uses a bit string to record the occupancy or vacancy of its tracks, with O denoting vacant and 1 denoting occupied. A 32-bit segment of this string has the hexadecimal value D4FE2003. The percentage of occupied tracks for the corresponding part of the disk, to the nearest percent, is", "choices": [{"label": "A", "text": "12%"}, {"label": "B", "text": "25%"}, {"label": "C", "text": "38%"}, {"label": "D", "text": "44%"}], "answerKey": "D", "model_answer": "LECTURE: A 32-bit segment of a disk unit's bit string has the hexadecimal value D4FE2003.\nEach hexadecimal number has two parts. The first part is as many digits as necessary to make the number between 0 and 16. The second part is as many digits as necessary to make the number between 0 and 16. For example, the hexadecimal number 0x53 has a first part of 0x5 and a second part of 0x3.\nSOLUTION: To find the percentage of occupied tracks, convert the 32-bit segment to a decimal number, then divide the decimal number by 32 and multiply by 100 to find the percentage.\nThe 32-bit segment is D4FE2003.\nConvert the 32-bit segment to a decimal number by first converting the hexadecimal numbers to decimal numbers.\nThe result is 670352803.\nDivide the decimal number by 32 to get 20628.\nMultiply the result by 100 to get 20.63.\nThe percentage of occupied tracks is 20.63%."}
{"question": "An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. Which of the following undirected graphs must have an Euler circuit?\nI. A complete graph with 12 vertices\nII. A complete graph with 13 vertices\nIII. A tree with 13 vertices", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "B", "model_answer": "LECTURE: An undirected graph is a tree if it is not connected and has no cycle.\nA graph is a complete graph if each vertex is connected to every other vertex.\nSOLUTION: A complete graph with 12 vertices is a tree. It is not possible to connect 12 vertices to each other without creating a cycle.\nA complete graph with 13 vertices is a tree. It is not possible to connect 13 vertices to each other without creating a cycle.\nA graph with 13 vertices and an Euler circuit must have 13 vertices and 12 edges. It is not possible to add an Euler circuit to a tree with 13 vertices."}
{"question": "Which of the following characteristics of a programming language is best specified using a context-free grammar?", "choices": [{"label": "A", "text": "Identifier length"}, {"label": "B", "text": "Maximum level of nesting"}, {"label": "C", "text": "Operator precedence"}, {"label": "D", "text": "Type compatibility"}], "answerKey": "C", "model_answer": "LECTURE: A programming language is a set of instructions written in a formal language that is used to create software. A programming language may have the following characteristics:\nFormal language: A programming language is a formal language, which means that it has a precise and well-defined syntax.\nType: A programming language may be a high-level language or a low-level language.\nHigh-level language: A high-level language is a language that is easier to write and read. It may use more abstract symbols to represent actions, or it may use natural language words. High-level languages are typically used to write application software.\nLow-level language: A low-level language is a language that is more difficult to write and read. It may use more complex symbols to represent actions. Low-level languages are typically used to write system software.\nType compatibility: The compatibility of types in a programming language means that some values can be used in multiple ways. For example, in a language with type compatibility, an integer value can be used as a boolean value.\nOperator precedence: The precedence of an operator in a programming language determines the order in which operators are evaluated. For example, in a language with a high precedence for multiplication, the multiplication of a number by a binary value will be evaluated before the multiplication of a decimal value by a different binary value."}
{"question": "Which of the following statements about datagrams sent by a node in a network using IPv4 protocol is (are) true?\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nIII. Datagrams are reassembled only at the destination.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "LECTURE: Datagram: A datagram is a block of data that is sent over a network. A datagram is sent from one host to another.\nWhen a datagram is sent, it is broken into smaller pieces called packets. A packet is a piece of a datagram. A packet is sent from one host to another host.\nThe packets that make up a datagram may take different paths through the network. The packets may also be sent at different times. But the datagram is put back together in the correct order at the destination.\nIP version 4 (IPv4) is the fourth version of the Internet Protocol. It is the most widely used version of the Internet Protocol.\nIPv4 specifies that a datagram must not be larger than 65,535 bytes.\nThe link is the connection between two hosts on a network. The maximum transmission unit (MTU) is the size of a packet that a link can transmit.\nA datagram must be the size of the smallest MTU of all the links on a path to the destination. This is because larger datagrams cannot be transmitted over smaller MTUs.\nA datagram may be fragmented during routing. This means that the datagram is broken into smaller packets that can be transmitted over the links in the network. The packets are then reassembled at the destination."}
{"question": "A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. Which of the following job-scheduling policies is starvation-free?", "choices": [{"label": "A", "text": "Round-robin"}, {"label": "B", "text": "Priority queuing"}, {"label": "C", "text": "Shortest job first"}, {"label": "D", "text": "Youngest job first"}], "answerKey": "A", "model_answer": "LECTURE: In a computer system with multiple processes or jobs, the job-scheduling policy is a set of rules that determines how the system selects and orders jobs to be executed. Different job-scheduling policies have different priorities and strategies.\nRound-robin is a scheduling policy that selects the next job to run by cycling through all the jobs in a first-come, first-served order. If some of the jobs are still running when it is their turn, the scheduler will wait for each job to finish before selecting the next job.\nPriority queuing is a scheduling policy that orders jobs by their priority. A job with a higher priority will be selected for execution before a job with a lower priority.\nShortest job first is a scheduling policy that orders jobs by their estimated length. A job with the shortest estimated length will be selected for execution first.\nYoungest job first is a scheduling policy that orders jobs by the time they were started. A job that was started first will be selected for execution next.\nSOLUTION: To decide whether a job-scheduling policy is starvation-free, consider what happens when there are only two jobs, and one job is smaller and shorter than the other job.\nWith a shortest job first policy, the smaller job will be selected for execution first. These smaller jobs will eventually finish, and then the larger jobs will run to completion.\nWith a youngest job first policy, the younger job will be selected for execution next. These younger jobs will never finish, because they will always be replaced by older jobs. This policy is not starvation-free.\nWith a round-robin policy, the smaller jobs will be selected for execution first. These smaller jobs will eventually finish, and then the larger jobs will run to completion.\nWith a priority queuing policy, the smaller jobs will be selected for execution first. These smaller jobs will eventually finish, and then the larger jobs will run to completion.\nSo, the shortest job first policy is starvation-free."}
{"question": "Of the following, which gives the best upper bound for the value of f(N) where f is a solution to the recurrence f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0?", "choices": [{"label": "A", "text": "O(log N)"}, {"label": "B", "text": "O(N log N)"}, {"label": "C", "text": "O(log N) + 0(1)"}, {"label": "D", "text": "O((log N)^2)"}], "answerKey": "D", "model_answer": "LECTURE: A recurrence is a closed-form formula that defines a sequence in terms of one or more previous terms. Recurrences with constant coefficients are usually solvable by explicit formula.\nf(2N + 1) = f(2N) = f(N) + log N, for N \u2265 1, with f(1) = 0.\nSOLUTION: This recurrence can be solved using an iterative formula. Let g(N) = f(N) + log N. Then, g(N) satisfies the recurrence:\ng(2N + 1) = g(2N), for N \u2265 1.\nThis recurrence has a solution of g(N) = O(log N).\nSo, f(N) = g(N) + 0 = O(log N)."}
{"question": "Company X shipped 5 computer chips, 1 of which was defective, and Company Y shipped 4 computer chips, 2 of which were defective. One computer chip is to be chosen uniformly at random from the 9 chips shipped by the companies. If the chosen chip is found to be defective, what is the probability that the chip came from Company Y?", "choices": [{"label": "A", "text": "2 / 9"}, {"label": "B", "text": "4 / 9"}, {"label": "C", "text": "1 / 2"}, {"label": "D", "text": "2 / 3"}], "answerKey": "D", "model_answer": "LECTURE: A company needs to ship 500 boxes of toys to its customers. The company has two factories that can make the boxes. One factory can make 200 boxes per day. The other factory can make 300 boxes per day. How many days will it take for the company to ship all the boxes?"}
{"question": "Which of the following problems can be solved by a standard greedy algorithm?\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights\nII. Finding a maximum clique in an undirected graph\nIII. Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "LECTURE: A graph is a set of nodes connected by edges.\nA flow is a way to assign a number to each edge in a graph. A maximum flow is a way to assign a number to each edge in a graph such that the sum of the numbers assigned to the edges leaving a node is less than or equal to the number assigned to the node.\nA clique is a set of nodes in a graph such that each node is connected to every other node in the set.\nA greedy algorithm is an algorithm that makes the locally optimal choice at each step.\nA standard greedy algorithm is a greedy algorithm that makes the locally optimal choice among the remaining options.\nSOLUTION: A standard greedy algorithm can solve the following problem:\nFinding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities.\nTo do this, perform the following steps:\n1. For each edge in the graph, assign a value to the edge based on the maximum flow from the source node to the edge. Assign a value of 0 to all edges with a capacity of 0.\n2. For each edge in the graph, increment the value of the edge by the amount of the edge's capacity that is left over after the flow has passed through the edge.\n3. The maximum flow from the source node to the sink node is the value of the sink node.\nA standard greedy algorithm cannot solve the following problem:\nFinding a minimum spanning tree in an undirected graph with positive-integer edge weights.\nTo do this, you need to find a way to choose which edges to include in the minimum spanning tree. This is difficult to do with a standard greedy algorithm, which always chooses the best available option.\nA standard greedy algorithm also cannot solve the following problem:\nFinding a maximum clique in an undirected graph.\nTo do this, you need to find a way to choose which nodes to include in the maximum clique. This is difficult to do with a standard greedy algorithm, which always chooses the best available option."}
{"question": "A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined. Which of the following is (are) correct?\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "LECTURE: A hash table is a data structure that allows you to store and access items (known as keys) in a way that is similar to a dictionary.\nA hash table uses a hash function to map a key to an index in an array. The index where the key is stored is called the hash code. The hash code is used to access the value that is associated with the key.\nIf one key is changed, its hash code may be different from the original hash code. This means that the value associated with the key may be accessed using a different index.\nSOLUTION: To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined.\nTrue means the word was in the dictionary. Each entry in the hash table is a Boolean variable initialized to false. When a word is in the dictionary, the appropriate entry in the hash table is set to true.\nFalse means the word was not in the dictionary. Each entry in the hash table is a Boolean variable initialized to false. When a word is not in the dictionary, the appropriate entry in the hash table is not changed.\nHash table size should increase with document size. As the number of words in a document increases, it becomes more likely that the hash table will need to be expanded. A larger hash table can hold more entries, so it is more likely to have room to grow."}
{"question": "One approach to handling fuzzy logic data might be to design a computer using ternary (base-3) logic so that data could be stored as \u201ctrue,\u201d \u201cfalse,\u201d and \u201cunknown.\u201d If each ternary logic element is called a flit, how many flits are required to represent at least 256 different values?", "choices": [{"label": "A", "text": "4"}, {"label": "B", "text": "5"}, {"label": "C", "text": "6"}, {"label": "D", "text": "7"}], "answerKey": "C", "model_answer": "LECTURE: Fuzzy logic allows for the representation of uncertainty and gradual transition between values. A fuzzy set is a set of values that is defined by its membership grades. The membership grades assign a degree of membership to each value in the set. The degree of membership can range from 0 to 1, with 0 meaning the value is not a member of the set and 1 meaning the value is a perfect member of the set.\nFor example, the fuzzy set 'tall' for humans can be defined by its membership grades:\n0.001.\nThis set has two values, 1.0 and 0.001. The value 1.0 is a perfect member of the set, and the value 0.001 is a member of the set with a degree of membership of 0.001.\nThe fuzzy set 'leCTURE: Fuzzy logic allows for the representation of uncertainty and gradual transition between values. A fuzzy set is a set of values that is defined by its membership grades. The membership grades assign a degree of membership to each value in the set. The degree of membership can range from 0 to 1, with 0 meaning the value is not a member of the set and 1 meaning the value is a perfect member of the set.\nFor example, the fuzzy set 'tall' for humans can be defined by its membership grades:\n0.001.\nThis set has two values, 1.0 and 0.001. The value 1.0 is a perfect member of the set, and the value 0.001 is a member of the set with a degree of membership of 0.001.\nThe fuzzy set 'FALSE' for flits can be defined by its membership grades:\n0.0.\nThis set has two values, 0.0 and 1.0. The value 1.0 is a perfect member of the set 'TRUE', and the value 0.0 is a perfect member of the set 'FALSE'.\nSOLUTION: To represent at least 256 different values, you need at least 256 membership grades. This means you need 5 membership grades.\nEach ternary logic element is called a flit. So, 5 membership grades require 5 flits."}
{"question": "Local caching of files is common in distributed file systems, but it has the disadvantage that", "choices": [{"label": "A", "text": "Temporary inconsistencies among views of a file by different machines can result"}, {"label": "B", "text": "The file system is likely to be corrupted when a computer crashes"}, {"label": "C", "text": "A much higher amount of network traffic results"}, {"label": "D", "text": "Caching makes file migration impossible"}], "answerKey": "A", "model_answer": "LECTURE: In a distributed file system, different machines may have different copies of a file. Each copy of a file is called a view of the file.\nWhen a file is cached, a local copy of the file is placed in the cache. If multiple machines have the same view of a file in their caches, a change to the file will not be immediately reflected in the other machines' copies of the file. This can lead to temporary inconsistencies among the different views of the file."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-through policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2048"}], "answerKey": "C", "model_answer": ""}
{"question": "At time 0, five jobs are available for execution on a single processor, with service times of 25, 15, 5, 3, and 2 time units. Which of the following is the minimum value of the average completion time of these jobs?", "choices": [{"label": "A", "text": "50"}, {"label": "B", "text": "208/5"}, {"label": "C", "text": "92/5"}, {"label": "D", "text": "10"}], "answerKey": "C", "model_answer": "LECTURE: The average completion time of a group of jobs is the time it takes to run all the jobs. The average completion time is equal to the sum of the completion times of all the jobs divided by the total number of jobs.\nIf there are m jobs and they have completion times c1, c2, ..., cm, then the average completion time is:\naverage completion time = c1 + c2 + ... + cm.\nSOLUTION: To find the minimum value of the average completion time of the five jobs, add up the completion times of all the jobs and divide the sum by the total number of jobs.\nThe completion times of the jobs are 25, 15, 5, 3, and 2. So, the sum of the completion times is 25 + 15 + 5 + 3 + 2 = 55.\nThe total number of jobs is 5. So, the minimum value of the average completion time is 55/5 = 11."}
{"question": "Let G = (V, E) be a connected, undirected graph, and let a and b be two distinct vertices in V. Let P_1 be the problem of finding a shortest simple path between a and b, and let P_2 be the problem of finding a longest simple path between a and b. Which of the following statements about P_1 and P_2 is true?", "choices": [{"label": "A", "text": "Both P_1 and P_2 can be solved in polynomial time."}, {"label": "B", "text": "P_1 can be solved in polynomial time but P_2 is not known to be solvable in polynomial time."}, {"label": "C", "text": "P_1 is not known to be solvable in polynomial time but P_2 can be solved in polynomial time."}, {"label": "D", "text": "It is not known whether either P_1 or P_2 can be solved in polynomial time."}], "answerKey": "B", "model_answer": ""}
{"question": "A major advantage of direct mapping of a cache is its simplicity. The main disadvantage of this organization is that", "choices": [{"label": "A", "text": "it does not allow simultaneous access to the intended data and its tag"}, {"label": "B", "text": "it is more expensive than other types of cache organizations"}, {"label": "C", "text": "the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache"}, {"label": "D", "text": "its access time is greater than that of other cache organizations"}], "answerKey": "C", "model_answer": ""}
{"question": "Let M be a single-tape, deterministic Turing machine with tape alphabet {blank,0,1}, and let C denote the (possibly infinite) computation of M starting with a blank tape. The input to each problem below is M, together with a positive integer n. Which of the following problems is (are) decidable?\nI. The computation C lasts for at least n steps.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nIII. M scans at least n distinct tape squares during the computation C.", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "D", "model_answer": "LECTURE: A Turing machine is a mathematical model of a computer. It has three parts: a tape, which can be divided into cells; a tape head, which can read and write cells on the tape; and a control mechanism, which dictates the tape head's behavior.\nTo make a copy of a Turing machine, use the following procedure:\n1. Make a new Turing machine that is identical to the original in every way.\n2. Interrupt the new Turing machine after the first step of computation.\n3. Configure the new Turing machine to mimic the original Turing machine's second computation step.\n4. Repeat steps 2 and 3 n times to make the new Turing machine simulate the original machine's first n steps of computation.\n5. After the new Turing machine has completed its simulations of the original machine's first n steps of computation, interrupt the new Turing machine and configure it to mimic the original machine's remaining steps of computation.\nThe new Turing machine will have executed the same computation as the original machine.\nSOLUTION: To decide whether the computation C of M lasts for at least n steps, M can scan at least n distinct tape squares during the computation C, and M prints a 1 at some point after the nth step, look at the first n cells and the nth cell. If the nth cell is a 1, then the computation C lasts for at least n steps. If the nth cell is a blank, then M scans at least n distinct tape squares during the computation C. If the nth cell is a 0, then the computation C does not last for at least n steps."}
{"question": "A 3-way, set-associative cache is", "choices": [{"label": "A", "text": "one in which each main memory word can be stored at any of 3 cache locations"}, {"label": "B", "text": "effective only if 3 or fewer processes are running alternately on the processor"}, {"label": "C", "text": "possible only with write-back"}, {"label": "D", "text": "faster to access than a direct-mapped cache"}], "answerKey": "A", "model_answer": ""}
{"question": "Consider an object-oriented language in which all entities are objects. Two relationships arise: (1) the instance relationship, between an object and the class of which that object is a member, and (2) the subclass relationship, between a class and the superclass from which that class inherits properties. In such a language, when a message is sent to an object requesting execution of one of its methods (procedures), the method is located by following", "choices": [{"label": "A", "text": "one instance link and then zero or more subclass links"}, {"label": "B", "text": "one or more instance links and then one or more subclass links"}, {"label": "C", "text": "one or more instance links"}, {"label": "D", "text": "one subclass link and then one or more instance links"}], "answerKey": "A", "model_answer": "LECTURE: In an object-oriented language, all entities are objects. An object is an instance of a class. A class is a template for creating objects.\nA class defines the data and methods that are common to all objects of that class. An object is an instance of a class. An instance of a class is a separate object that has its own data.\nWhen a message is sent to an object, the object's method is located by following the links from the object to its class. The links are formed by the instance relationship and the subclass relationship.\nThere are two types of links: instance links and subclass links.\nAn instance link connects an object to its class. An object is an instance of a class.\nA subclass link connects a class to its superclass. A class is a subclass of its superclass.\nWhen a message is sent to an object, the link is followed from the object to its class. The link is followed from the class to its superclass, and so on, until the desired method is found.\nSOLUTION: To locate a method when a message is sent to an object, follow the instance links from the object to its class.\nWhen a message is sent to an object, the method is located by following one or more instance links from the object to its class."}
{"question": "In a pipelined RISC computer where all arithmetic instructions have the same CPI (cycles per instruction), which of the following actions would improve the execution time of a typical program?\nI. Increasing the clock cycle rate\nII. Disallowing any forwarding in the pipeline\nIII. Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "D", "model_answer": "LECTURE: In a pipelined RISC computer, the clock cycle rate is the rate at which the clock signal changes state. The clock cycle rate determines the speed of the computer.\nThe clock cycle rate is set by the clock rate. The clock rate is the rate at which the clock signal changes state.\nIf the clock rate is increased, the clock cycle rate increases. The pipelined RISC computer can execute more instructions per second.\nThe sizes of the instruction cache and the data cache determine how much of the instruction and data are stored in the caches. The sizes of the caches affect the amount of time it takes to access the instructions and data.\nIf the sizes of the caches are doubled, the amounts of the instructions and data that can be stored in the caches are increased. The pipelined RISC computer can access more instructions and data from the caches."}
{"question": "A microcomputer used for data acquisition and control is required to digitize and process four analog input signals and to output their average continually; i.e., in real time. The time for an external analog-to-digital converter (which is triggered by a CPU instruction) to digitize one input is 12 microseconds, and only one digitization occurs at a time. Five CPU instructions, including the triggering instruction, must be executed for each signal digitized. Ten CPU instructions are executed in order to average each set of four samples and output this value. The time to convert the output from digital to analog form is to be ignored. If it is assumed that suitable data buffering is employed, then the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates, is", "choices": [{"label": "A", "text": "0.8 microseconds"}, {"label": "B", "text": "1.2 microseconds"}, {"label": "C", "text": "1.6 microseconds"}, {"label": "D", "text": "2.4 microseconds"}], "answerKey": "C", "model_answer": "LECTURE: To digitize an analog signal, the signal must be converted from analog to digital form. This process is called digitization.\nThe analog-to-digital converter (ADC) is the part of the microcomputer that performs the digitization. The ADC takes a sample of the analog signal and converts it to a digital value.\nThere are many kinds of ADCs, but most ADCs use one of two types of conversion:"}
{"question": "Suppose that a certain software product has a mean time between failures of 10,000 hours and has a mean time to repair of 20 hours. If the product is used by 100 customers, what is its availability?", "choices": [{"label": "A", "text": "80%"}, {"label": "B", "text": "90%"}, {"label": "C", "text": "98%"}, {"label": "D", "text": "99.80%"}], "answerKey": "D", "model_answer": ""}
