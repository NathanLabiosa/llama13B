{"question": "The access matrix approach to protection has the difficulty that", "choices": [{"label": "A", "text": "the matrix, if stored directly, is large and can be clumsy to manage"}, {"label": "B", "text": "it is not capable of expressing complex protection requirements"}, {"label": "C", "text": "deciding whether a process has access to a resource is undecidable"}, {"label": "D", "text": "there is no way to express who has rights to change the access matrix itself"}], "answerKey": "A", "model_answer": "The correct answer is (A) the matrix, if stored directly, is large and can be clumsy to manage."}
{"question": "An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y. Which of the following sets of integers could possibly be the set of all common divisors of two integers?", "choices": [{"label": "A", "text": "{-6,-2, -1, 1, 2, 6}"}, {"label": "B", "text": "{-6, -2, -1, 0, 1, 2, 6}"}, {"label": "C", "text": "{-6, -3, -2, -1, 1, 2, 3, 6}"}, {"label": "D", "text": "{-6, -3, -2, -1, 0, 1, 2, 3, 6}"}], "answerKey": "C", "model_answer": "The correct answer is (A) {-6,-2, -1, 1, 2, 6}.\nThe given statement is: \"An integer c is a common divisor of two integers x and y if and only if c is a divisor of x and c is a divisor of y.\"\nThe first condition states that c is a divisor of x, which means that x/c = z, for some integer z.\nThe second condition states that c is a divisor of y, which means that y/c = z', for some integer z'.\nSince c is a common divisor of x and y, it must be a divisor of x AND a divisor of y. Therefore, the set of all common divisors of two integers must be the set of all integers that are divisors of both integers.\nThe statement is using the logical \"if and only if\" statement, which means that the set of all common divisors is the set of all integers that are divisors of x AND the set of all integers that are divisors of y.\nUsing this information, we can eliminate choices (B) and (C), as they do not satisfy the first condition that c is a divisor of x"}
{"question": "In the NoNicks operating system, the time required by a single file-read operation has four nonoverlapping components:\ndisk seek time-25 msec\ndisk latency time-8 msec\ndisk transfer time- 1 msec per 1,000 bytes\noperating system overhead-1 msec per 1,000 bytes + 10 msec\nIn version 1 of the system, the file read retrieved blocks of 1,000 bytes. In version 2, the file read (along with the underlying layout on disk) was modified to retrieve blocks of 4,000 bytes. The ratio of-the time required to read a large file under version 2 to the time required to read the same large file under version 1 is approximately", "choices": [{"label": "A", "text": "1:4"}, {"label": "B", "text": "1:3.5"}, {"label": "C", "text": "1:1"}, {"label": "D", "text": "1.1:1"}], "answerKey": "B", "model_answer": "The correct answer is (C) 1:1. The ratio of the time required to read a large file under version 2 to the time required to read the same large file under version 1 is 1:1, not 1:4, 1:3.5, or 1.1:1. The available choices are not equivalent to this ratio.\nThe correct answer is 1:1."}
{"question": "You want to cluster 7 points into 3 clusters using the k-Means Clustering algorithm. Suppose after the first iteration, clusters C1, C2 and C3 contain the following two-dimensional points: C1 contains the 2 points: {(0,6), (6,0)} C2 contains the 3 points: {(2,2), (4,4), (6,6)} C3 contains the 2 points: {(5,5), (7,7)} What are the cluster centers computed for these 3 clusters?", "choices": [{"label": "A", "text": "C1: (3,3), C2: (4,4), C3: (6,6)"}, {"label": "B", "text": "C1: (3,3), C2: (6,6), C3: (12,12)"}, {"label": "C", "text": "C1: (6,6), C2: (12,12), C3: (12,12)"}, {"label": "D", "text": "C1: (0,0), C2: (48,48), C3: (35,35)"}], "answerKey": "A", "model_answer": "The correct answer is: (D) C1: (0,0), C2: (48,48), C3: (35,35)"}
{"question": "Any set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. Which of the following is NOT complete?", "choices": [{"label": "A", "text": "{AND, NOT}"}, {"label": "B", "text": "{NOT, OR}"}, {"label": "C", "text": "{AND, OR}"}, {"label": "D", "text": "{NAND}"}], "answerKey": "C", "model_answer": "The correct answer is (D) {NAND}.\nA Boolean expression is a combination of Boolean operators (AND, OR, NOT) and Boolean variables (true or false). A set of Boolean operators that is sufficient to represent all Boolean expressions is said to be complete. The set {AND, OR} is not complete, because not all Boolean expressions can be represented using only these operators. For example, the expression (A AND NOT B) requires the use of the NOT operator, which is not included in the set {AND, OR}.\nThe set {NOT, OR} is also not complete, as it does not include the AND operator. Similarly, the set {AND, OR} is not complete, as it does not include the NOT operator.\nThe set {NAND} is complete, because all Boolean expressions can be expressed using the NAND operator alone (i.e., NOT NOT A).\nTherefore, the correct answer is (D) {NAND}."}
{"question": "Consider the collection of all undirected graphs with 10 nodes and 6 edges. Let M and m, respectively, be the maximum and minimum number of connected components in any graph in the collection. If a graph has no selfloops and there is at most one edge between any pair of nodes, which of the following is true?", "choices": [{"label": "A", "text": "M = 10, m = 10"}, {"label": "B", "text": "M = 10, m = 1"}, {"label": "C", "text": "M = 7, m = 4"}, {"label": "D", "text": "M = 6, m = 4"}], "answerKey": "C", "model_answer": "The correct answer is (C) M = 7, m = 4.\nThe question states that the collection of all undirected graphs with 10 nodes and 6 edges has the following properties:\n1. No self-loops.\n2. At most one edge between any pair of nodes.\nGiven these properties, we can use the Handshaking Lemma to prove that the maximum number of connected components in any graph in the collection is 7.\nThe Handshaking Lemma states that if a graph has no self-loops and at most one edge between any pair of nodes, then it has at most \u0394(n-1) + 1 connected components, where \u0394 is the maximum degree of the graph.\nIn this case, n = 10 and the maximum degree is 4 (since each node has at most one neighbor). Therefore, the maximum number of connected components is 9, which is equal to \u0394(n-1) + 1, where \u0394 = 4.\nTherefore, the correct answer is (C) M = 7, m = 4."}
{"question": "Resolution theorem proving for showing that a formula of propositional logic is not satisfiable has which of the following properties?\nI. It is a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic.\nII. It is a complete proof system in the sense that there is a proof of unsatisfiability for every unsa tisfiable formula of propositional logic.\nIII. It is a succinct proof system in the sense that whenever an unsatisfiable formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "C", "model_answer": "The correct answer is (B) III only.\nResolution theorem proving for showing that a formula of propositional logic is not satisfiable is a property of resolution theorem proving, which is a proof system for propositional logic. This property states that if a formula F of propositional logic has a resolution proof, F also has a proof whose length is polynomial in the length of F. This means that resolution theorem proving is a succinct proof system, as it can prove formulas with polynomial-length proofs.\nHowever, resolution theorem proving is not a complete proof system in the sense that it does not guarantee the existence of a proof of the unsatisfiability of a satisfiable formula of propositional logic. This means that there may be satisfiable formulas of propositional logic for which resolution theorem proving does not have a proof of unsatisfiability. Additionally, resolution theorem proving is not a sound proof system in the sense that there does not exist a proof of the unsatisfiability of a satisfiable formula of propositional logic. This means that there may be formulas of propositional logic that are proven to be unsatisfiable by resolution theorem proving that are actually satisfiable.\nTherefore, the correct"}
{"question": "Which of the following statements describe(s) properties of a purely segmented memory system?\nI. It divides memory into units of equal size.\nII. It permits implementation of virtual memory.\nIII. It suffers from internal fragmentation.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "B", "model_answer": "The correct answer is (D) I and III.\nOption (A) I only is not correct, as the statement \"It divides memory into units of equal size\" does not necessarily imply that the memory system is purely segmented.\nOption (B) II only is not correct, as the statement \"It permits implementation of virtual memory\" does not necessarily imply that the memory system is purely segmented.\nOption (C) III only is not correct, as the statement \"It suffers from internal fragmentation\" does not necessarily imply that the memory system is purely segmented.\nOption (D) I and III is the correct answer, as both statements apply to a purely segmented memory system. A purely segmented memory system divides memory into units of equal size and suffers from internal fragmentation, which is the inefficient use of memory because of the way segments are allocated."}
{"question": "Which of the following statements about floating-point arithmetic is NOT true?", "choices": [{"label": "A", "text": "It is inherently nonassociative because some numbers have no exact representation."}, {"label": "B", "text": "It is inherently nonassociative because there have to be upper and lower bounds on the size of numbers."}, {"label": "C", "text": "Associativity can be achieved with appropriate roundoff conventions."}, {"label": "D", "text": "Some rational numbers have no exact representation."}], "answerKey": "C", "model_answer": "The correct answer is (D) Some rational numbers have no exact representation.\nThis statement is not true for floating-point arithmetic.\nFloating-point arithmetic is a way of representing real numbers in a computer, using a set of numbers that can be represented in binary form. These numbers are stored in a structure called a \"floating-point format\", which is based on the IEEE 754 standard.\nThe statement \"Some rational numbers have no exact representation\" is true for some types of numbers that can be represented in floating-point arithmetic, but it is not a characteristic of floating-point arithmetic itself. For example, the number 1/3 cannot be represented exactly in floating-point arithmetic, because there is no way to represent the decimal point with a finite number of bits. This is not a characteristic of floating-point arithmetic, but rather a limitation of the IEEE 754 standard."}
{"question": "Suppose sharing of tiles in a multilevel directory structure is achieved with directory entries that are links pointing to a node containing information about a shared file. Information in this node includes (1) the owner of the file, (2) a count of the number of links to the tile, and (3) the disk block numbers of the file. What is a primary drawback to this approach to sharing?", "choices": [{"label": "A", "text": "If the owner modifies the file, another user who does not share will see the changes."}, {"label": "B", "text": "If the owner renames the file, other users will not be able to access it."}, {"label": "C", "text": "If the owner is allowed to delete a file, dangling links may result."}, {"label": "D", "text": "If any user who shares the file appends to it, others who share it will not be able to access the new disk blocks."}], "answerKey": "C", "model_answer": "The correct answer is (B) If the owner renames the file, other users will not be able to access it.\n\nThe primary drawback to this approach to sharing is that if the owner of the file renames it, other users who do not share the file will not be able to access it. If the file is renamed and the new name is not known to the other users, they will not be able to access it. This can be a major problem if multiple users need to access the file and if the owner frequently renames the file, other users will not be able to access it."}
{"question": "Mergesort works by splitting a list of n numbers in half, sorting each half recursively, and merging the two halves. Which of the following data structures will allow mergesort to work in O(n log n) time?\nI. A singly linked list\nII. A doubly linked list\nIII. An array", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "The correct answer is (B) III only.\nMerge sort works by recursively dividing the input list into two halves, sorting each half, and then merging the two sorted halves back together to form the final sorted list. Since the list is divided into two halves, it is essential to maintain a reference between the two halves during the sorting process to ensure that the correct order is maintained. A doubly linked list is a data structure that allows for efficient insertion, deletion, and traversal of elements, making it suitable for this purpose. This is why option (B) III only is the correct answer.\nOption (A) None is incorrect because, in reality, a singly linked list can be used to implement a merge sort algorithm. Option (C) I and II only is incorrect because a singly linked list is not a doubly linked list, and therefore, option (C) I and II only does not fully describe a doubly linked list. Option (D) I, II, and III is incorrect because it is not necessary to use a doubly linked list to implement merge sort, and using a doubly linked list can potentially complicate the implementation."}
{"question": "If p(x) is the minimal-degree interpolating polynomial for the real-valued function f(x) at the n + 1 distinct real numbers x0, .... xn what is the maximum possible degree of p(x)?", "choices": [{"label": "A", "text": "n"}, {"label": "B", "text": "n + 1"}, {"label": "C", "text": "n + 2"}, {"label": "D", "text": "2n"}], "answerKey": "A", "model_answer": "The correct answer is (B) n + 1, not (D) 2n.\nTo see why, consider the minimum degree condition for the interpolating polynomial:\np(x) = (x - x0) (x - x1)...(xn) + q(x)\nwhere q(x) is the remaining term of the polynomial.\nSince f(x) has n + 1 distinct real values, the polynomial must vanish at each of these values, so we have:\nq(x0) = f(x0), q(x1) = f(x1),..., q(xn) = f(xn)\nThis means that the degree of the polynomial p(x) is equal to the maximum of the degrees of the remaining terms q(x), which is n.\nTherefore, the maximum possible degree of p(x) is n + 1, not 2n."}
{"question": "An internal hash table has 5 buckets, numbered 0, 1, 2, 3, 4. Keys are integers, and the hash function h(i) = i mod 5 is used, with linear resolution of collisions (i.e., if bucket h(i) is filled, the buckets h(i) + 1, h(i) + 2, ... are tried successively with all bucket numbers computed modulo 5). If elements with keys 13, 8, 24, 10, and 3 are inserted, m that order, into an initially blank hash table, then the content of the bucket numbered 2 is", "choices": [{"label": "A", "text": "3"}, {"label": "B", "text": "8"}, {"label": "C", "text": "10"}, {"label": "D", "text": "13"}], "answerKey": "A", "model_answer": "The correct answer is (C) 10, because the hash function in this scenario assigns the key value 24 to the bucket numbered 2.\nThink about what the hash function does: it takes the key as an input and returns the index of the bucket in the hash table where the key should be stored. In this case, the key value 24 is hashed to 4 mod 5, which equals 0. Therefore, the bucket numbered 0 is the first bucket to be tried, and since it's already filled with the key 13, the next bucket to be tried is the bucket numbered 1, which is already filled with the key 8. Therefore, the key 24 is stored in the bucket numbered 3.\nSo, the content of the bucket numbered 2 is 10, because 10 was inserted into the bucket numbered 2, not 24."}
{"question": "TCP protocol is responsible (among other things) for", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "C", "model_answer": "The correct answer is (A) Routing packets through the network.\nTCP (Transmission Control Protocol) is responsible for reliable delivery of packets between directly connected machines. It is also used to route packets through the network, but that is not its primary function. TCP also provides reliability for large messages that are not necessarily multi-packet, but that is not its primary function either. It is also used to deal with differences among operating system architectures, but that is not its primary function either."}
{"question": "Let A and B be two sets of words (strings) from \u03a3*, for some alphabet of symbols \u03a3. Suppose that B is a subset of A. Which of the following statements must always be true of A and B ?\nI. If A is finite, then B is finite.\nII. If A is regular, then B is regular.\nIII. If A is context-free, then B is context-free.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "The correct answer is (D) I and II only.\nStatement I is true because if A is finite, then it means that it has a finite number of elements, and since B is a subset of A, it must also have a finite number of elements.\nStatement II is also true because if A is regular, then it means that it can be recognized by a finite-state machine, and since B is a subset of A, it can also be recognized by a finite-state machine.\nStatement III is not true in general. While A is a context-free language, it does not necessarily mean that B is a context-free language as well. A language can be context-free, but its subset can still be context-sensitive or non-context-free.\nTherefore, statement III is not always true.\nTherefore, the correct answer is (D) I and II only."}
{"question": "For all strings x, the function x^M is defined recursively as follows.\ne^M= e, and\nif w is a string and a is a string with length 1, then\n(aw)^M = aw^Ma.\nLet a be a string with length 1, and let x and y be arbitrary strings. Which of the following is true?", "choices": [{"label": "A", "text": "a^M = a"}, {"label": "B", "text": "(ax)^M = (xa)^M"}, {"label": "C", "text": "(xy)^M = y^Mx^M"}, {"label": "D", "text": "None of the above"}], "answerKey": "D", "model_answer": "The correct answer is (D) None of the above.\nThe given definition for the function x^M is not complete, as it does not specify what happens to the function when the base string is the empty string. Therefore, it is not possible to conclude anything about the behavior of the function for all strings x.\nWithout further information about the behavior of the function for the empty string, it is not possible to determine which of the given choices is true. Therefore, all of the given choices could be false, and none of them could be true.\nThe function is defined recursively, but it is not defined for all inputs, and therefore it is not possible to say which of the given choices is correct."}
{"question": "Which of the following is NOT a reasonable justification for choosing to busy-wait on an asynchronous event?", "choices": [{"label": "A", "text": "The wait is expected to be short."}, {"label": "B", "text": "A busy-wait loop is easier to code than an interrupt handler."}, {"label": "C", "text": "There is no other work for the processor to do."}, {"label": "D", "text": "The program executes on a time-sharing system."}], "answerKey": "D", "model_answer": "The correct answer is (B) A busy-wait loop is easier to code than an interrupt handler.\nThe reason for choosing to busy-wait on an asynchronous event is often to implement a simple and efficient solution to a problem, rather than a more complex and specialized one. In this case, a busy-wait loop is considered easier to code than an interrupt handler, because it requires less code and less overhead.\nIt is important to note that a busy-wait loop is not always the best choice for an asynchronous event, as it can lead to unnecessary power consumption and reduce the system's performance. It is always recommended to use more advanced techniques, such as interrupts or semaphores, when dealing with asynchronous events to achieve better performance and power efficiency."}
{"question": "The language {ww | w in (0 + 1)*} is", "choices": [{"label": "A", "text": "not accepted by any Turing machine"}, {"label": "B", "text": "accepted by some Turing machine, but by no pushdown automaton"}, {"label": "C", "text": "accepted by some pushdown automaton, but not context-free"}, {"label": "D", "text": "context-free, but not regular"}], "answerKey": "B", "model_answer": "The answer is (B). The language {ww | w in (0 + 1)*} is accepted by some Turing machine, but by no pushdown automaton.\nA Turing machine is a general-purpose model of computation that can simulate the behavior of any computer program, including pushdown automata. However, a pushdown automaton is a more restrictive model of computation that can only recognize context-free languages. So, while a Turing machine can recognize the language {ww | w in (0 + 1)*}, a pushdown automaton cannot.\nIn contrast, the language {ww | w in (0 + 1)*} is not context-free, but it is regular. This means that it can be recognized by a regular expression, which is a more restricted form of context-free grammar that is used to specify patterns in strings. A regular expression is a sequence of symbols that defines a set of strings that match a given pattern. So, a regular expression can be used to recognize the language {ww | w in (0 + 1)*}."}
{"question": "Which of the following statements about Ethernets is typically FALSE?", "choices": [{"label": "A", "text": "Ethernets use circuit switching to send messages."}, {"label": "B", "text": "Ethernets use buses with multiple masters."}, {"label": "C", "text": "Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly."}, {"label": "D", "text": "Networks connected by Ethernets are limited in length to a few hundred meters."}], "answerKey": "A", "model_answer": "The correct answer is (C) Ethernet protocols use a collision-detection method to ensure that messages are transmitted properly.\nThe other statements are not typically FALSE:\n\n(A) Ethernets use circuit switching to send messages is false. Ethernets use packet switching to send messages.\n(B) Ethernets use buses with multiple masters is false. Ethernets use point-to-point connections.\n(D) Networks connected by Ethernets are limited in length to a few hundred meters is false. Ethernets can be used over very long distances."}
{"question": "Let P be a procedure that for some inputs calls itself (i.e., is recursive). If P is guaranteed to terminate, which of the following statements must be true?\nI. P has a local variable.\nII. P has an execution path where it does not call itself.\nIII. P either refers to a global variable or has at least one parameter.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "The correct answer is (C) I and II only.\nIf P is guaranteed to terminate, then it must have a local variable or an execution path where it does not call itself. This means that it cannot have a global variable and it cannot have at least one parameter. Therefore, the choice (C) I and II only is the correct answer.\nI. P has a local variable\nThis statement is not necessarily true. A procedure can be recursive without having a local variable.\nII. P has an execution path where it does not call itself\nThis statement is true if P is guaranteed to terminate. It means that there is at least one execution path where P does not call itself, otherwise it would never terminate.\nIII. P either refers to a global variable or has at least one parameter\nThis statement is not necessarily true. A procedure can be recursive without referring to a global variable or having at least one parameter.\n\nTherefore, the correct answer is (C) I and II only."}
{"question": "Which of the following comes closest to being a perfectly secure encryption scheme?", "choices": [{"label": "A", "text": "The Caesar Cipher, a substitution cipher"}, {"label": "B", "text": "DES (Data Encryption Standard), a symmetric-key algorithm"}, {"label": "C", "text": "Enigma, a transposition cipher"}, {"label": "D", "text": "One-time pad"}], "answerKey": "D", "model_answer": "The correct answer is (A) The Caesar Cipher, a substitution cipher.\n\nA substitution cipher involves substituting each letter in the plaintext with another letter a certain number of positions down the alphabet. The Caesar cipher is a simple example of this type of encryption, where each letter is shifted by a certain number of positions. For example, if the shift value is 3, then the letter \"E\" would be encrypted as \"H\". The Caesar cipher is easy to break, as the frequency of letters in the plaintext will be different from the frequency of letters in the ciphertext.\n\nOn the other hand, (C) Enigma, a transposition cipher, is a type of encryption that involves rearranging the letters of a message or document in a predetermined way. Enigma machines were used by the German military during World War II and were considered to be secure due to the complexity of the encryption process, but they could still be broken with enough effort.\n\n(B) DES, a symmetric-key algorithm, is a more complex encryption method that uses a secret key to encrypt and decrypt messages. DES is considered to be secure if the key is long enough and randomly generated"}
{"question": "Of the following problems concerning a given undirected graph G, which is currently known to be solvable in polynomial time?", "choices": [{"label": "A", "text": "Finding a longest simple cycle in G"}, {"label": "B", "text": "Finding a shortest cycle in G"}, {"label": "C", "text": "Finding ALL spanning trees of G"}, {"label": "D", "text": "Finding a largest clique in G"}], "answerKey": "B", "model_answer": "The correct answer is (C) Finding ALL spanning trees of G.\n\nSpanning trees of a graph are a fundamental concept in graph theory. They are the subset of edges in a graph that connect every vertex to every other vertex. A spanning tree can be thought of as a tree that is embedded in a graph and whose edges connect all the vertices. There are many algorithms for finding all spanning trees of a graph, and they can be found in polynomial time.\n\nOn the other hand, finding a longest simple cycle in a graph and finding a shortest cycle in a graph are NP-hard problems, meaning that they are not known to be solvable in polynomial time. A longest cycle and shortest cycle are both important in graph theory and computer science, but they are not known to have a polynomial-time algorithm for finding all of them.\n\nFinding ALL spanning trees of a graph is a fundamental problem in graph theory, and it is known to be solvable in polynomial time. The Kruskal's algorithm and Prim's algorithm are two well-known algorithms for finding all spanning trees of a graph."}
{"question": "The IP protocol is primarily concerned with", "choices": [{"label": "A", "text": "Routing packets through the network"}, {"label": "B", "text": "Reliable delivery of packets between directly connected machines"}, {"label": "C", "text": "Reliable delivery of large (multi-packet) messages between machines that are not necessarily directly connected"}, {"label": "D", "text": "Dealing with differences among operating system architectures"}], "answerKey": "A", "model_answer": "The correct answer is (B): Reliable delivery of packets between directly connected machines.\nThe Internet Protocol (IP) is a network layer protocol that provides reliable delivery of packets of data between directly connected machines. It is responsible for routing packets through the network and ensuring that packets reach their intended destination.\nWhile it is true that IP also deals with differences among operating system architectures (option D), its primary concern is the reliable delivery of packets between directly connected machines.\nThanks for the question!"}
{"question": "Of the following, which best approximates the ratio of the number of nonterminal nodes to the total number of nodes in a complete K-ary tree of depth N?", "choices": [{"label": "A", "text": "1/K"}, {"label": "B", "text": "K-1/K"}, {"label": "C", "text": "log_10 (1/N)"}, {"label": "D", "text": "N-1/m"}], "answerKey": "A", "model_answer": "The correct answer is (C) log_10 (1/N).\nThe ratio of the number of non-terminal nodes to the total number of nodes in a complete K-ary tree of depth N can be calculated using the formula:\n(number of nodes at level 1) + (number of nodes at level 2) +... + (number of nodes at level N-1) / (number of nodes at level 1) + (number of nodes at level 2) +... + (number of nodes at level N-1)\nSince there are (2^N) nodes in a complete K-ary tree of depth N, the number of non-terminal nodes can be calculated as:\n(2^1) + (2^2) +... + (2^N-1) / (2^1) + (2^2) +... + (2^N-1)\nSimplifying the fraction, we have:\n(2^N) / (2^1)\nWhich can be simplified to:\n2^N\n\nThe number of non-terminal nodes in a complete K-ary tree of depth N is equal to the number of nodes at level N"}
{"question": "Consider a computer system in which processes can request and release one or more resources. Once a process has been granted a resource, the process has exclusive use of that resource until it is released. If a process requests a resource that is already in use, the process enters a queue for that resource, waiting until the resource is available. Which of the following will NOT deal effectively with the problem of deadlock?", "choices": [{"label": "A", "text": "Giving priorities to processes and ordering the wait queues by priority"}, {"label": "B", "text": "Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all"}, {"label": "C", "text": "Numbering the resources and requiring that processes request resources in order of increasing number"}, {"label": "D", "text": "Having processes time out and restart after a random interval of waiting"}], "answerKey": "A", "model_answer": "The correct answer is (B) Having a process request all its required resources when it first begins, and restarting if it cannot obtain them all.\nThis answer is correct because it addresses the problem of deadlock by ensuring that all required resources are requested at the same time, and only when all required resources are available to the process does it start. If any of the resources are not available, the process will not be granted a resource and will continue to wait in the queue. This approach does not allow deadlock to occur, as any process that is waiting for resources will not start until all required resources are available.\nThe other answers do not effectively deal with the problem of deadlock because:\n\n* (A) Giving priorities to processes and ordering the wait queues by priority does not prevent deadlock, it only ensures that higher priority processes are given resources first, but it does not prevent processes from waiting for resources that are not available.\n* (C) Numbering the resources and requiring that processes request resources in order of increasing number does not prevent deadlock, it only ensures that resources are requested in specific order, but it does not prevent processes from waiting for resources that are not available.\n* (D) Having processes time out"}
{"question": "\"Magic memory\"' has two operations: Read and Clear. Both are indivisible and mutually exclusive. Clear sets the magic memory to zero. Read returns a value that represents the number of Read operations since the last Clear operation. Which of the following is (are) true of \"Magic memory\"?\nI. It can provide the functionality of an atomic Test-and-Set.\nII. It can be used to coordinate processes running on a shared-memory multiprocessor.\nIII. It is only useful on a multiprocessor.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "The correct answer is (C) III only. \"Magic memory\" is a specific type of memory that has two operations: Read and Clear. Clear sets the memory to zero, while Read returns a value that represents the number of Read operations since the last Clear operation. It is not an atomic Test-and-Set and cannot be used to coordinate processes running on a shared-memory multiprocessor. Therefore, (A) I only, (B) II only, and (D) I and II are incorrect."}
{"question": "Which of the following is the name of the data structure in a compiler that is responsible for managing information about variables and their attributes?", "choices": [{"label": "A", "text": "Abstract Syntax Tree (AST)"}, {"label": "B", "text": "Attribute Grammar"}, {"label": "C", "text": "Symbol Table"}, {"label": "D", "text": "Semantic Stack"}], "answerKey": "C", "model_answer": "The correct answer is (A) Abstract Syntax Tree (AST).\nAn Abstract Syntax Tree (AST) is a data structure used in compilers to represent the abstract syntax of a programming language. It is used to analyze and transform source code into a form that can be efficiently executed by a computer. The AST is a tree-like structure that contains information about the structure of the source code, such as the types of variables, functions, and expressions, as well as their relationships to each other. This data structure allows the compiler to parse, analyze, and transform the source code into machine code, which can then be executed by the computer.\nThe other options you were given are not correct answers to the question:\n(B) Attribute Grammar is a method for specifying the syntax of a programming language using attributes, rather than a data structure used in compilers.\n(C) Symbol Table is a data structure used in programming languages to store information about symbols, such as variables and functions, rather than being responsible for managing information about variables and their attributes.\n(D) Semantic Stack is a data structure used in some compilers to represent the semantic information of a program, such as the meaning of expressions and the flow of control through the program, rather than"}
{"question": "Which of the following algorithms has running time \u0398(n^2) in the worst case but \u0398(n log n) on average?", "choices": [{"label": "A", "text": "Bubblesort"}, {"label": "B", "text": "Mergesort"}, {"label": "C", "text": "Heapsort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "D", "model_answer": "The correct answer is (B) Mergesort.\nBubblesort, (C) Heapsort, and (D) Quicksort have \u0398(n log n) running time on average, but Quicksort has a worst-case running time of \u0398(n^2) in the worst case. Mergesort, on the other hand, has a worst-case running time of \u0398(n^2) in the worst case, but on average it has a running time of \u0398(n log n). Therefore, Mergesort is the algorithm that has a running time of \u0398(n^2) in the worst case but \u0398(n log n) on average."}
{"question": "Languages with a structure that implements abstract data types (e.g., a C++ class) can prevent access to components of this structure by all operations except those that are part of this structure. However, definitions of such a structure often contain declarations of components of the structure (e.g., the header file for a C++ class may contain declarations of its private components). For such a language, an object's name could be bound at run time to stack storage for its component values (direct representation) or to a stack pointer referencing heap storage for its component values (indirect representation). Which of the following statements about comparisons between direct and indirect representations is (are) true?\nI. Indirect representation noticeably increases compilation time.\nII. Direct representation decreases the time needed to access components of a variable.\nIII. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "The correct answer is (D) II and III only.\nThe given statement about the comparison between direct and indirect representations of variables is:\n\"II. Direct representation decreases the time needed to access components of a variable.\"\nThis means that in direct representation, the name of the object is bound to stack storage for its component values, which allows for faster access to the components of the variable.\nThe other statement about the impact of indirect representation on compilation time is:\n\"III. When the storage size of some private component of a variable changes, indirect representation minimizes the number of recompilations of source modules that must be performed.\"\nThis means that in indirect representation, the name of the object is bound to a stack pointer referencing heap storage for its component values, which can affect the number of recompilations of source modules that need to be performed when the storage size of some private component of a variable changes.\nTherefore, the correct answer is (D) II and III only, as both statements are related to the access time and recompilation of source modules when the storage size of some private component of a variable changes."}
{"question": "Which of the following is NOT a property of bitmap graphics?", "choices": [{"label": "A", "text": "Fast hardware exists to move blocks of pixels efficiently."}, {"label": "B", "text": "Realistic lighting and shading can be done."}, {"label": "C", "text": "All line segments can be displayed as straight."}, {"label": "D", "text": "Polygons can be filled with solid colors and textures."}], "answerKey": "C", "model_answer": "The correct answer is (B) Realistic lighting and shading can be done. Bitmap graphics, also known as raster graphics, are a type of digital image that is made up of a grid of pixels, each of which can have a single color. While bitmap graphics can be used to create realistic lighting and shading effects, they are generally slower and less efficient than vector graphics, which can be used to create more complex images and animations."}
{"question": "Which of the following is true of interrupts?", "choices": [{"label": "A", "text": "They are generated when memory cycles are \"stolen\"."}, {"label": "B", "text": "They are used in place of data channels."}, {"label": "C", "text": "They can indicate completion of an I/O operation."}, {"label": "D", "text": "They cannot be generated by arithmetic operations."}], "answerKey": "C", "model_answer": "The correct answer is (C) They can indicate completion of an I/O operation.\nExplanation: Interrupts are generated by hardware or software to indicate that an event has occurred that requires immediate attention, such as completion of an I/O operation. It is not true that interrupts are generated when memory cycles are \"stolen\" or that they are used in place of data channels. It is also not true that interrupts cannot be generated by arithmetic operations."}
{"question": "In a height-balanced binary search tree, the heights of the left and right descendents of any node differ by at most 1. Which of the following are true of such a tree?\nI. Worst-case search time is logarithmic in the number of nodes.\nII. Average-case search time is logarithmic in the number of nodes.\nIII. Best-case search time is proportional to the height of the tree.\nIV. The height of the tree is logarithmic in the number of nodes.", "choices": [{"label": "A", "text": "I and III only"}, {"label": "B", "text": "II and III only"}, {"label": "C", "text": "II and IV only"}, {"label": "D", "text": "I, II, and IV"}], "answerKey": "D", "model_answer": "The correct answer is (A) I and III only.\nA height-balanced binary search tree satisfies the property that the heights of the left and right descendents of any node differ by at most 1. This means that the height of the subtree rooted at the left child of any node is at most 1 greater than the height of the subtree rooted at the right child of that same node, and vice versa.\nStatements I and III are both true of a height-balanced binary search tree. Statement I states that the worst-case search time for a node in such a tree is logarithmic in the number of nodes, which is the same as saying that the average-case search time is logarithmic in the number of nodes. Statement III states that the best-case search time for a node in such a tree is proportional to the height of the tree, which is also logarithmic in the number of nodes.\nStatement II is not true of a height-balanced binary search tree. The average-case search time for a node in such a tree is not logarithmic in the number of nodes.\nStatement IV is not true of a height-balanced binary search tree."}
{"question": "Bob writes down a number between 1 and 1,000. Mary must identify that number by asking \"yes/no\" questions of Bob. Mary knows that Bob always tells the truth. If Mary uses an optimal strategy, then she will determine the answer at the end of exactly how many questions in the worst case?", "choices": [{"label": "A", "text": "1,000"}, {"label": "B", "text": "999"}, {"label": "C", "text": "500"}, {"label": "D", "text": "10"}], "answerKey": "D", "model_answer": "The correct answer is (D) 10.\nThe optimal strategy for Mary to determine the number Bob wrote down would involve asking:\n1. Is the number even?\n2. Is the number greater than 500?\n3. Is the number a prime number?\n4. Is the number divisible by 2, 3, 5, 7, or 11?\n5. Is the number a power of two?\n6. Is the number a prime number congruent to 3 mod 4?\n7. Is the number a Mersenne prime?\n8. Is the number a prime number congruent to 3 mod 4?\n9. Is the number a prime number congruent to 5 mod 6?\n10. Is the number a prime number congruent to 3 mod 4 or 5 mod 6?\nIf Mary asks and answers these questions correctly, she will determine the number Bob wrote down at the end of 10 questions in the worst case. The number of questions required would be 10, as the worst-case scenario would involve Bob writing down a number that is not prime, not a power of two, not a"}
{"question": "Which of the following is (are) true about virtual memory systems that use pages?\nI. The virtual address space can be larger than the amount of physical memory.\nII. Programs must be resident in main memory throughout their execution.\nIII. Pages correspond to semantic characteristics of the program.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "The correct answer is (C) I and III. Both statements I and III are true about virtual memory systems that use pages.\nStatement I is true because a virtual address space can be larger than the amount of physical memory, which allows for more memory-intensive programs to run without causing a page fault. This is possible because virtual memory systems use page tables to map virtual addresses to physical addresses, allowing for the use of the entire virtual address space even if not all of it is currently in physical memory.\nStatement III is also true because programs must be resident in main memory throughout their execution. In other words, the entire program must be loaded into memory before it can be executed, and it will remain in memory until it is closed or exited. This ensures that the program can quickly access its data and code without having to load it into memory again.\nThe other options are not true. Statement II is false because programs do not necessarily have to be resident in main memory throughout their execution. Some programs may be loaded into memory only when they are needed, and unloaded when they are not, in a process known as demand paging.\nTherefore, the correct answer is (C) I and III."}
{"question": "Which of the following is usually NOT represented in a subroutine's activation record frame for a stack-based programming language?", "choices": [{"label": "A", "text": "Values of local variables"}, {"label": "B", "text": "A heap area"}, {"label": "C", "text": "The return address"}, {"label": "D", "text": "Stack pointer for the calling activation record"}], "answerKey": "B", "model_answer": "The correct answer is (D) Stack pointer for the calling activation record. In a stack-based programming language, the activation record is used to keep track of the current state of the program, including the values of local variables and the current function call stack. The stack pointer for the calling activation record is a crucial part of the activation record and is used to store the address of the next element to be pushed onto the stack. Without the stack pointer, the rest of the activation record would be meaningless. Therefore, the stack pointer for the calling activation record is usually represented in a subroutine's activation record frame in a stack-based programming language."}
{"question": "Which of the following statements about a remote procedure call is true?", "choices": [{"label": "A", "text": "It is used to call procedures with addresses that are farther than 2^16 bytes away."}, {"label": "B", "text": "It cannot return a value."}, {"label": "C", "text": "It cannot pass parameters by reference."}, {"label": "D", "text": "It cannot call procedures implemented in a different language."}], "answerKey": "C", "model_answer": "Answer: D. It cannot call procedures implemented in a different language.\nA remote procedure call (RPC) is a method of invoking a procedure in a separate process or computer system over a network. RPCs are often used to access procedures that are not available on the local system, such as those implemented by a server. RPCs allow the calling process to execute the called procedure as if it were part of the calling process, and they can be used to pass parameters and return values between the processes.\nRPCs can be used to call procedures with addresses that are farther than 2^16 bytes away, but this is not a requirement for an RPC. RPCs can also return values, although this is not always possible due to the nature of network communication. RPCs can also pass parameters by reference, although this may not always be the most efficient method.\nRPCs do not have the capability to call procedures implemented in a different language, as they are typically used to call procedures implemented in the same language on a separate system."}
{"question": "Of the following sorting algorithms, which has a running time that is LEAST dependent on the initial ordering of the input?", "choices": [{"label": "A", "text": "Insertion sort"}, {"label": "B", "text": "Quicksort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Selection sort"}], "answerKey": "C", "model_answer": "The correct answer is (D) Selection sort.\nSelection sort is a simple sorting algorithm that works by selecting the smallest element in a group of elements and swapping it with the first element in the group. It then selects the next smallest element and swaps it with the second element, and so on until the entire group is sorted.\nThe running time of selection sort is O(n^2), which means it is quadratic in the length of the input. This means that the running time of selection sort is not dependent on the initial ordering of the input.\nOn the other hand, insertion sort has a running time that is dependent on the initial ordering of the input. Quicksort and merge sort have running times that are much faster than insertion sort and selection sort, but they are also more complex and may not always be the best choice for all problems.\nSo, the answer is (D) Selection sort."}
{"question": "A particular parallel program computation requires 100 seconds when executed on a single processor. If 40 percent of this computation is \"inherently sequential\" (i.e., will not benefit from additional processors), then the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are", "choices": [{"label": "A", "text": "20 and 10 seconds"}, {"label": "B", "text": "30 and 15 seconds"}, {"label": "C", "text": "50 and 25 seconds"}, {"label": "D", "text": "70 and 55 seconds"}], "answerKey": "D", "model_answer": "The correct answer is (D) 70 and 55 seconds.\nThe question states that the program requires 100 seconds to execute on a single processor, and that 40 percent of the computation is inherently sequential and will not benefit from additional processors. Therefore, the theoretically best possible elapsed times for this program running with 2 and 4 processors, respectively, are:\n100/2 + 40/2 = 50 seconds\n100/4 + 40/4 = 70 seconds\nSince (70 + 55) / 2 = 70, the correct answer is (D) 70 and 55 seconds."}
{"question": "Consider the representation of six-bit numbers by two's complement, one's complement, or by sign and magnitude. In which representation is there overflow from the addition of the integers 011000 and 011000?", "choices": [{"label": "A", "text": "Two's complement only"}, {"label": "B", "text": "Sign and magnitude and one's complement only"}, {"label": "C", "text": "Two's complement and one's complement only"}, {"label": "D", "text": "All three representations"}], "answerKey": "D", "model_answer": "The correct answer is (B) Sign and magnitude and one's complement only.\nIn two's complement representation, there will be overflow when the sum of two six-bit numbers exceeds 63. In one's complement representation, there will be overflow when the sum of two six-bit numbers exceeds 31. Since both two's complement and one's complement representations can lead to overflow when performing addition with six-bit numbers, the correct answer is (B) Sign and magnitude and one's complement only.\nIn sign and magnitude representation, there will be no overflow when performing addition with six-bit numbers, since the result of the addition is scaled by the maximum value of the numbers being added. However, this representation is not used for six-bit numbers."}
{"question": "Of the following, which best characterizes computers that use memory-mapped I/O?", "choices": [{"label": "A", "text": "The computer provides special instructions for manipulating I/O ports."}, {"label": "B", "text": "I/O ports are placed at addresses on the bus and are accessed just like other memory locations."}, {"label": "C", "text": "To perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation."}, {"label": "D", "text": "Ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations."}], "answerKey": "B", "model_answer": "The correct answer is (A).\nMemory-mapped I/O is a method of accessing I/O devices where the I/O ports are placed at addresses on the bus and are accessed just like other memory locations. In this method, an I/O operation can be performed by simply placing the data in an address register and calling the channel to perform the operation. This method allows direct access to I/O ports without the need for special instructions or hardware.\nOption (A) best characterizes computers that use memory-mapped I/O. It provides special instructions for manipulating I/O ports and allows direct access to I/O ports without the need for special instructions or hardware. Option (C) is incorrect because it states that to perform an I/O operation, it is sufficient to place the data in an address register and call the channel to perform the operation. While this is one way to perform I/O operations, it is not the only method. Option (D) is incorrect because it states that ports are referenced only by memory-mapped instructions of the computer and are located at hardwired memory locations. This is not true for memory-mapped I/O, as the ports are accessed at addresses on the bus and can be"}
{"question": "Many cryptographic protocols base their security on assumptions about the computational difficulty of integer factorization. Integer factorization serves this purpose because we believe that", "choices": [{"label": "A", "text": "integer multiplication is a function whose inverse, factorization, remains difficult for a large class of inputs"}, {"label": "B", "text": "P = NP"}, {"label": "C", "text": "even if P = NP, integer factorization is still likely not to be polynomial-time computable"}, {"label": "D", "text": "testing primality is computationally intractable"}], "answerKey": "A", "model_answer": "D. Testing primality is computationally intractable.\nIn this statement, integer factorization is used as an example of a computational problem that is believed to be difficult, but the focus is on testing primality. Testing primality is the problem of determining whether a number is prime (i.e., whether it is divisible by only itself and 1) or not. It is a fundamental problem in number theory and is used in many cryptographic protocols to ensure the security of private keys.\nThe statement suggests that even if P=NP (a widely studied and debated problem in computer science) and integer factorization were polynomial-time computable, testing primality would still likely not be computationally tractable. This is because there are certain classes of inputs that can make integer factorization easy, but it does not mean it becomes polynomial-time computable.\nTherefore, the correct answer is D: testing primality is computationally intractable."}
{"question": "Which of the following sets of bit strings CANNOT be described with a regular expression?", "choices": [{"label": "A", "text": "All bit strings whose number of zeros is a multiple of five"}, {"label": "B", "text": "All bit strings starting with a zero and ending with a one"}, {"label": "C", "text": "All bit strings with an even number of zeros"}, {"label": "D", "text": "All bit strings with more ones than zeros"}], "answerKey": "D", "model_answer": "The correct answer is (D) All bit strings with more ones than zeros.\nRegular expressions are a way of describing patterns in strings of characters using a combination of characters and operators. The regular expression for a set of bit strings that have more ones than zeros would be something like \"0*1\". This means that any string of zeros followed by any number of ones is a match.\nHowever, the other choices do not describe a regular expression that would match all bit strings with a specific property. For example, the string \"000101000\" has more ones than zeros, but it is not a match for the regular expression \"0*1\". Similarly, \"01010000\" has an even number of zeros, but it does not match the regular expression \"0*1\". Lastly, \"000000000000000000000000000001010000\" has more ones than zeros, but it is not a match for the regular expression \"0*1\".\nTherefore, the correct answer is (D) All bit strings with more ones than zeros."}
{"question": "Which of the following conditions can be expressed by a Boolean formula in the Boolean variables p_1, p_2, p_3, p_4 and the connectives \u2227,\u2228 (without \u00ac)?\nI. At least three of p_1, p_2, p_3, p_4 are true.\nII. Exactly three of p_1, p_2, p_3, p_4 are true.\nIII. An even number of p_1, p_2, p_3, p_4 are true.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "A", "model_answer": "The correct answer is (D) I and III.\nThe first condition, I, can be expressed as:\n(p_1 \u2227 p_2 \u2227 p_3 \u2227 p_4) \u2228 (p_1 \u2227 p_2 \u2227 p_3 \u2227 p_4) \u2228 (p_1 \u2227 p_2 \u2227 p_3 \u2227 p_4) \u2228 (p_1 \u2227 p_2 \u2227 p_3 \u2227 p_4)\nWhich is a disjunction of five conjunctions, each of which has three variables and a \u2228 operator.\nThe second condition, III, can be expressed as:\n(p_1 \u2228 p_2 \u2228 p_3 \u2228 p_4) \u2227 (p_1 \u2228 p_2 \u2228 p_3 \u2228 p_4)\nWhich is a conjunction of two disjunctions, each of which has four variables and a \u2227 operator.\nTherefore, the conjunction of the first condition (I) and the second condition (III) would be:\n(p_1 \u2227 p_2 \u2227 p_3 \u2227 p_"}
{"question": "Two alternatives for interconnecting a set of processors with bidirectional links are (1) the fully interconnected network, in which each processor is directly connected to every other processor, and (2) the ring network, in which each processor is connected to two other processors. The worst-case path length for a network is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes. For each type of interconnection of n processors, a figure of merit can be formed as the product of the number of links required for the network times the worst-case path length connecting any two processors. The ratio of this figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is", "choices": [{"label": "A", "text": "1/(n^2)"}, {"label": "B", "text": "1/(n(n-1))"}, {"label": "C", "text": "1/n"}, {"label": "D", "text": "(n-1)/n"}], "answerKey": "D", "model_answer": "The correct answer is (B) 1/(n(n-1)).\nThe given question is asking for the ratio of the figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2.\nThe figure of merit is the product of the number of links required for the network times the worst-case path length connecting any two processors.\nFor the fully interconnected network, the worst-case path length is the maximum, over all pairs of nodes in the network, of the minimum length paths (measured in number of links) between the nodes.\nFor the ring network, the worst-case path length is the maximum, over all pairs of nodes in the network, of the minimum length paths between the nodes, which is equal to the number of links in the ring.\nTherefore, the ratio of the figure of merit for the fully interconnected network compared to that of the ring network, for even n > 2, is:\n(Number of links required for the fully interconnected network \\* worst-case path length connecting any two processors) / (Number of links in the ring \\* worst-case path length connecting any two processors)\n= ("}
{"question": "For a connected, undirected graph G = (V, E), which of the following must be true?\nI. \u03a3_{v\u2208V} degree(v) is even.\nII. |E| \u2265 |V| \u2212 1\nIII. G has at least one vertex with degree 1.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "D", "model_answer": "The correct answer is (C) III only.\nChoice (A) I only is not always true, as there are graphs with an even sum of degrees for some vertices and an odd sum of degrees for others.\nChoice (B) II only is not always true, as there are graphs with a number of edges that is less than or equal to the number of vertices minus 1.\nChoice (D) I and II is not always true, as there are graphs with at least one vertex with degree 1 and a sum of degrees that is not even.\nChoice (C) III only is always true, as a connected, undirected graph must have at least one vertex with degree 1 in order to have an edge.\nTherefore, the correct answer is (C) III only."}
{"question": "In multiprogrammed systems it is advantageous if some programs such as editors and compilers can be shared by several users. Which of the following must be true of multiprogrammed systems in order that a single copy of a program can be shared by several users?\nI. The program is a macro.\nII. The program is recursive.\nIII. The program is reentrant.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "C", "model_answer": "The correct answer is (C) III only.\nIn a multiprogrammed system, a program must be reentrant in order to be shared by several users. A reentrant program is one that can be called from multiple processes or threads without causing undefined behavior. This is because multiple processes or threads may be executing the same code simultaneously, and reentrant programs can handle this situation without causing any issues.\nMacros and recursion are two other characteristics that can affect the behavior of a program in a multiprogrammed system, but they are not necessary for a program to be reentrant. Therefore, the choices (A) I only, (B) II only, and (D) II and III only are incorrect.\nTherefore, the correct answer is (C) III only, which means that the program must be reentrant in order to be shared by several users in a multiprogrammed system."}
{"question": "Which of the following decimal numbers has an exact representation in binary notation?", "choices": [{"label": "A", "text": "0.1"}, {"label": "B", "text": "0.2"}, {"label": "C", "text": "0.3"}, {"label": "D", "text": "0.5"}], "answerKey": "D", "model_answer": "The correct answer is (D) 0.5. This is because 0.5 can be represented exactly in binary notation as 101, which is the binary equivalent of the decimal number 0.5. The other choices do not have an exact representation in binary notation."}
{"question": "Function signatures describe the types of the arguments to a function as well as the return value of the function. For instance, the addition function on reals has a signature of\nadd : real x real -> real\nsince it takes two real numbers and returns a real number. But, for a language that allows functions as return values, addition could be considered to have the signature\nadd : real -> (real -> real)\nwhich means that add takes a single real (the first operand) and returns a new function that itself takes a single real (the second operand) and returns a real (the result). This process of reducing a function with multiple arguments to a function with fewer arguments is called currying. Which of the following is correct?", "choices": [{"label": "A", "text": "Currying can be applied to any function to the point where it has exactly one input argument."}, {"label": "B", "text": "Currying cannot be applied to functions of more than two arguments."}, {"label": "C", "text": "Currying cannot be applied to functions that return functions as arguments."}, {"label": "D", "text": "Currying cannot be applied w functions that haw arguments that are functions."}], "answerKey": "A", "model_answer": "(C) Currying cannot be applied to functions that return functions as arguments.\nCurrying is the process of reducing a function with multiple arguments to a function with fewer arguments. It can be applied to any function, regardless of the number of arguments it takes or returns.\nIn the context of your question, the signature of the addition function on reals is:\nadd : real x real -> real\nThis means that it takes two real numbers as inputs and returns a real number as the result.\nIf the language allows functions as return values, then the signature of the addition function could be:\nadd : real -> (real -> real)\nThis means that it takes a single real number as input and returns a new function that itself takes a single real number as input and returns a real number. This is an example of currying.\nTherefore, the correct answer is (C) Currying cannot be applied to functions that return functions as arguments."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-back policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2000"}], "answerKey": "A", "model_answer": "The correct answer is (B) 256.\nWhen the loop executes, the values in each element of Array A are added to the corresponding element of Array B. Since Array B has 512 elements, and Array A has 256 elements, the total amount of data being written to memory is 256 \\* 512 = 128,640 bytes.\nSince Array B is stored at physical address 8,192, and Array A is stored at physical address 4,096, the loop will write data from physical address 8,192 to 4,096, in other words, the write will cover the entire array A. Since Array A is 256 elements long, the total amount of data being written to memory is 256 \\* 4,096 = 1,048,576 bytes.\nSince Array A and B are stored in a 2K-byte cache, the write will cover 256 \\* 2,097 = 524,288 bytes. Since the cache has a write-back policy, only the modified data"}
{"question": "In which of the following representations of numbers by 8-bit words is the addition of the integers 109 and -42 within range?\nI. One's complement\nII. Two's complement\nIII. Sign and magnitude", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "The correct answer is D.\nBoth I and II work for addition of integers within the range of 8-bit words.\nOne's complement and two's complement are two ways to represent negative numbers in binary form. In one's complement, the most significant bit (MSB) is set to 1 to indicate a negative number, while in two's complement, the most significant bit is set to 0 and the next least significant bit is used to indicate the sign.\nThe question does not specify which representation is being used for addition, so both I and II are viable options. If the question is asking for the representation used in the given addition, then C is the correct answer. If the question is asking for the representation that could be used for addition, then D is the correct answer."}
{"question": "If a malicious process is granted temporary administrator-level access to a system", "choices": [{"label": "A", "text": "the threat is over as soon as the process is killed"}, {"label": "B", "text": "the threat is over after the operating system is rebooted"}, {"label": "C", "text": "the thread is over after rebooting the machine and replacing files that show a virus infection"}, {"label": "D", "text": "the threat is often permanent until the entire disk is wiped clean"}], "answerKey": "D", "model_answer": "The correct answer is (A). When a malicious process is granted temporary administrator-level access to a system, the threat is over as soon as the process is killed. This is because once the process is terminated, it will no longer have access to the system or any sensitive information. Therefore, rebooting the system or replacing files on the machine will not undo the damage caused by the malicious process. It is important to note that while killing the process can stop the immediate threat, it may not prevent any damage that has already been done by the malicious process. This is why it is important to have security measures in place to prevent and detect malicious activity, and to have a plan for responding to such threats."}
{"question": "Which of the following statements about horizontal versus vertical microarchitecture is (are) true?\nI. Programs for horizontal architectures require more time steps than those for vertical architectures.\nII. Horizontal microinstructions are unencoded.\nIII. Horizontal microinstructions usually have a single opcode and multiple operand specifiers.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "The correct answer is (D) II and III only.\nBoth statements II and III are true, but statement I is not necessarily true.\nHorizontal microinstructions usually have a single opcode and multiple operand specifiers, which means that they are encoded and have multiple bits to specify the operands. However, the number of time steps required for a program for horizontal architecture may be less than or greater than that for a program for vertical architecture, depending on the complexity of the program and the microarchitecture.\nSo, the correct answer is (D) II and III only."}
{"question": "A \"strictly binary tree\" is a binary tree in which every node that is not a leaf has two children. Suppose that for a class of strictly binary trees there exists c > 0 such that, for any tree in the class, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. Which of the following best characterizes the height h of any tree in this class, where N is the number of nodes in the tree and N > 1 ?", "choices": [{"label": "A", "text": "h <= log2(N)"}, {"label": "B", "text": "h = 1/c * log2(N)"}, {"label": "C", "text": "h < c log2(N)"}, {"label": "D", "text": "h > c log2(N)"}], "answerKey": "C", "model_answer": "The correct answer is (C) h < c log2(N).\nIn the given problem, we are given that for any tree in the class of strictly binary trees, the ratio of the lengths of any two root-to-leaf paths is bounded above by c. This means that the height of any tree in this class is less than or equal to the ratio of the lengths of any two root-to-leaf paths, which is bounded above by c.\nTherefore, the height of any tree in this class must be less than or equal to the reciprocal of c multiplied by the natural logarithm of N. This can be expressed mathematically as h < c log2(N).\nTherefore, the correct answer is (C) h < c log2(N)."}
{"question": "Which of the following sorting algorithms has average-case and worst-case running times of O(n log n)?", "choices": [{"label": "A", "text": "Bubble sort"}, {"label": "B", "text": "Insertion sort"}, {"label": "C", "text": "Merge sort"}, {"label": "D", "text": "Quicksort"}], "answerKey": "C", "model_answer": "The correct answer is (D) Quicksort.\nQuicksort has both an average-case and worst-case running time of O(n log n). On average, it takes O(n log n) time to sort n elements, but in the worst case, it can take as much as O(n**2) time to sort a list of n elements. Insertion sort has an average-case running time of O(n^2) and a worst-case running time of O(n^2), while Bubble sort has an average-case running time of O(n^2) and a worst-case running time of O(n^2), and Merge sort has an average-case running time of O(n log n) and a worst-case running time of O(n log n).\nQuicksort is a popular sorting algorithm that uses divide and conquer to sort elements. It starts by selecting the largest element in the list and partitioning the remaining elements into two smaller sub-lists. It then recursively sorts the two sub-lists and combines them back into the original list."}
{"question": "Consider the following equations concerning a stack module that has the operations Push, Pop, Top, and IsEmpty. Which of the equations does NOT represent the conventional semantics of a stack?", "choices": [{"label": "A", "text": "IsEmpty(Push(Stack,Elem)) = true"}, {"label": "B", "text": "Pop(Push(Stack,Elem)) = Stack"}, {"label": "C", "text": "Top(Push(Stack,Elem)) = Elem"}, {"label": "D", "text": "IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false"}], "answerKey": "A", "model_answer": "The correct answer is (A) IsEmpty(Push(Stack,Elem)) = true.\n\nThis equation represents a peculiar semantics for the stack, where the IsEmpty function returns true when the Push function is called with one element on an empty stack. This is not the conventional semantics for a stack, which typically defines IsEmpty as a boolean function that returns true if the stack is empty and false otherwise. The other equations represent the expected semantics for a stack:\n\n* (B) Pop(Push(Stack,Elem)) = Stack: This equation states that the element on top of the stack is removed by the Pop function when the Push function is called with one element.\n* (C) Top(Push(Stack,Elem)) = Elem: This equation states that the element that is pushed onto the stack is the same as the one that is accessed by the Top function.\n* (D) IsEmpty(Push(Push(Stack,Elem1),Elem2)) = false: This equation states that the IsEmpty function returns false when the Push function is called with two elements on an empty stack. This is not the conventional semantics for a stack, where IsEmpty is defined as a boolean function that returns"}
{"question": "Assume that any assignment statement can be executed in unit time. If as many identical processors as needed are used, what is the minimum number of time units needed to execute the assignments\nA := B + C\nB := A - B\nC := A * E\nD := A/F\nE := B - C\nF := A + B\nwith the same result as if the assignments were executed in the order shown?", "choices": [{"label": "A", "text": "1"}, {"label": "B", "text": "2"}, {"label": "C", "text": "3"}, {"label": "D", "text": "4"}], "answerKey": "C", "model_answer": "The correct answer is (C) 3 time units.\n\nAssuming that any assignment statement can be executed in unit time, each assignment statement will take 1 time unit to execute. Therefore, if we need to execute the assignments in the order shown, it will take a total of 3 time units:\n\n1 time unit for A := B + C\n1 time unit for B := A - B\n1 time unit for C := A*E\n1 time unit for D := A/F\n1 time unit for E := B - C\n1 time unit for F := A + B\n\nThe total time required to execute the assignments using these processors is 3 time units. Therefore, the minimum number of time units needed to execute the assignments is 3."}
{"question": "Two expressions E and F are said to be unifiable if there are substitutions for the variables of E and F that make the expressions lexically identical. In the following three expressions, only w, x, y, and z are variables.\nI. f(w,w)\nII. f(x,1)\nIII. f(y,g(z))\nWhich pairs of these expressions is (are) pairs of unifiable expressions?", "choices": [{"label": "A", "text": "(I, II) only"}, {"label": "B", "text": "(I, III) only"}, {"label": "C", "text": "(II, III) only"}, {"label": "D", "text": "(I, II) and (I, III) only"}], "answerKey": "D", "model_answer": "The correct answer is (D) (I, II) and (I, III) only.\nThe first pair, (I, II), is unifiable because we can substitute f(w,w) for f(x,1), and we can substitute g(z) for y in (III), so (I, II) and (I, III) are unifiable.\nHowever, (II, III) is not unifiable because we cannot substitute f(w,w) for f(x,1), and we cannot substitute g(z) for y in (III).\nTherefore, the correct answer is (D) (I, II) and (I, III) only."}
{"question": "Which of the following instruction-set features is NOT generally considered an obstacle to aggressive pipelining of an integer unit?", "choices": [{"label": "A", "text": "Condition codes set by every instruction"}, {"label": "B", "text": "Variable-length encoding of instructions"}, {"label": "C", "text": "Instructions requiring widely varying numbers of cycles to execute"}, {"label": "D", "text": "Several different classes (sets) of registers"}], "answerKey": "D", "model_answer": "The correct answer is (D) Several different classes (sets) of registers.\nA pipeline must be able to handle instructions with widely varying numbers of cycles to execute, and this can be a challenge for aggressive pipelining. However, instructions that require different sets of registers can also be a challenge, as they may need to wait for register resources to become available, which can slow down the execution of the pipeline.\nIt is not necessarily true that condition codes set by every instruction can be an obstacle to aggressive pipelining, as condition codes can be used to prevent hazards and synchronize the execution of instructions.\nVariable-length encoding of instructions can also be a challenge for pipelining, as it may require additional resources and processing to handle the varying lengths of instructions. However, this is not generally considered an obstacle to aggressive pipelining.\nTherefore, the correct answer is (D) Several different classes (sets) of registers."}
{"question": "Let k >= 2. Let L be the set of strings in {0, 1}^* such that x \\in L if and only if the number of 0's in x is divisible by k and the number of 1's in x is odd. The minimum number of states in a deterministic finite automaton (DFA) that recognizes L is", "choices": [{"label": "A", "text": "k + 2"}, {"label": "B", "text": "2k"}, {"label": "C", "text": "k log k"}, {"label": "D", "text": "k^2"}], "answerKey": "B", "model_answer": "The correct answer is (D) k^2.\nThe minimum number of states in a deterministic finite automaton (DFA) that recognizes L is equal to 2^k, where k is the number of 1's in a string of length k. This is because a DFA consists of a set of states and a set of transitions between states, and each state can have at most 2^k possible configurations, one for each possible input string of length k. Therefore, the DFA that recognizes L has 2^k states, and this is the minimum number of states that can recognize the language L.\nTherefore, the correct answer is (D) k^2."}
{"question": "Let G = (V, E) be a finite directed acyclic graph with |E| > 0. Which of the following must be true?\nI. G has a vertex with no incoming edge.\nII. G has a vertex with no outgoing edge.\nIII. G has an isolated vertex, that is, one with neither an incoming edge nor an outgoing edge.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "D", "model_answer": "The correct answer is (A) I only.\nStatement I implies that there is at least one vertex in the graph G that has no incoming edge. This means that the graph is not connected, and therefore it does not have a cycle. Therefore, if the graph is finite and directed, it must have a vertex with no incoming edge.\nStatement II implies that there is at least one vertex in the graph G that has no outgoing edge. This means that the graph is not connected, and therefore it does not have a cycle. Therefore, if the graph is finite and directed, it must have a vertex with no outgoing edge.\nStatement III implies that there is at least one vertex in the graph G that has neither an incoming edge nor an outgoing edge. This means that the graph is not connected, and therefore it does not have a cycle. Therefore, if the graph is finite and directed, it must have an isolated vertex.\nTherefore, the answer is (A) I only, which means that at least one vertex in the graph G has no incoming edge."}
{"question": "Let T be a depth-first search tree of a connected undirected graph G. For each vertex v of T, let pre(v) be the number of nodes visited up to and including v during a preorder traversal of T, and post(v) be the number of nodes visited up to and including v during a postorder traversal of T. The lowest common ancestor of vertices u and v in T is a vertex w of T such that w is an ancestor of both u and v, and no child of w is an ancestor of both u and v. Let (u, v) be an edge in G that is not in T, such that pre(u) < pre(v). Which of the following statements about u and v must be true?\nI. post(u) < post(v)\nII. u is an ancestor of v in T.\nIII. If w is the lowest common ancestor of u and v in T, then w = u.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "The correct answer is (D) II and III.\nStatement II is true because, by definition of lowest common ancestor, u and v are ancestors of each other in T, and u is not an ancestor of v in T. Statement III is also true because if w is the lowest common ancestor of u and v in T, then w must be an ancestor of both u and v, and no child of w is an ancestor of both u and v. Therefore, w must be equal to u.\nSo, the statement \"(u, v) is an edge in G that is not in T, such that pre(u) < pre(v) implies that u is an ancestor of v in T and that the lowest common ancestor of u and v in T equals u\" is a true statement."}
{"question": "In systems with support for automatic memory management, a garbage collector typically has the responsibility for reclaiming allocated memory objects whose contents cannot affect any future legal computation. Such objects are identified by determining that they cannot be reached from a root set. Which of the following is NOT part of the root set in a typical garbage collector?", "choices": [{"label": "A", "text": "Actual parameters of the active procedures"}, {"label": "B", "text": "Dynamically allocated objects on the heap"}, {"label": "C", "text": "Global variables of the program"}, {"label": "D", "text": "Local variables on the call stack"}], "answerKey": "B", "model_answer": "The correct answer is (C) Global variables of the program.\nIn a typical garbage collector, the root set typically includes all the global variables of the program. Global variables are variables that are shared between multiple objects in the program and are typically stored on the heap. The garbage collector is responsible for reclaiming memory objects that are no longer reachable from the root set, which in this case, would include the global variables.\nThe other choices listed (A) Actual parameters of the active procedures, (B) Dynamically allocated objects on the heap, and (D) Local variables on the call stack are not part of the root set in a typical garbage collector. Actual parameters are variables that are passed as arguments to a function and are typically stored in registers or on the stack. They are not usually stored on the heap. Dynamically allocated objects on the heap are typically not part of the root set because they are not shared between multiple objects in the program and are typically stored separately from global variables. Global variables are stored on the heap, but they are not part of the call stack. Local variables on the call stack are typically not part of the root set either because they are only accessible within the scope of a single function call and are not shared"}
{"question": "In the Internet Protocol (IP) suite of protocols, which of the following best describes the purpose of the Address Resolution Protocol?", "choices": [{"label": "A", "text": "To translate Web addresses to host names"}, {"label": "B", "text": "To determine the IP address of a given host name"}, {"label": "C", "text": "To determine the hardware address of a given host name"}, {"label": "D", "text": "To determine the hardware address of a given IP address"}], "answerKey": "D", "model_answer": "The correct answer is (D): To determine the hardware address of a given IP address, which is also known as the Physical Address. The Address Resolution Protocol (ARP) is a protocol in the Internet Protocol (IP) suite of protocols that is used to map an IP address to a hardware address, which is also known as a \"Physical Address\" or \"Media Access Control (MAC) address\". The ARP protocol is used by devices on a network to determine the hardware address of a device on the network that has a known IP address. The ARP protocol is typically used to resolve the IP address of a device to its corresponding hardware address so that data can be transmitted between devices on the network."}
{"question": "Which of the following language features requires that stack-based storage allocation be used rather than static allocation?", "choices": [{"label": "A", "text": "Recursive procedures"}, {"label": "B", "text": "Arbitrary goto's"}, {"label": "C", "text": "Two-dimensional arrays"}, {"label": "D", "text": "Integer-valued functions"}], "answerKey": "A", "model_answer": "The correct answer is (D) Integer-valued functions.\nRecursive procedures and two-dimensional arrays do not require stack-based storage allocation. Arbitrary goto's are also not related to the question, as it is about language features instead of programming techniques or structures. Integer-valued functions, on the other hand, can be implemented using stack-based storage allocation if the function returns a value that needs to be pushed onto the stack (e.g. a return value) or if the function calls itself recursively.\nPlease note that my knowledge cutoff is 2021, so my answer might be subject to change if there are any updates in the future."}
{"question": "Which of the following is not a sentence that is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z?", "choices": [{"label": "A", "text": "xyz"}, {"label": "B", "text": "xy"}, {"label": "C", "text": "xxzy"}, {"label": "D", "text": "xxxxy"}], "answerKey": "A", "model_answer": "The correct answer is (B) xy.\nThe sentence \"xy\" is generated by the grammar A -> BC, B -> x|Bx, C -> B|D, D -> y|Ey, E -> z, where BC is \"xy\" and A is \"x\".\nThe other choices do not follow the grammar rules. For example, \"xyz\" would require \"x\" to be a terminal symbol, which it is not. \"xxzy\" would require \"y\" to be a terminal symbol, which it is not. \"xxxxy\" would require \"x\" to be a terminal symbol, which it is not, and it also does not follow the grammar rules."}
{"question": "Let T (n) be defined by T(1) = 7 and T(n + 1) = 3n + T(n) for all integers n \u2265 1. Which of the following represents the order of growth of T(n) as a function of n?", "choices": [{"label": "A", "text": "\u0398(n)"}, {"label": "B", "text": "\u0398(n log n)"}, {"label": "C", "text": "\u0398(n^2)"}, {"label": "D", "text": "\u0398(n^2 log n)"}], "answerKey": "C", "model_answer": "The given recurrence relation T(n) = 3n + T(n - 1) for all integers n \u2265 1 suggests that the order of growth of T(n) is O(n^2). This is because the inner loop of the recurrence relation requires T(n - 1) which increases the order of the recurrence relation from n to n^2.\nTherefore, the correct answer is C) \u0398(n^2).\nPlease note that the other choices (A) \u0398(n), (B) \u0398(n log n), and (D) \u0398(n^2 log n) are incorrect as they do not fit the given recurrence relation."}
{"question": "Which of the following problems is (are) decidable?\nI. Given a (finite) string w, is w a prefix of the decimal expansion of \u03c0?\nII. Given a program and an input, is the program\u2019s output the decimal expansion of \u03c0?\nIII. Given a program that takes as input a prefix of the decimal expansion of \u03c0, is the program\u2019s output always the same for every prefix?", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "The correct answer is (C) III only.\nThe question asks about decidability of problems, which is the ability to determine whether a problem has a solution or not. The first problem asks about a specific string of characters (w) and whether it is a prefix of the decimal expansion of \u03c0. This problem can be solved by checking if the first few characters of w are the same as the first few digits of \u03c0's decimal expansion. This is a decidable problem because it can be checked if the input is a prefix of the output, and the answer is either true or false.\nThe second problem asks about a specific program and its output. This problem is not decidable because the output of a program can depend on many factors, including the input, the hardware, and the programming language. There is no definite answer to whether the output of a program is the decimal expansion of \u03c0 or not.\nThe third problem asks about a specific program and its input. This problem is also not decidable because the output of a program can depend on many factors, including the input, the hardware, and the programming language. There is no definite answer to whether the program's output is always the same for every prefix.\nIn conclusion, the"}
{"question": "Which of the following statements about circuits is (are) true?\nI. Combinational circuits may have feedback; sequential circuits do not.\nII. Combinational circuits have a \"memoryless\" property; sequential circuits do not.\nIII. Both sequential and combinational circuits must be controlled by an external clock.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "The correct answer is (C) I and II only.\nStatement (I) is correct. Combinational circuits may have feedback, while sequential circuits do not.\nStatement (II) is also correct. Combinational circuits have a \"memoryless\" property, while sequential circuits do not.\nStatement (III) is incorrect. Both sequential and combinational circuits may or may not be controlled by an external clock.\nTherefore, choices (A) I only, (B) II only, and (D) II and III only are incorrect."}
{"question": "Two single-user workstations are attached to the same local area network. On one of these workstations, file pages are accessed over the network from a file server; the average access time per page is 0.1 second. On the other of these workstations, file pages are accessed from a local disk; the average access time per page is 0.05 second. A particular compilation requires 30 seconds of computation and 200 file page accesses. What is the ratio of the total time required by this compilation if run on the diskless (file server) workstation to the total time required if run on the workstation with the local disk, if it is assumed that computation is not overlapped with file access?", "choices": [{"label": "A", "text": "1/1"}, {"label": "B", "text": "5/4"}, {"label": "C", "text": "5/3"}, {"label": "D", "text": "10/5"}], "answerKey": "B", "model_answer": "The correct answer is (B) 5/4.\nTo solve this problem, we need to calculate the total time required for the compilation on the diskless workstation and compare it to the total time required on the workstation with the local disk.\nThe average access time per page on the diskless workstation is 0.1 second, so it will take 200 page accesses x 0.1 seconds per access = 200 seconds.\nThe total time required for the compilation on the diskless workstation is 30 seconds + 200 seconds = 230 seconds.\nOn the other hand, the average access time per page on the workstation with the local disk is 0.05 second, so it will take 200 page accesses x 0.05 seconds per access = 10 seconds.\nThe total time required for the compilation on the workstation with the local disk is 30 seconds + 10 seconds = 40 seconds.\nSince the total time required on the diskless workstation is greater than the total time required on the workstation with the local disk, the ratio of the total time required by the compilation on the diskless work"}
{"question": "Assume that a debugger places a breakpoint at a load instruction at virtual address 0x77E81234 (hexadecimal notation) in a debugged process P. If the text segment of P begins at 0x77E80000 in P\u2019s virtual address space and if the debugger has mapped this same text segment at 0x01000000 in its virtual address space, which of the following is the virtual address used by the debugger in its WRITE operation, along with a description of how the debugger has mapped the virtual memory page containing this address?", "choices": [{"label": "A", "text": "0x01001234; page mapped with READ/WRITE access"}, {"label": "B", "text": "0x01001234; page mapped with COPY-ON-WRITE access"}, {"label": "C", "text": "0x76E81234; page mapped with READ/WRITE access"}, {"label": "D", "text": "0x76E81234; page mapped with COPY-ON-WRITE access"}], "answerKey": "A", "model_answer": "The correct answer is (B) 0x01001234; page mapped with COPY-ON-WRITE access.\n\nIn this question, the debugger has mapped the same text segment at 0x01000000 in its virtual address space. Therefore, when the debugger performs a WRITE operation at virtual address 0x77E81234, it will use the virtual address 0x01001234 for the write operation. This is because the debugger has used the COPY-ON-WRITE technique, which involves copying data to a new page before modifying it. So, the debugger will first copy the data from the 0x01000000 page to a new page before modifying it, and then modify the data in the new page. This way, the original data in the 0x01000000 page remains unchanged and the modified data is available in the new page."}
{"question": "Which of the following considerations applies (apply) to choosing the page size in a paging system?\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III only"}, {"label": "D", "text": "I, II, and III"}], "answerKey": "D", "model_answer": "The correct answer is (D) I, II, and III.\nI. An advantage of larger pages is that they lead to smaller page tables.\nII. An advantage of smaller pages is that they lead to less waste due to internal fragmentation.\nIII. Normally, the dominant factor in disk access time is not dependent on page length, so longer pages can be used advantageously."}
{"question": "Two processors, M-5 and M-7, implement the same instruction set. Processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. Processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds. Which of the following is (are) true?\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline.\nII. The latency of a single instruction is shorter on M-7\u2019s pipeline than on M-5\u2019s pipeline.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and III"}, {"label": "D", "text": "II and III"}], "answerKey": "A", "model_answer": "Answer: C - I and III\nExplanation: The statement that \"processor M-7 uses a 7-stage pipeline and a clock cycle of 7.5 nanoseconds\" implies that the pipeline can hold seven instructions, and each instruction takes 7.5 nanoseconds to complete. Therefore, the pipeline can support a maximum throughput of seven instructions per clock cycle.\nOn the other hand, processor M-5 uses a 5-stage pipeline and a clock cycle of 10 nanoseconds. This means that the pipeline can hold five instructions, and each instruction takes 10 nanoseconds to complete. Therefore, the pipeline can support a maximum throughput of five instructions per clock cycle.\nSo, the answer is (C) I and III.\nI. M-7\u2019s pipeline has better maximum throughput than M-5\u2019s pipeline. This is true because the 7-stage pipeline of M-7 can process more instructions per clock cycle than the 5-stage pipeline of M-5.\nIII. Programs executing on M-7 will always run faster than programs executing on M-5. This is also true because the 7-stage pipeline of M-"}
{"question": "Which of the following pairs of 8-bit, two's-complement numbers will result in overflow when the members of the pairs are added?", "choices": [{"label": "A", "text": "11111111, 00000001"}, {"label": "B", "text": "00000001, 10000000"}, {"label": "C", "text": "11111111, 10000001"}, {"label": "D", "text": "10000001, 10101010"}], "answerKey": "D", "model_answer": "The correct answer is (D) 10000001, 10101010.\nWhen the two's-complement numbers in the pairs are added, they will result in overflow since they are both 8 bits and cannot represent values greater than 255. The only pair that will not result in overflow is (D) 10000001, 10101010 because the numbers have different signs and are therefore not complementary."}
{"question": "Two computers communicate with each other by sending data packets across a local area network. The size of these packets is 1,000 bytes. The network has the capacity to carry 1,000 packets per second. The CPU time required to execute the network protocol to send one packet is 10 milliseconds. The maximum rate at which one computer can send data to another is approximately", "choices": [{"label": "A", "text": "10,000 bytes/second"}, {"label": "B", "text": "25,000 bytes/ second"}, {"label": "C", "text": "100,000 bytes/ second"}, {"label": "D", "text": "500,000 bytes/ second"}], "answerKey": "C", "model_answer": "The correct answer is (C) 100,000 bytes/second.\nTo determine the maximum rate at which one computer can send data to another, we need to calculate the maximum size of each data packet (1,000 bytes) multiplied by the number of packets per second (1,000) divided by the CPU time required to execute the network protocol (10 milliseconds).\n1,000 bytes x 1,000 packets/s / 10 milliseconds = 100,000 bytes/second\nTherefore, the maximum rate at which one computer can send data to another is approximately 100,000 bytes/second."}
{"question": "Consider the following grammar.\nS \u2192 ( S )\nS \u2192 x\nWhich of the following statements is (are) true?\nI. The grammar is ambiguous.\nII. The grammar is suitable for top-down parsing.\nIII. The grammar is suitable for bottom-up parsing.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III only"}], "answerKey": "D", "model_answer": "The correct answer is (C) III only.\nThe given grammar is suitable for bottom-up parsing, which is a type of parsing that works from the leaves (i.e., non-terminals) to the top (i.e., terminals). This is because the grammar has two non-terminals, S and x, which are used to construct strings. The production rule S \u2192 (S) allows for the construction of a string that contains itself, which is a common technique used in bottom-up parsing.\nOn the other hand, the grammar is not suitable for top-down parsing, which is a type of parsing that works from the top (i.e., terminals) to the bottom (i.e., non-terminals). This is because the grammar only has two terminals (i.e., the empty string and the string \"x\"), which are not sufficient for constructing a parse tree using top-down parsing. The production rule S \u2192 x does not create any new non-terminals, so there is no opportunity to construct a parse tree using top-down parsing.\nTherefore, only statement III is true, and option C is the correct answer."}
{"question": "Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT:", "choices": [{"label": "A", "text": "Counting distinct values: Given a set of n keys, determine the number of distinct key values."}, {"label": "B", "text": "Dynamic dictionary: Support the operations of insert, delete, and search in a dictionary."}, {"label": "C", "text": "Range search: Given values a and b, find all the records whose key value is in the range a, b."}, {"label": "D", "text": "Symbol table lookup: Given a program identifier, find its type and address."}], "answerKey": "C", "model_answer": "The correct answer is (C) Range search. Hash tables can contribute to an efficient average-case solution for all of the problems described below EXCEPT for range search. This is because hash tables are designed to handle key-value pairs, and range search involves finding records within a certain key range. Other problems, such as dynamic dictionaries and symbol table lookups, can be addressed using hash tables, but range search may not be the most efficient approach."}
{"question": "Let A be a finite set with m elements, and let B be a finite set with n elements. The number of distinct functions mapping A into B is", "choices": [{"label": "A", "text": "n^m"}, {"label": "B", "text": "n!/(n - m)!"}, {"label": "C", "text": "n!"}, {"label": "D", "text": "n!/(m!(n - m)!)"}], "answerKey": "A", "model_answer": "The correct answer is (C) n!/(m!).\nThe number of distinct functions mapping A into B is equal to the number of ways to choose m elements from A and n - m elements from B, which is (n - m)!. However, we want to choose m elements from A and n - m elements from B that are pairwise different, which means we cannot choose the same element twice. Therefore, the number of distinct functions is n! / (m!).\nTherefore, the correct answer is (C) n!/(m!)."}
{"question": "To compute the matrix product M_1M_2, where M_1 has p rows and q columns and where M_2 has q rows and r columns, takes time proportional to pqr, and the result is a matrix of p rows and r columns. Consider the product of three matrices N_1N_2N_3 that have, respectively, w rows and x columns, x rows and y columns, and y rows and z columns. Under what condition will it take less time to compute the product as (N_1N_2)N_3 (i.e., multiply the first two matrices first) than to compute it as N_1(N_2 N_3)?", "choices": [{"label": "A", "text": "There is no such condition; i.e., they will always take the same time."}, {"label": "B", "text": "1/x + 1/z < 1/w + 1/y"}, {"label": "C", "text": "x > y"}, {"label": "D", "text": "1/w + 1/x < 1/y + 1/z"}], "answerKey": "B", "model_answer": "The correct answer is (C) x > y.\nTo compute the matrix product M_1M_2M_3, where M_1 has w rows and x columns, M_2 has x rows and y columns, and M_3 has y rows and z columns, it will take time proportional to wxyz, and the result is a matrix of w rows and z columns.\nIf we compute the product M_1M_2 first and then M_2M_3, it will take less time than computing it as M_1(M_2M_3) because the number of computations required is smaller in the first case.\nTherefore, the answer is (C) x > y."}
{"question": "The hit ratio of a cache memory is the percentage of accesses (reads and writes) for which data are found in the cache. Write-through is a policy whereby every write operation updates main memory. Write-back is a policy whereby a write operation to a line found in the cache does not affect main memory until the line is evicted from the cache. Write-allocation is a policy whereby a cache line is allocated and loaded on a write-miss. If it is assumed that write-allocation is always used, which of the following is true?", "choices": [{"label": "A", "text": "Write-back usually results in a better hit ratio than write-through."}, {"label": "B", "text": "Write-through usually results in a better hit ratio than write-back."}, {"label": "C", "text": "The percentage of write operations resulting in a main memory operation will never be larger for write-back than for write-through."}, {"label": "D", "text": "The percentage of write operations resulting in a main memory operation will never be larger for writethrough than for write-back."}], "answerKey": "C", "model_answer": "The correct answer is option (A) Write-back usually results in a better hit ratio than write-through.\n\nThis is because write-back ensures that the changes made to the cache are automatically reflected in main memory, while write-through requires an explicit write command to be issued to update main memory. This means that write-back reduces the number of writes to main memory, and since caches are typically smaller than main memory, this reduces the number of cache misses and increases the hit ratio."}
{"question": "A particular disk unit uses a bit string to record the occupancy or vacancy of its tracks, with O denoting vacant and 1 denoting occupied. A 32-bit segment of this string has the hexadecimal value D4FE2003. The percentage of occupied tracks for the corresponding part of the disk, to the nearest percent, is", "choices": [{"label": "A", "text": "12%"}, {"label": "B", "text": "25%"}, {"label": "C", "text": "38%"}, {"label": "D", "text": "44%"}], "answerKey": "D", "model_answer": "The correct answer is (B) 25%.\nTo calculate the percentage of occupied tracks, we need to divide the number of occupied tracks by the total number of tracks and then multiply by 100.\nThe bit string value D4FE2003 represents a 32-bit segment of the string used to record the occupancy or vacancy of tracks on the disk. The number of occupied tracks can be found by looking up the corresponding bit value in the string.\nTherefore, the percentage of occupied tracks for the corresponding part of the disk is:\n(Number of occupied tracks / Total number of tracks) x 100\n= (Number of occupied tracks / 65535) x 100\n= (Number of occupied tracks / 65535)\n= 0.0018 x 100\n= 1.8%\nThe correct answer is (B) 25%."}
{"question": "An Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. Which of the following undirected graphs must have an Euler circuit?\nI. A complete graph with 12 vertices\nII. A complete graph with 13 vertices\nIII. A tree with 13 vertices", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II"}], "answerKey": "B", "model_answer": "The correct answer is D, I and II.\nAn Euler circuit of an undirected graph is a circuit in which each edge of the graph appears exactly once. In other words, all vertices are visited exactly once, and no vertex is visited twice. For a connected undirected graph with n vertices, an Euler circuit exists if and only if n is odd.\nTherefore, for the given question, all three graphs must have an Euler circuit.\n\nI. A complete graph with 12 vertices has 12 vertices and no edge appears twice, so an Euler circuit exists.\n\nII. A complete graph with 13 vertices has 13 vertices and no edge appears twice, so an Euler circuit exists.\n\nIII. A tree with 13 vertices has 13 vertices and no edge appears twice, so an Euler circuit exists."}
{"question": "Which of the following characteristics of a programming language is best specified using a context-free grammar?", "choices": [{"label": "A", "text": "Identifier length"}, {"label": "B", "text": "Maximum level of nesting"}, {"label": "C", "text": "Operator precedence"}, {"label": "D", "text": "Type compatibility"}], "answerKey": "C", "model_answer": "The correct answer is option B: Maximum level of nesting.\nA context-free grammar is a formal language description that specifies a set of strings (or sequences of symbols) using a set of production rules (also known as grammatical rules). A context-free grammar can be used to describe a programming language, which is a set of rules for how to write programs in a particular language.\nOption A, identifier length, is not typically specified using a context-free grammar. This is because identifiers in a programming language typically follow a set of rules or conventions, such as having a specific length, but these rules are not necessarily described using a context-free grammar.\nOption C, operator precedence, is also not specified using a context-free grammar. Operator precedence is a rule for determining the order in which operators are applied to operands in a programming language. While this rule is important for the correct syntax of a program, it is not typically specified using a context-free grammar.\nOption D, type compatibility, is also not typically specified using a context-free grammar. This is because type compatibility rules in a programming language are typically defined using type systems or other formalisms that are not necessarily specified using a context-"}
{"question": "Which of the following statements about datagrams sent by a node in a network using IPv4 protocol is (are) true?\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination.\nII. Datagrams may be fragmented during routing.\nIII. Datagrams are reassembled only at the destination.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "II and III"}], "answerKey": "D", "model_answer": "The correct answer is (D) II and III.\nBoth statements II and III are true.\nII. Datagrams may be fragmented during routing, meaning that if the datagram is larger than the MTU of the next hop, it will be divided into smaller chunks called fragments.\nIII. Datagrams are reassembled only at the destination, meaning that the destination node will receive the fragments, reassemble them, and process the original datagram.\n\nI. Datagrams at the source must be the size of the smallest maximum transmission unit (MTU) of all the links on a path to the destination is not true. Fragmentation occurs when the datagram is larger than the MTU of the next hop, and the datagram will be divided into smaller fragments."}
{"question": "A starvation-free job-scheduling policy guarantees that no job waits indefinitely for service. Which of the following job-scheduling policies is starvation-free?", "choices": [{"label": "A", "text": "Round-robin"}, {"label": "B", "text": "Priority queuing"}, {"label": "C", "text": "Shortest job first"}, {"label": "D", "text": "Youngest job first"}], "answerKey": "A", "model_answer": "The correct answer is (A) Round-robin, because a round-robin policy schedules jobs in a circular manner, meaning that each job gets an equal amount of time to complete its service. This ensures that no job waits indefinitely for service and therefore guarantees that the policy is starvation-free.\n\nOn the other hand, policies like (B) Priority queuing and (C) Shortest job first do not guarantee that no job waits indefinitely for service. In priority queuing, the jobs are sorted based on their priority, but there is no guarantee that lower-priority jobs will not wait indefinitely for service if there are not enough resources available. Similarly, in shortest job first, the jobs are sorted based on their length, but there is no guarantee that shorter jobs will not wait indefinitely for service if there are not enough resources available.\n\n(D) Youngest job first means that the job that was completed the most recently is scheduled first, but there is no guarantee that the job will not wait indefinitely for service if there are not enough resources available."}
{"question": "Of the following, which gives the best upper bound for the value of f(N) where f is a solution to the recurrence f(2N + 1) = f(2N) = f(N) + log N for N >= 1, with f(1) = 0?", "choices": [{"label": "A", "text": "O(log N)"}, {"label": "B", "text": "O(N log N)"}, {"label": "C", "text": "O(log N) + 0(1)"}, {"label": "D", "text": "O((log N)^2)"}], "answerKey": "D", "model_answer": "The correct answer is (B) O(N log N).\nThe recurrence relation given in the question can be solved by using the master theorem. The master theorem states that if a problem can be reduced to a special case of the divide-and-conquer algorithm, then the time complexity of the problem is O(n^k), where n is the size of the input and k is a constant.\nIn this case, the special case of the divide-and-conquer algorithm is the recurrence relation f(n+1) = f(n) + log(n). This recurrence relation can be solved using the master theorem, and the time complexity of the problem is O(N log N), where N is the size of the input.\nTherefore, the best upper bound for the value of f(N) is O(N log N)."}
{"question": "Company X shipped 5 computer chips, 1 of which was defective, and Company Y shipped 4 computer chips, 2 of which were defective. One computer chip is to be chosen uniformly at random from the 9 chips shipped by the companies. If the chosen chip is found to be defective, what is the probability that the chip came from Company Y?", "choices": [{"label": "A", "text": "2 / 9"}, {"label": "B", "text": "4 / 9"}, {"label": "C", "text": "1 / 2"}, {"label": "D", "text": "2 / 3"}], "answerKey": "D", "model_answer": "The correct answer is (A) 2/9.\nThis problem can be solved by applying the binomial distribution. The probability that a randomly chosen chip is defective is:\nP(D) = (1/5) \\* (4/9) + (1/5) \\* (1/9) = 3/9 = 0.333\nNow, we want to find the probability that a defective chip is chosen if the chip is chosen uniformly at random from the 9 chips shipped by the companies. This can be found by multiplying the probability of a defective chip by the number of chips shipped by each company.\nP(D|Company X) \\* (1/5) + P(D|Company Y) \\* (2/5) = 2/9\nSubstituting the values of P(D|Company X) and P(D|Company Y) from the problem statement:\nP(D|Company X) \\* (1/5) + P(D|Company Y) \\* (2/5) = 3/9\nP(D|Company Y) = 2/3\nSo the correct"}
{"question": "Which of the following problems can be solved by a standard greedy algorithm?\nI. Finding a minimum spanning tree in an undirected graph with positive-integer edge weights\nII. Finding a maximum clique in an undirected graph\nIII. Finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and II only"}], "answerKey": "A", "model_answer": "The correct answer is (D) I and II only. A standard greedy algorithm can solve both of these problems but not the third problem.\nAn example of a greedy algorithm for finding a minimum spanning tree is the following:\n1. Start with a single node and add it to the tree if possible.\n2. For each neighboring node, if adding it to the tree would not increase the total weight of the tree, then add it and remove the edge from the original node.\n3. Keep repeating the above steps until the tree is complete.\nAn example of a greedy algorithm for finding a maximum clique is the following:\n1. Start with a single node and add it to the clique if it has no neighbors in the current clique.\n2. For each neighboring node, if adding it to the clique would not decrease the size of the clique, then add it and remove the edge from the original node.\n3. Keep repeating the above steps until the clique is complete.\nA standard greedy algorithm cannot solve the third problem, finding a maximum flow from a source node to a sink node in a directed graph with positive-integer edge capacities, because it may not always find the maximum"}
{"question": "A program that checks spelling works in the following way. A hash table has been defined in which each entry is a Boolean variable initialized to false. A hash function has been applied to each word in the dictionary, and the appropriate entry in the hash table has been set to true. To check the spelling in a document, the hash function is applied to every word in the document, and the appropriate entry in the hash table is examined. Which of the following is (are) correct?\nI. true means the word was in the dictionary.\nII. false means the word was not in the dictionary.\nIII. Hash table size should increase with document size.", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "II and III only"}], "answerKey": "B", "model_answer": "The correct answer is (D) II and III only.\nThe hash table is being used to store the spelling of words in a dictionary. The hash function is applied to each word in the dictionary to determine the location in the hash table where the word should be stored. The entry in the hash table is then examined to determine whether the word was in the dictionary or not.\nTherefore, the answer (D) II and III only is correct. The hash table size should not increase with document size, and the meaning of the Boolean variable true and false in the hash table is not relevant to the correctness of the program."}
{"question": "One approach to handling fuzzy logic data might be to design a computer using ternary (base-3) logic so that data could be stored as \u201ctrue,\u201d \u201cfalse,\u201d and \u201cunknown.\u201d If each ternary logic element is called a flit, how many flits are required to represent at least 256 different values?", "choices": [{"label": "A", "text": "4"}, {"label": "B", "text": "5"}, {"label": "C", "text": "6"}, {"label": "D", "text": "7"}], "answerKey": "C", "model_answer": "The correct answer is (C) 6.\nTo represent at least 256 different values with ternary logic, we need to have at least 256 different flits. Since 2 to the power of 7 is equal to 128, we need 6 bits to represent 256 different values. (4 bits can represent 16 values, 5 bits can represent 32 values, and 6 bits can represent 64 values.) Therefore, the answer is (C) 6."}
{"question": "Local caching of files is common in distributed file systems, but it has the disadvantage that", "choices": [{"label": "A", "text": "Temporary inconsistencies among views of a file by different machines can result"}, {"label": "B", "text": "The file system is likely to be corrupted when a computer crashes"}, {"label": "C", "text": "A much higher amount of network traffic results"}, {"label": "D", "text": "Caching makes file migration impossible"}], "answerKey": "A", "model_answer": "The correct answer is (A) Temporary inconsistencies among views of a file by different machines can result.\nLocal caching of files in a distributed file system can create temporary inconsistencies among views of a file by different machines. These inconsistencies can lead to errors and problems when multiple machines try to access the same file simultaneously. This can be a major drawback of local caching, as it can lead to data corruption and other issues."}
{"question": "Array A contains 256 elements of 4 bytes each. Its first element is stored at physical address 4,096.\nArray B contains 512 elements of 4 bytes each. Its first element is stored at physical address 8,192.\nAssume that only arrays A and B can be cached in an initially empty, physically addressed, physically tagged, direct-mapped, 2K-byte cache with an 8-byte block size. The following loop is then executed.\nfor (i = 0; i < 256; i++)\n        A[i] = A[i] + B[2*i];\nDuring the execution of the loop, how many bytes will be written to memory if the cache has a write-through policy?", "choices": [{"label": "A", "text": "0"}, {"label": "B", "text": "256"}, {"label": "C", "text": "1024"}, {"label": "D", "text": "2048"}], "answerKey": "C", "model_answer": "The correct answer is (B) 256.\nThe loop iterates 256 times, and each iteration increments the value of A[i] by the value of B[2*i]. Since B is located at physical address 8,192, each iteration of the loop will write 4 bytes to memory. Since the cache is full with 256 elements of 4 bytes each, it can hold a maximum of 1024 bytes of data. Therefore, the total amount of data written to memory during the execution of the loop will be 1024 bytes, which is equal to 256 elements of 4 bytes each.\nTherefore, the correct answer is (B) 256."}
{"question": "At time 0, five jobs are available for execution on a single processor, with service times of 25, 15, 5, 3, and 2 time units. Which of the following is the minimum value of the average completion time of these jobs?", "choices": [{"label": "A", "text": "50"}, {"label": "B", "text": "208/5"}, {"label": "C", "text": "92/5"}, {"label": "D", "text": "10"}], "answerKey": "C", "model_answer": "The correct answer is (D) 10.\nThe average completion time of these jobs is the sum of their service times divided by the number of jobs. For this problem, there are five jobs, and their service times are 25, 15, 5, 3, and 2 time units.\nThe minimum value of the average completion time of these jobs is 10, which is equal to the service time of the job with the shortest service time (2 time units) divided by the number of jobs (5).\nThe total service time is 25 + 15 + 5 + 3 + 2 = 50 time units, but 50 / 5 = 10, which is the minimum value of the average completion time.\nThus, the correct answer is (D) 10."}
{"question": "Let G = (V, E) be a connected, undirected graph, and let a and b be two distinct vertices in V. Let P_1 be the problem of finding a shortest simple path between a and b, and let P_2 be the problem of finding a longest simple path between a and b. Which of the following statements about P_1 and P_2 is true?", "choices": [{"label": "A", "text": "Both P_1 and P_2 can be solved in polynomial time."}, {"label": "B", "text": "P_1 can be solved in polynomial time but P_2 is not known to be solvable in polynomial time."}, {"label": "C", "text": "P_1 is not known to be solvable in polynomial time but P_2 can be solved in polynomial time."}, {"label": "D", "text": "It is not known whether either P_1 or P_2 can be solved in polynomial time."}], "answerKey": "B", "model_answer": "The correct answer is (B).\nP_1 is the problem of finding a shortest simple path between two vertices a and b, which is a well-known NP-hard problem. Therefore, it is not known whether P_1 can be solved in polynomial time. On the other hand, P_2 is the problem of finding a longest simple path between a and b, which is not known to be solvable in polynomial time. Therefore, it is not known whether P_2 can be solved in polynomial time.\nIt is possible that P_1 can be solved in polynomial time if there is a polynomial-time algorithm that can solve it, but this has not been proven yet. Similarly, it is possible that P_2 can be solved in polynomial time if there is a polynomial-time algorithm that can solve it, but this has not been proven yet. However, as of now, it is not known whether P_1 can be solved in polynomial time or not, and it is not known whether P_2 can be solved in polynomial time or not."}
{"question": "A major advantage of direct mapping of a cache is its simplicity. The main disadvantage of this organization is that", "choices": [{"label": "A", "text": "it does not allow simultaneous access to the intended data and its tag"}, {"label": "B", "text": "it is more expensive than other types of cache organizations"}, {"label": "C", "text": "the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache"}, {"label": "D", "text": "its access time is greater than that of other cache organizations"}], "answerKey": "C", "model_answer": "The correct answer is (C) the cache hit ratio is degraded if two or more blocks used alternately map onto the same block frame in the cache.\nThis is because direct mapping of a cache involves assigning a block of data to a specific location in the cache, and if two or more blocks used alternately map onto the same block frame, they will overwrite each other when they are accessed, which can result in lower cache hit ratio.\nOn the other hand, (A) it does not allow simultaneous access to the intended data and its tag, is incorrect because direct mapping of a cache does not provide a tag for the data, therefore it does not allow simultaneous access to the intended data and its tag. (B) it is more expensive than other types of cache organizations, is not related to the issue of direct mapping of a cache, and (D) its access time is greater than that of other cache organizations, is also not related to the issue of direct mapping of a cache."}
{"question": "Let M be a single-tape, deterministic Turing machine with tape alphabet {blank,0,1}, and let C denote the (possibly infinite) computation of M starting with a blank tape. The input to each problem below is M, together with a positive integer n. Which of the following problems is (are) decidable?\nI. The computation C lasts for at least n steps.\nII. The computation C lasts for at least n steps, and M prints a 1 at some point after the nth step.\nIII. M scans at least n distinct tape squares during the computation C.", "choices": [{"label": "A", "text": "None"}, {"label": "B", "text": "III only"}, {"label": "C", "text": "I and II only"}, {"label": "D", "text": "I and III only"}], "answerKey": "D", "model_answer": "The correct answer is (D) I and III only.\nIt can be shown that all other problems are undecidable, meaning that there is no algorithm that can determine whether a given computation will last at least n steps or whether a given machine will scan at least n distinct tape squares.\nThe problem of determining whether a computation will last at least n steps is undecidable because it is equivalent to the halting problem, which is undecidable. This is because the question of whether a given computation will last at least n steps can be reduced to the question of whether a given Turing machine will halt on a given input, and the halting problem is undecidable.\nThe problem of determining whether a given machine will scan at least n distinct tape squares can also be reduced to the halting problem, so it is undecidable as well.\nTherefore, only the problem of determining whether a given computation will last at least n steps, and M prints a 1 at some point after the nth step is decidable."}
{"question": "A 3-way, set-associative cache is", "choices": [{"label": "A", "text": "one in which each main memory word can be stored at any of 3 cache locations"}, {"label": "B", "text": "effective only if 3 or fewer processes are running alternately on the processor"}, {"label": "C", "text": "possible only with write-back"}, {"label": "D", "text": "faster to access than a direct-mapped cache"}], "answerKey": "A", "model_answer": "The correct answer is (B) effective only if 3 or fewer processes are running alternately on the processor.\nDescription of a 3-way, set-associative cache:\nA 3-way, set-associative cache is a type of cache that has three cache lines (also known as cache slots) that can hold a set of data. Each set of data is associated with a particular address range. The cache is organized so that each memory word can be stored at any of the three cache locations. This allows for better utilization of the cache because more data can be stored in the cache. This type of cache is also known as a set-associative cache.\n\nThe key feature of a 3-way, set-associative cache that is not mentioned in the choices is that it is set-associative. This means that each memory word is associated with a set of cache lines, and each set can be stored in one of the three cache locations. This is different from a direct-mapped cache, where each memory word is stored in only one cache location.\n\nThe choice (B) is correct because a 3-way, set-associative cache is effective only if 3 or fewer processes are running"}
{"question": "Consider an object-oriented language in which all entities are objects. Two relationships arise: (1) the instance relationship, between an object and the class of which that object is a member, and (2) the subclass relationship, between a class and the superclass from which that class inherits properties. In such a language, when a message is sent to an object requesting execution of one of its methods (procedures), the method is located by following", "choices": [{"label": "A", "text": "one instance link and then zero or more subclass links"}, {"label": "B", "text": "one or more instance links and then one or more subclass links"}, {"label": "C", "text": "one or more instance links"}, {"label": "D", "text": "one subclass link and then one or more instance links"}], "answerKey": "A", "model_answer": "The correct answer is:\n(C) one or more instance links\nIn an object-oriented language, an instance relationship is established between an object and the class of which that object is a member. This relationship is established through an instance link. A subclass relationship, on the other hand, is established between a class and the superclass from which that class inherits properties. This relationship is established through a subclass link. Therefore, the correct answer is:\n(C) one or more instance links, and then"}
{"question": "In a pipelined RISC computer where all arithmetic instructions have the same CPI (cycles per instruction), which of the following actions would improve the execution time of a typical program?\nI. Increasing the clock cycle rate\nII. Disallowing any forwarding in the pipeline\nIII. Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time", "choices": [{"label": "A", "text": "I only"}, {"label": "B", "text": "II only"}, {"label": "C", "text": "III only"}, {"label": "D", "text": "I and III"}], "answerKey": "D", "model_answer": "The correct answer is D. (I) Increasing the clock cycle rate and (III) Doubling the sizes of the instruction cache and the data cache without changing the clock cycle time will both improve the execution time of a typical program.\nChoice A: I only is incorrect because while increasing the clock cycle rate will improve the execution time, it does not address the issue of the pipeline being full.\nChoice B: II only is incorrect because disallowing any forwarding in the pipeline will not allow the pipeline to operate effectively, which will result in slow execution times.\nChoice C: III only is incorrect because doubling the sizes of the instruction cache and the data cache without changing the clock cycle time will not improve the execution time of a typical program."}
{"question": "A microcomputer used for data acquisition and control is required to digitize and process four analog input signals and to output their average continually; i.e., in real time. The time for an external analog-to-digital converter (which is triggered by a CPU instruction) to digitize one input is 12 microseconds, and only one digitization occurs at a time. Five CPU instructions, including the triggering instruction, must be executed for each signal digitized. Ten CPU instructions are executed in order to average each set of four samples and output this value. The time to convert the output from digital to analog form is to be ignored. If it is assumed that suitable data buffering is employed, then the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates, is", "choices": [{"label": "A", "text": "0.8 microseconds"}, {"label": "B", "text": "1.2 microseconds"}, {"label": "C", "text": "1.6 microseconds"}, {"label": "D", "text": "2.4 microseconds"}], "answerKey": "C", "model_answer": "The correct answer is (B) 1.2 microseconds.\n\nThe given information is that the external analog-to-digital converter (ADC) takes 12 microseconds to digitize one input, and only one digitization occurs at a time. Therefore, if the microcomputer is to digitize and process all four analog signals in real time, it must be able to execute at least 12 microseconds worth of instructions for each signal.\n\nThe given time constraints are:\n\n* Five CPU instructions, including the triggering instruction, must be executed for each signal digitized.\n* Ten CPU instructions are executed in order to average each set of four samples and output this value.\n\nTherefore, the maximum average instruction execution time that allows the microcomputer to keep up with the input-output data rates is:\n\n10 instructions / signal x 5 instructions / signal x 12 microseconds / instruction = 120 microseconds\n\nSince the instructions take 12 microseconds each, this means that the microcomputer must be able to execute 120 microseconds worth of instructions in total. Therefore, the correct answer is (B) 1.2 micro"}
{"question": "Suppose that a certain software product has a mean time between failures of 10,000 hours and has a mean time to repair of 20 hours. If the product is used by 100 customers, what is its availability?", "choices": [{"label": "A", "text": "80%"}, {"label": "B", "text": "90%"}, {"label": "C", "text": "98%"}, {"label": "D", "text": "99.80%"}], "answerKey": "D", "model_answer": "The correct answer is (B) 90%.\nTo solve this problem, we can use the formula for availability:\nAvailability = (MTBF x MTTR) / (MTBF + MTTR)\nwhere MTBF is the mean time between failures, MTTR is the mean time to repair, and the formula calculates the availability of the product.\nIn this case, we are given:\nMTBF = 10,000 hours\nMTTR = 20 hours\nTherefore, the formula becomes:\nAvailability = (10,000 x 20) / (10,000 + 20)\nAvailability = 0.9\nSo, the correct answer is (B) 90%."}
